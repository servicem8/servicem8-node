/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
/**
 * Record active/deleted flag.
 *
 * @remarks
 *
 * Valid values are [0,1]
 */
export const JobActive = {
    Zero: 0,
    One: 1,
};
/**
 * (Read-only).
 *
 * @remarks
 *
 * Valid values are [0,1]
 */
export const QuoteSent = {
    Zero: 0,
    One: 1,
};
/** @internal */
export const JobActive$inboundSchema = z
    .nativeEnum(JobActive);
/** @internal */
export const JobActive$outboundSchema = JobActive$inboundSchema;
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var JobActive$;
(function (JobActive$) {
    /** @deprecated use `JobActive$inboundSchema` instead. */
    JobActive$.inboundSchema = JobActive$inboundSchema;
    /** @deprecated use `JobActive$outboundSchema` instead. */
    JobActive$.outboundSchema = JobActive$outboundSchema;
})(JobActive$ || (JobActive$ = {}));
/** @internal */
export const QuoteSent$inboundSchema = z
    .nativeEnum(QuoteSent);
/** @internal */
export const QuoteSent$outboundSchema = QuoteSent$inboundSchema;
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var QuoteSent$;
(function (QuoteSent$) {
    /** @deprecated use `QuoteSent$inboundSchema` instead. */
    QuoteSent$.inboundSchema = QuoteSent$inboundSchema;
    /** @deprecated use `QuoteSent$outboundSchema` instead. */
    QuoteSent$.outboundSchema = QuoteSent$outboundSchema;
})(QuoteSent$ || (QuoteSent$ = {}));
/** @internal */
export const RelatedKnowledgeArticle$inboundSchema = z.object({
    knowledge_article_uuid: z.string(),
    relevance: z.number(),
}).transform((v) => {
    return remap$(v, {
        "knowledge_article_uuid": "knowledgeArticleUuid",
    });
});
/** @internal */
export const RelatedKnowledgeArticle$outboundSchema = z.object({
    knowledgeArticleUuid: z.string(),
    relevance: z.number(),
}).transform((v) => {
    return remap$(v, {
        knowledgeArticleUuid: "knowledge_article_uuid",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var RelatedKnowledgeArticle$;
(function (RelatedKnowledgeArticle$) {
    /** @deprecated use `RelatedKnowledgeArticle$inboundSchema` instead. */
    RelatedKnowledgeArticle$.inboundSchema = RelatedKnowledgeArticle$inboundSchema;
    /** @deprecated use `RelatedKnowledgeArticle$outboundSchema` instead. */
    RelatedKnowledgeArticle$.outboundSchema = RelatedKnowledgeArticle$outboundSchema;
})(RelatedKnowledgeArticle$ || (RelatedKnowledgeArticle$ = {}));
export function relatedKnowledgeArticleToJSON(relatedKnowledgeArticle) {
    return JSON.stringify(RelatedKnowledgeArticle$outboundSchema.parse(relatedKnowledgeArticle));
}
export function relatedKnowledgeArticleFromJSON(jsonString) {
    return safeParse(jsonString, (x) => RelatedKnowledgeArticle$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'RelatedKnowledgeArticle' from JSON`);
}
/** @internal */
export const Job$inboundSchema = z
    .object({
    uuid: z.string().optional(),
    active: JobActive$inboundSchema.default(1),
    edit_date: z.string().optional(),
    created_by_staff_uuid: z.string().optional(),
    date: z.string().optional(),
    company_uuid: z.string().optional(),
    job_address: z.string().optional(),
    billing_address: z.string().optional(),
    status: z.string(),
    job_description: z.string().optional(),
    work_done_description: z.string().optional(),
    lng: z.number().optional(),
    lat: z.number().optional(),
    generated_job_id: z.string().optional(),
    payment_date: z.string().optional(),
    payment_actioned_by_uuid: z.string().optional(),
    payment_method: z.string().optional(),
    payment_amount: z.string().optional(),
    total_invoice_amount: z.string().optional(),
    category_uuid: z.string().optional(),
    payment_note: z.string().optional(),
    geo_is_valid: z.string().optional(),
    purchase_order_number: z.string().optional(),
    invoice_sent: z.string().optional(),
    invoice_sent_stamp: z.string().optional(),
    ready_to_invoice: z.string().optional(),
    ready_to_invoice_stamp: z.string().optional(),
    payment_processed: z.string().optional(),
    payment_processed_stamp: z.string().optional(),
    geo_country: z.string().optional(),
    geo_postcode: z.string().optional(),
    geo_state: z.string().optional(),
    geo_city: z.string().optional(),
    geo_street: z.string().optional(),
    geo_number: z.string().optional(),
    queue_uuid: z.string().optional(),
    queue_expiry_date: z.string().optional(),
    queue_assigned_staff_uuid: z.string().optional(),
    payment_received: z.string().optional(),
    payment_received_stamp: z.string().optional(),
    badges: z.string().optional(),
    quote_date: z.string().optional(),
    quote_sent: QuoteSent$inboundSchema.optional(),
    quote_sent_stamp: z.string().optional(),
    work_order_date: z.string().optional(),
    completion_date: z.string().optional(),
    completion_actioned_by_uuid: z.string().optional(),
    unsuccessful_date: z.string().optional(),
    job_is_scheduled_until_stamp: z.string().optional(),
    active_network_request_uuid: z.string().optional(),
    related_knowledge_articles: z.array(z.lazy(() => RelatedKnowledgeArticle$inboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        "edit_date": "editDate",
        "created_by_staff_uuid": "createdByStaffUuid",
        "company_uuid": "companyUuid",
        "job_address": "jobAddress",
        "billing_address": "billingAddress",
        "job_description": "jobDescription",
        "work_done_description": "workDoneDescription",
        "generated_job_id": "generatedJobId",
        "payment_date": "paymentDate",
        "payment_actioned_by_uuid": "paymentActionedByUuid",
        "payment_method": "paymentMethod",
        "payment_amount": "paymentAmount",
        "total_invoice_amount": "totalInvoiceAmount",
        "category_uuid": "categoryUuid",
        "payment_note": "paymentNote",
        "geo_is_valid": "geoIsValid",
        "purchase_order_number": "purchaseOrderNumber",
        "invoice_sent": "invoiceSent",
        "invoice_sent_stamp": "invoiceSentStamp",
        "ready_to_invoice": "readyToInvoice",
        "ready_to_invoice_stamp": "readyToInvoiceStamp",
        "payment_processed": "paymentProcessed",
        "payment_processed_stamp": "paymentProcessedStamp",
        "geo_country": "geoCountry",
        "geo_postcode": "geoPostcode",
        "geo_state": "geoState",
        "geo_city": "geoCity",
        "geo_street": "geoStreet",
        "geo_number": "geoNumber",
        "queue_uuid": "queueUuid",
        "queue_expiry_date": "queueExpiryDate",
        "queue_assigned_staff_uuid": "queueAssignedStaffUuid",
        "payment_received": "paymentReceived",
        "payment_received_stamp": "paymentReceivedStamp",
        "quote_date": "quoteDate",
        "quote_sent": "quoteSent",
        "quote_sent_stamp": "quoteSentStamp",
        "work_order_date": "workOrderDate",
        "completion_date": "completionDate",
        "completion_actioned_by_uuid": "completionActionedByUuid",
        "unsuccessful_date": "unsuccessfulDate",
        "job_is_scheduled_until_stamp": "jobIsScheduledUntilStamp",
        "active_network_request_uuid": "activeNetworkRequestUuid",
        "related_knowledge_articles": "relatedKnowledgeArticles",
    });
});
/** @internal */
export const Job$outboundSchema = z
    .object({
    uuid: z.string().optional(),
    active: JobActive$outboundSchema.default(1),
    editDate: z.string().optional(),
    createdByStaffUuid: z.string().optional(),
    date: z.string().optional(),
    companyUuid: z.string().optional(),
    jobAddress: z.string().optional(),
    billingAddress: z.string().optional(),
    status: z.string(),
    jobDescription: z.string().optional(),
    workDoneDescription: z.string().optional(),
    lng: z.number().optional(),
    lat: z.number().optional(),
    generatedJobId: z.string().optional(),
    paymentDate: z.string().optional(),
    paymentActionedByUuid: z.string().optional(),
    paymentMethod: z.string().optional(),
    paymentAmount: z.string().optional(),
    totalInvoiceAmount: z.string().optional(),
    categoryUuid: z.string().optional(),
    paymentNote: z.string().optional(),
    geoIsValid: z.string().optional(),
    purchaseOrderNumber: z.string().optional(),
    invoiceSent: z.string().optional(),
    invoiceSentStamp: z.string().optional(),
    readyToInvoice: z.string().optional(),
    readyToInvoiceStamp: z.string().optional(),
    paymentProcessed: z.string().optional(),
    paymentProcessedStamp: z.string().optional(),
    geoCountry: z.string().optional(),
    geoPostcode: z.string().optional(),
    geoState: z.string().optional(),
    geoCity: z.string().optional(),
    geoStreet: z.string().optional(),
    geoNumber: z.string().optional(),
    queueUuid: z.string().optional(),
    queueExpiryDate: z.string().optional(),
    queueAssignedStaffUuid: z.string().optional(),
    paymentReceived: z.string().optional(),
    paymentReceivedStamp: z.string().optional(),
    badges: z.string().optional(),
    quoteDate: z.string().optional(),
    quoteSent: QuoteSent$outboundSchema.optional(),
    quoteSentStamp: z.string().optional(),
    workOrderDate: z.string().optional(),
    completionDate: z.string().optional(),
    completionActionedByUuid: z.string().optional(),
    unsuccessfulDate: z.string().optional(),
    jobIsScheduledUntilStamp: z.string().optional(),
    activeNetworkRequestUuid: z.string().optional(),
    relatedKnowledgeArticles: z.array(z.lazy(() => RelatedKnowledgeArticle$outboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        editDate: "edit_date",
        createdByStaffUuid: "created_by_staff_uuid",
        companyUuid: "company_uuid",
        jobAddress: "job_address",
        billingAddress: "billing_address",
        jobDescription: "job_description",
        workDoneDescription: "work_done_description",
        generatedJobId: "generated_job_id",
        paymentDate: "payment_date",
        paymentActionedByUuid: "payment_actioned_by_uuid",
        paymentMethod: "payment_method",
        paymentAmount: "payment_amount",
        totalInvoiceAmount: "total_invoice_amount",
        categoryUuid: "category_uuid",
        paymentNote: "payment_note",
        geoIsValid: "geo_is_valid",
        purchaseOrderNumber: "purchase_order_number",
        invoiceSent: "invoice_sent",
        invoiceSentStamp: "invoice_sent_stamp",
        readyToInvoice: "ready_to_invoice",
        readyToInvoiceStamp: "ready_to_invoice_stamp",
        paymentProcessed: "payment_processed",
        paymentProcessedStamp: "payment_processed_stamp",
        geoCountry: "geo_country",
        geoPostcode: "geo_postcode",
        geoState: "geo_state",
        geoCity: "geo_city",
        geoStreet: "geo_street",
        geoNumber: "geo_number",
        queueUuid: "queue_uuid",
        queueExpiryDate: "queue_expiry_date",
        queueAssignedStaffUuid: "queue_assigned_staff_uuid",
        paymentReceived: "payment_received",
        paymentReceivedStamp: "payment_received_stamp",
        quoteDate: "quote_date",
        quoteSent: "quote_sent",
        quoteSentStamp: "quote_sent_stamp",
        workOrderDate: "work_order_date",
        completionDate: "completion_date",
        completionActionedByUuid: "completion_actioned_by_uuid",
        unsuccessfulDate: "unsuccessful_date",
        jobIsScheduledUntilStamp: "job_is_scheduled_until_stamp",
        activeNetworkRequestUuid: "active_network_request_uuid",
        relatedKnowledgeArticles: "related_knowledge_articles",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var Job$;
(function (Job$) {
    /** @deprecated use `Job$inboundSchema` instead. */
    Job$.inboundSchema = Job$inboundSchema;
    /** @deprecated use `Job$outboundSchema` instead. */
    Job$.outboundSchema = Job$outboundSchema;
})(Job$ || (Job$ = {}));
export function jobToJSON(job) {
    return JSON.stringify(Job$outboundSchema.parse(job));
}
export function jobFromJSON(jsonString) {
    return safeParse(jsonString, (x) => Job$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Job' from JSON`);
}
/** @internal */
export const JobInput$inboundSchema = z.object({
    uuid: z.string().optional(),
    active: JobActive$inboundSchema.default(1),
    created_by_staff_uuid: z.string().optional(),
    date: z.string().optional(),
    company_uuid: z.string().optional(),
    job_address: z.string().optional(),
    billing_address: z.string().optional(),
    status: z.string(),
    job_description: z.string().optional(),
    work_done_description: z.string().optional(),
    lng: z.number().optional(),
    lat: z.number().optional(),
    generated_job_id: z.string().optional(),
    payment_date: z.string().optional(),
    payment_actioned_by_uuid: z.string().optional(),
    payment_method: z.string().optional(),
    payment_amount: z.string().optional(),
    total_invoice_amount: z.string().optional(),
    category_uuid: z.string().optional(),
    payment_note: z.string().optional(),
    geo_is_valid: z.string().optional(),
    purchase_order_number: z.string().optional(),
    invoice_sent: z.string().optional(),
    invoice_sent_stamp: z.string().optional(),
    ready_to_invoice: z.string().optional(),
    ready_to_invoice_stamp: z.string().optional(),
    payment_processed: z.string().optional(),
    payment_processed_stamp: z.string().optional(),
    geo_country: z.string().optional(),
    geo_postcode: z.string().optional(),
    geo_state: z.string().optional(),
    geo_city: z.string().optional(),
    geo_street: z.string().optional(),
    geo_number: z.string().optional(),
    queue_uuid: z.string().optional(),
    queue_expiry_date: z.string().optional(),
    queue_assigned_staff_uuid: z.string().optional(),
    payment_received: z.string().optional(),
    payment_received_stamp: z.string().optional(),
    badges: z.string().optional(),
    quote_date: z.string().optional(),
    quote_sent: QuoteSent$inboundSchema.optional(),
    quote_sent_stamp: z.string().optional(),
    work_order_date: z.string().optional(),
    completion_date: z.string().optional(),
    completion_actioned_by_uuid: z.string().optional(),
    unsuccessful_date: z.string().optional(),
    job_is_scheduled_until_stamp: z.string().optional(),
    active_network_request_uuid: z.string().optional(),
    related_knowledge_articles: z.array(z.lazy(() => RelatedKnowledgeArticle$inboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        "created_by_staff_uuid": "createdByStaffUuid",
        "company_uuid": "companyUuid",
        "job_address": "jobAddress",
        "billing_address": "billingAddress",
        "job_description": "jobDescription",
        "work_done_description": "workDoneDescription",
        "generated_job_id": "generatedJobId",
        "payment_date": "paymentDate",
        "payment_actioned_by_uuid": "paymentActionedByUuid",
        "payment_method": "paymentMethod",
        "payment_amount": "paymentAmount",
        "total_invoice_amount": "totalInvoiceAmount",
        "category_uuid": "categoryUuid",
        "payment_note": "paymentNote",
        "geo_is_valid": "geoIsValid",
        "purchase_order_number": "purchaseOrderNumber",
        "invoice_sent": "invoiceSent",
        "invoice_sent_stamp": "invoiceSentStamp",
        "ready_to_invoice": "readyToInvoice",
        "ready_to_invoice_stamp": "readyToInvoiceStamp",
        "payment_processed": "paymentProcessed",
        "payment_processed_stamp": "paymentProcessedStamp",
        "geo_country": "geoCountry",
        "geo_postcode": "geoPostcode",
        "geo_state": "geoState",
        "geo_city": "geoCity",
        "geo_street": "geoStreet",
        "geo_number": "geoNumber",
        "queue_uuid": "queueUuid",
        "queue_expiry_date": "queueExpiryDate",
        "queue_assigned_staff_uuid": "queueAssignedStaffUuid",
        "payment_received": "paymentReceived",
        "payment_received_stamp": "paymentReceivedStamp",
        "quote_date": "quoteDate",
        "quote_sent": "quoteSent",
        "quote_sent_stamp": "quoteSentStamp",
        "work_order_date": "workOrderDate",
        "completion_date": "completionDate",
        "completion_actioned_by_uuid": "completionActionedByUuid",
        "unsuccessful_date": "unsuccessfulDate",
        "job_is_scheduled_until_stamp": "jobIsScheduledUntilStamp",
        "active_network_request_uuid": "activeNetworkRequestUuid",
        "related_knowledge_articles": "relatedKnowledgeArticles",
    });
});
/** @internal */
export const JobInput$outboundSchema = z.object({
    uuid: z.string().optional(),
    active: JobActive$outboundSchema.default(1),
    createdByStaffUuid: z.string().optional(),
    date: z.string().optional(),
    companyUuid: z.string().optional(),
    jobAddress: z.string().optional(),
    billingAddress: z.string().optional(),
    status: z.string(),
    jobDescription: z.string().optional(),
    workDoneDescription: z.string().optional(),
    lng: z.number().optional(),
    lat: z.number().optional(),
    generatedJobId: z.string().optional(),
    paymentDate: z.string().optional(),
    paymentActionedByUuid: z.string().optional(),
    paymentMethod: z.string().optional(),
    paymentAmount: z.string().optional(),
    totalInvoiceAmount: z.string().optional(),
    categoryUuid: z.string().optional(),
    paymentNote: z.string().optional(),
    geoIsValid: z.string().optional(),
    purchaseOrderNumber: z.string().optional(),
    invoiceSent: z.string().optional(),
    invoiceSentStamp: z.string().optional(),
    readyToInvoice: z.string().optional(),
    readyToInvoiceStamp: z.string().optional(),
    paymentProcessed: z.string().optional(),
    paymentProcessedStamp: z.string().optional(),
    geoCountry: z.string().optional(),
    geoPostcode: z.string().optional(),
    geoState: z.string().optional(),
    geoCity: z.string().optional(),
    geoStreet: z.string().optional(),
    geoNumber: z.string().optional(),
    queueUuid: z.string().optional(),
    queueExpiryDate: z.string().optional(),
    queueAssignedStaffUuid: z.string().optional(),
    paymentReceived: z.string().optional(),
    paymentReceivedStamp: z.string().optional(),
    badges: z.string().optional(),
    quoteDate: z.string().optional(),
    quoteSent: QuoteSent$outboundSchema.optional(),
    quoteSentStamp: z.string().optional(),
    workOrderDate: z.string().optional(),
    completionDate: z.string().optional(),
    completionActionedByUuid: z.string().optional(),
    unsuccessfulDate: z.string().optional(),
    jobIsScheduledUntilStamp: z.string().optional(),
    activeNetworkRequestUuid: z.string().optional(),
    relatedKnowledgeArticles: z.array(z.lazy(() => RelatedKnowledgeArticle$outboundSchema)).optional(),
}).transform((v) => {
    return remap$(v, {
        createdByStaffUuid: "created_by_staff_uuid",
        companyUuid: "company_uuid",
        jobAddress: "job_address",
        billingAddress: "billing_address",
        jobDescription: "job_description",
        workDoneDescription: "work_done_description",
        generatedJobId: "generated_job_id",
        paymentDate: "payment_date",
        paymentActionedByUuid: "payment_actioned_by_uuid",
        paymentMethod: "payment_method",
        paymentAmount: "payment_amount",
        totalInvoiceAmount: "total_invoice_amount",
        categoryUuid: "category_uuid",
        paymentNote: "payment_note",
        geoIsValid: "geo_is_valid",
        purchaseOrderNumber: "purchase_order_number",
        invoiceSent: "invoice_sent",
        invoiceSentStamp: "invoice_sent_stamp",
        readyToInvoice: "ready_to_invoice",
        readyToInvoiceStamp: "ready_to_invoice_stamp",
        paymentProcessed: "payment_processed",
        paymentProcessedStamp: "payment_processed_stamp",
        geoCountry: "geo_country",
        geoPostcode: "geo_postcode",
        geoState: "geo_state",
        geoCity: "geo_city",
        geoStreet: "geo_street",
        geoNumber: "geo_number",
        queueUuid: "queue_uuid",
        queueExpiryDate: "queue_expiry_date",
        queueAssignedStaffUuid: "queue_assigned_staff_uuid",
        paymentReceived: "payment_received",
        paymentReceivedStamp: "payment_received_stamp",
        quoteDate: "quote_date",
        quoteSent: "quote_sent",
        quoteSentStamp: "quote_sent_stamp",
        workOrderDate: "work_order_date",
        completionDate: "completion_date",
        completionActionedByUuid: "completion_actioned_by_uuid",
        unsuccessfulDate: "unsuccessful_date",
        jobIsScheduledUntilStamp: "job_is_scheduled_until_stamp",
        activeNetworkRequestUuid: "active_network_request_uuid",
        relatedKnowledgeArticles: "related_knowledge_articles",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var JobInput$;
(function (JobInput$) {
    /** @deprecated use `JobInput$inboundSchema` instead. */
    JobInput$.inboundSchema = JobInput$inboundSchema;
    /** @deprecated use `JobInput$outboundSchema` instead. */
    JobInput$.outboundSchema = JobInput$outboundSchema;
})(JobInput$ || (JobInput$ = {}));
export function jobInputToJSON(jobInput) {
    return JSON.stringify(JobInput$outboundSchema.parse(jobInput));
}
export function jobInputFromJSON(jsonString) {
    return safeParse(jsonString, (x) => JobInput$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'JobInput' from JSON`);
}
//# sourceMappingURL=job.js.map