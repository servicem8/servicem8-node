#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b2) {
  const aType = getParsedType(a);
  const bType = getParsedType(b2);
  if (a === b2) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var util, objectUtil, ZodParsedType, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError, errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, overrideErrorMap, makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x2) => x2.status === "aborted", isDirty = (x2) => x2.status === "dirty", isValid = (x2) => x2.status === "valid", isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER, z2;
var init_lib = __esm(() => {
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_2, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  overrideErrorMap = errorMap;
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
  })(errorUtil || (errorUtil = {}));
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
        local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
        ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
        ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === undefined ? undefined : options.position,
        ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch (_a) {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me2 = this;
        return OK(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, undefined);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  _ZodEnum_cache = new WeakMap;
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, undefined);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  _ZodNativeEnum_cache = new WeakMap;
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b2) {
      return new ZodPipeline({
        in: a,
        out: b2,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER = INVALID;
  z2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    enum: enumType,
    function: functionType,
    instanceof: instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    null: nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    undefined: undefinedType,
    union: unionType,
    unknown: unknownType,
    void: voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
});

// src/mcp-server/console-logger.ts
function createConsoleLogger(level) {
  const min = consoleLoggerLevels.indexOf(level);
  const noop = () => {};
  const logger = {
    debug: noop,
    warning: noop,
    info: noop,
    error: noop
  };
  return consoleLoggerLevels.reduce((logger2, level2, i) => {
    if (i < min) {
      return logger2;
    }
    logger2[level2] = log.bind(null, level2);
    return logger2;
  }, logger);
}
function log(level, message, data) {
  let line = "";
  const allData = [{ msg: message, l: level }, data];
  for (const ctx of allData) {
    for (const [key, value] of Object.entries(ctx || {})) {
      if (value == null) {
        line += ` ${key}=<${value}>`;
      } else if (typeof value === "function") {
        line += ` ${key}=<function>`;
      } else if (typeof value === "symbol") {
        line += ` ${key}=${value.toString()}`;
      } else if (typeof value === "string") {
        const v2 = value.search(/\s/g) >= 0 ? JSON.stringify(value) : value;
        line += ` ${key}=${v2}`;
      } else if (typeof value !== "object") {
        line += ` ${key}=${value}`;
      } else {
        line += ` ${key}="${JSON.stringify(value)}"`;
      }
    }
  }
  console.error(line);
}
var consoleLoggerLevels;
var init_console_logger = __esm(() => {
  consoleLoggerLevels = [
    "debug",
    "warning",
    "info",
    "error"
  ];
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2024-11-05", SUPPORTED_PROTOCOL_VERSIONS, JSONRPC_VERSION = "2.0", ProgressTokenSchema, CursorSchema, BaseRequestParamsSchema, RequestSchema, BaseNotificationParamsSchema, NotificationSchema, ResultSchema, RequestIdSchema, JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, ErrorCode, JSONRPCErrorSchema, JSONRPCMessageSchema, EmptyResultSchema, CancelledNotificationSchema, ImplementationSchema, ClientCapabilitiesSchema, InitializeRequestSchema, ServerCapabilitiesSchema, InitializeResultSchema, InitializedNotificationSchema, PingRequestSchema, ProgressSchema, ProgressNotificationSchema, PaginatedRequestSchema, PaginatedResultSchema, ResourceContentsSchema, TextResourceContentsSchema, BlobResourceContentsSchema, ResourceSchema, ResourceTemplateSchema, ListResourcesRequestSchema, ListResourcesResultSchema, ListResourceTemplatesRequestSchema, ListResourceTemplatesResultSchema, ReadResourceRequestSchema, ReadResourceResultSchema, ResourceListChangedNotificationSchema, SubscribeRequestSchema, UnsubscribeRequestSchema, ResourceUpdatedNotificationSchema, PromptArgumentSchema, PromptSchema, ListPromptsRequestSchema, ListPromptsResultSchema, GetPromptRequestSchema, TextContentSchema, ImageContentSchema, AudioContentSchema, EmbeddedResourceSchema, PromptMessageSchema, GetPromptResultSchema, PromptListChangedNotificationSchema, ToolSchema, ListToolsRequestSchema, ListToolsResultSchema, CallToolResultSchema, CompatibilityCallToolResultSchema, CallToolRequestSchema, ToolListChangedNotificationSchema, LoggingLevelSchema, SetLevelRequestSchema, LoggingMessageNotificationSchema, ModelHintSchema, ModelPreferencesSchema, SamplingMessageSchema, CreateMessageRequestSchema, CreateMessageResultSchema, ResourceReferenceSchema, PromptReferenceSchema, CompleteRequestSchema, CompleteResultSchema, RootSchema, ListRootsRequestSchema, ListRootsResultSchema, RootsListChangedNotificationSchema, ClientRequestSchema, ClientNotificationSchema, ClientResultSchema, ServerRequestSchema, ServerNotificationSchema, ServerResultSchema, McpError;
var init_types = __esm(() => {
  init_lib();
  SUPPORTED_PROTOCOL_VERSIONS = [
    LATEST_PROTOCOL_VERSION,
    "2024-10-07"
  ];
  ProgressTokenSchema = z2.union([z2.string(), z2.number().int()]);
  CursorSchema = z2.string();
  BaseRequestParamsSchema = z2.object({
    _meta: z2.optional(z2.object({
      progressToken: z2.optional(ProgressTokenSchema)
    }).passthrough())
  }).passthrough();
  RequestSchema = z2.object({
    method: z2.string(),
    params: z2.optional(BaseRequestParamsSchema)
  });
  BaseNotificationParamsSchema = z2.object({
    _meta: z2.optional(z2.object({}).passthrough())
  }).passthrough();
  NotificationSchema = z2.object({
    method: z2.string(),
    params: z2.optional(BaseNotificationParamsSchema)
  });
  ResultSchema = z2.object({
    _meta: z2.optional(z2.object({}).passthrough())
  }).passthrough();
  RequestIdSchema = z2.union([z2.string(), z2.number().int()]);
  JSONRPCRequestSchema = z2.object({
    jsonrpc: z2.literal(JSONRPC_VERSION),
    id: RequestIdSchema
  }).merge(RequestSchema).strict();
  JSONRPCNotificationSchema = z2.object({
    jsonrpc: z2.literal(JSONRPC_VERSION)
  }).merge(NotificationSchema).strict();
  JSONRPCResponseSchema = z2.object({
    jsonrpc: z2.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
  }).strict();
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32000] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  })(ErrorCode || (ErrorCode = {}));
  JSONRPCErrorSchema = z2.object({
    jsonrpc: z2.literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    error: z2.object({
      code: z2.number().int(),
      message: z2.string(),
      data: z2.optional(z2.unknown())
    })
  }).strict();
  JSONRPCMessageSchema = z2.union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
  ]);
  EmptyResultSchema = ResultSchema.strict();
  CancelledNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/cancelled"),
    params: BaseNotificationParamsSchema.extend({
      requestId: RequestIdSchema,
      reason: z2.string().optional()
    })
  });
  ImplementationSchema = z2.object({
    name: z2.string(),
    version: z2.string()
  }).passthrough();
  ClientCapabilitiesSchema = z2.object({
    experimental: z2.optional(z2.object({}).passthrough()),
    sampling: z2.optional(z2.object({}).passthrough()),
    roots: z2.optional(z2.object({
      listChanged: z2.optional(z2.boolean())
    }).passthrough())
  }).passthrough();
  InitializeRequestSchema = RequestSchema.extend({
    method: z2.literal("initialize"),
    params: BaseRequestParamsSchema.extend({
      protocolVersion: z2.string(),
      capabilities: ClientCapabilitiesSchema,
      clientInfo: ImplementationSchema
    })
  });
  ServerCapabilitiesSchema = z2.object({
    experimental: z2.optional(z2.object({}).passthrough()),
    logging: z2.optional(z2.object({}).passthrough()),
    completions: z2.optional(z2.object({}).passthrough()),
    prompts: z2.optional(z2.object({
      listChanged: z2.optional(z2.boolean())
    }).passthrough()),
    resources: z2.optional(z2.object({
      subscribe: z2.optional(z2.boolean()),
      listChanged: z2.optional(z2.boolean())
    }).passthrough()),
    tools: z2.optional(z2.object({
      listChanged: z2.optional(z2.boolean())
    }).passthrough())
  }).passthrough();
  InitializeResultSchema = ResultSchema.extend({
    protocolVersion: z2.string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    instructions: z2.optional(z2.string())
  });
  InitializedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/initialized")
  });
  PingRequestSchema = RequestSchema.extend({
    method: z2.literal("ping")
  });
  ProgressSchema = z2.object({
    progress: z2.number(),
    total: z2.optional(z2.number())
  }).passthrough();
  ProgressNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/progress"),
    params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({
      progressToken: ProgressTokenSchema
    })
  });
  PaginatedRequestSchema = RequestSchema.extend({
    params: BaseRequestParamsSchema.extend({
      cursor: z2.optional(CursorSchema)
    }).optional()
  });
  PaginatedResultSchema = ResultSchema.extend({
    nextCursor: z2.optional(CursorSchema)
  });
  ResourceContentsSchema = z2.object({
    uri: z2.string(),
    mimeType: z2.optional(z2.string())
  }).passthrough();
  TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: z2.string()
  });
  BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: z2.string().base64()
  });
  ResourceSchema = z2.object({
    uri: z2.string(),
    name: z2.string(),
    description: z2.optional(z2.string()),
    mimeType: z2.optional(z2.string())
  }).passthrough();
  ResourceTemplateSchema = z2.object({
    uriTemplate: z2.string(),
    name: z2.string(),
    description: z2.optional(z2.string()),
    mimeType: z2.optional(z2.string())
  }).passthrough();
  ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: z2.literal("resources/list")
  });
  ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: z2.array(ResourceSchema)
  });
  ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: z2.literal("resources/templates/list")
  });
  ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: z2.array(ResourceTemplateSchema)
  });
  ReadResourceRequestSchema = RequestSchema.extend({
    method: z2.literal("resources/read"),
    params: BaseRequestParamsSchema.extend({
      uri: z2.string()
    })
  });
  ReadResourceResultSchema = ResultSchema.extend({
    contents: z2.array(z2.union([TextResourceContentsSchema, BlobResourceContentsSchema]))
  });
  ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/resources/list_changed")
  });
  SubscribeRequestSchema = RequestSchema.extend({
    method: z2.literal("resources/subscribe"),
    params: BaseRequestParamsSchema.extend({
      uri: z2.string()
    })
  });
  UnsubscribeRequestSchema = RequestSchema.extend({
    method: z2.literal("resources/unsubscribe"),
    params: BaseRequestParamsSchema.extend({
      uri: z2.string()
    })
  });
  ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/resources/updated"),
    params: BaseNotificationParamsSchema.extend({
      uri: z2.string()
    })
  });
  PromptArgumentSchema = z2.object({
    name: z2.string(),
    description: z2.optional(z2.string()),
    required: z2.optional(z2.boolean())
  }).passthrough();
  PromptSchema = z2.object({
    name: z2.string(),
    description: z2.optional(z2.string()),
    arguments: z2.optional(z2.array(PromptArgumentSchema))
  }).passthrough();
  ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: z2.literal("prompts/list")
  });
  ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: z2.array(PromptSchema)
  });
  GetPromptRequestSchema = RequestSchema.extend({
    method: z2.literal("prompts/get"),
    params: BaseRequestParamsSchema.extend({
      name: z2.string(),
      arguments: z2.optional(z2.record(z2.string()))
    })
  });
  TextContentSchema = z2.object({
    type: z2.literal("text"),
    text: z2.string()
  }).passthrough();
  ImageContentSchema = z2.object({
    type: z2.literal("image"),
    data: z2.string().base64(),
    mimeType: z2.string()
  }).passthrough();
  AudioContentSchema = z2.object({
    type: z2.literal("audio"),
    data: z2.string().base64(),
    mimeType: z2.string()
  }).passthrough();
  EmbeddedResourceSchema = z2.object({
    type: z2.literal("resource"),
    resource: z2.union([TextResourceContentsSchema, BlobResourceContentsSchema])
  }).passthrough();
  PromptMessageSchema = z2.object({
    role: z2.enum(["user", "assistant"]),
    content: z2.union([
      TextContentSchema,
      ImageContentSchema,
      AudioContentSchema,
      EmbeddedResourceSchema
    ])
  }).passthrough();
  GetPromptResultSchema = ResultSchema.extend({
    description: z2.optional(z2.string()),
    messages: z2.array(PromptMessageSchema)
  });
  PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/prompts/list_changed")
  });
  ToolSchema = z2.object({
    name: z2.string(),
    description: z2.optional(z2.string()),
    inputSchema: z2.object({
      type: z2.literal("object"),
      properties: z2.optional(z2.object({}).passthrough())
    }).passthrough()
  }).passthrough();
  ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: z2.literal("tools/list")
  });
  ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: z2.array(ToolSchema)
  });
  CallToolResultSchema = ResultSchema.extend({
    content: z2.array(z2.union([TextContentSchema, ImageContentSchema, AudioContentSchema, EmbeddedResourceSchema])),
    isError: z2.boolean().default(false).optional()
  });
  CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
    toolResult: z2.unknown()
  }));
  CallToolRequestSchema = RequestSchema.extend({
    method: z2.literal("tools/call"),
    params: BaseRequestParamsSchema.extend({
      name: z2.string(),
      arguments: z2.optional(z2.record(z2.unknown()))
    })
  });
  ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/tools/list_changed")
  });
  LoggingLevelSchema = z2.enum([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency"
  ]);
  SetLevelRequestSchema = RequestSchema.extend({
    method: z2.literal("logging/setLevel"),
    params: BaseRequestParamsSchema.extend({
      level: LoggingLevelSchema
    })
  });
  LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/message"),
    params: BaseNotificationParamsSchema.extend({
      level: LoggingLevelSchema,
      logger: z2.optional(z2.string()),
      data: z2.unknown()
    })
  });
  ModelHintSchema = z2.object({
    name: z2.string().optional()
  }).passthrough();
  ModelPreferencesSchema = z2.object({
    hints: z2.optional(z2.array(ModelHintSchema)),
    costPriority: z2.optional(z2.number().min(0).max(1)),
    speedPriority: z2.optional(z2.number().min(0).max(1)),
    intelligencePriority: z2.optional(z2.number().min(0).max(1))
  }).passthrough();
  SamplingMessageSchema = z2.object({
    role: z2.enum(["user", "assistant"]),
    content: z2.union([TextContentSchema, ImageContentSchema, AudioContentSchema])
  }).passthrough();
  CreateMessageRequestSchema = RequestSchema.extend({
    method: z2.literal("sampling/createMessage"),
    params: BaseRequestParamsSchema.extend({
      messages: z2.array(SamplingMessageSchema),
      systemPrompt: z2.optional(z2.string()),
      includeContext: z2.optional(z2.enum(["none", "thisServer", "allServers"])),
      temperature: z2.optional(z2.number()),
      maxTokens: z2.number().int(),
      stopSequences: z2.optional(z2.array(z2.string())),
      metadata: z2.optional(z2.object({}).passthrough()),
      modelPreferences: z2.optional(ModelPreferencesSchema)
    })
  });
  CreateMessageResultSchema = ResultSchema.extend({
    model: z2.string(),
    stopReason: z2.optional(z2.enum(["endTurn", "stopSequence", "maxTokens"]).or(z2.string())),
    role: z2.enum(["user", "assistant"]),
    content: z2.discriminatedUnion("type", [
      TextContentSchema,
      ImageContentSchema,
      AudioContentSchema
    ])
  });
  ResourceReferenceSchema = z2.object({
    type: z2.literal("ref/resource"),
    uri: z2.string()
  }).passthrough();
  PromptReferenceSchema = z2.object({
    type: z2.literal("ref/prompt"),
    name: z2.string()
  }).passthrough();
  CompleteRequestSchema = RequestSchema.extend({
    method: z2.literal("completion/complete"),
    params: BaseRequestParamsSchema.extend({
      ref: z2.union([PromptReferenceSchema, ResourceReferenceSchema]),
      argument: z2.object({
        name: z2.string(),
        value: z2.string()
      }).passthrough()
    })
  });
  CompleteResultSchema = ResultSchema.extend({
    completion: z2.object({
      values: z2.array(z2.string()).max(100),
      total: z2.optional(z2.number().int()),
      hasMore: z2.optional(z2.boolean())
    }).passthrough()
  });
  RootSchema = z2.object({
    uri: z2.string().startsWith("file://"),
    name: z2.optional(z2.string())
  }).passthrough();
  ListRootsRequestSchema = RequestSchema.extend({
    method: z2.literal("roots/list")
  });
  ListRootsResultSchema = ResultSchema.extend({
    roots: z2.array(RootSchema)
  });
  RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: z2.literal("notifications/roots/list_changed")
  });
  ClientRequestSchema = z2.union([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema
  ]);
  ClientNotificationSchema = z2.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema
  ]);
  ClientResultSchema = z2.union([
    EmptyResultSchema,
    CreateMessageResultSchema,
    ListRootsResultSchema
  ]);
  ServerRequestSchema = z2.union([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ListRootsRequestSchema
  ]);
  ServerNotificationSchema = z2.union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema
  ]);
  ServerResultSchema = z2.union([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema
  ]);
  McpError = class McpError extends Error {
    constructor(code, message, data) {
      super(`MCP error ${code}: ${message}`);
      this.code = code;
      this.data = data;
      this.name = "McpError";
    }
  };
});

// node_modules/bytes/index.js
var require_bytes = __commonJS((exports, module) => {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  module.exports = bytes;
  module.exports.format = format;
  module.exports.parse = parse;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes(value, options) {
    if (typeof value === "string") {
      return parse(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map[unit] * floatValue);
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014-2018 Douglas Christopher Wilson
   * MIT Licensed
   */
  var relative = __require("path").relative;
  module.exports = depd;
  var basePath = process.cwd();
  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0;i < vals.length; i++) {
      var val = vals[i];
      if (val && (val === "*" || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }
  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }
  function createArgumentsString(arity) {
    var str = "";
    for (var i = 0;i < arity; i++) {
      str += ", arg" + i;
    }
    return str.substr(2);
  }
  function createStackString(stack) {
    var str = this.name + ": " + this.namespace;
    if (this.message) {
      str += " deprecated " + this.message;
    }
    for (var i = 0;i < stack.length; i++) {
      str += `
    at ` + stack[i].toString();
    }
    return str;
  }
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
      log2.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function eehaslisteners(emitter, type) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }
  function isignored(namespace) {
    if (process.noDeprecation) {
      return true;
    }
    var str = process.env.NO_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function istraced(namespace) {
    if (process.traceDeprecation) {
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function log2(message, site) {
    var haslisteners = eehaslisteners(process, "deprecation");
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }
    for (;i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(":") + "__" + caller.join(":") : undefined;
    if (key !== undefined && key in this._warned) {
      return;
    }
    this._warned[key] = true;
    var msg = message;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit("deprecation", err);
      return;
    }
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + `
`, "utf8");
  }
  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || "<anonymous>";
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ", " + file;
    }
    var site = [file, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }
  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;
    if (!funcName) {
      funcName = "<anonymous@" + formatLocation(site) + ">";
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    if (typeName === "Object") {
      typeName = undefined;
    }
    if (typeName === "Function") {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
  }
  function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
    if (this._traced) {
      for (var i = 0;i < stack.length; i++) {
        formatted += `
    at ` + stack[i].toString();
      }
      return formatted;
    }
    if (caller) {
      formatted += " at " + formatLocation(caller);
    }
    return formatted;
  }
  function formatColor(msg, caller, stack) {
    var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m" + " \x1B[33;1mdeprecated\x1B[22;39m" + " \x1B[0m" + msg + "\x1B[39m";
    if (this._traced) {
      for (var i = 0;i < stack.length; i++) {
        formatted += `
    \x1B[36mat ` + stack[i].toString() + "\x1B[39m";
      }
      return formatted;
    }
    if (caller) {
      formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
    }
    return formatted;
  }
  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
  }
  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);
    Error.captureStackTrace(obj);
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
  }
  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    var args = createArgumentsString(fn.length);
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    var deprecatedfn = new Function("fn", "log", "deprecate", "message", "site", `"use strict"
` + "return function (" + args + ") {" + `log.call(deprecate, message, site)
` + `return fn.apply(this, arguments)
` + "}")(fn, log2, this, message, site);
    return deprecatedfn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = prop;
    if ("value" in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop, message);
    }
    var get = descriptor.get;
    var set = descriptor.set;
    if (typeof get === "function") {
      descriptor.get = function getter() {
        log2.call(deprecate, message, site);
        return get.apply(this, arguments);
      };
    }
    if (typeof set === "function") {
      descriptor.set = function setter() {
        log2.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }
  function DeprecationError(namespace, message, stack) {
    var error = new Error;
    var stackString;
    Object.defineProperty(error, "constructor", {
      value: DeprecationError
    });
    Object.defineProperty(error, "message", {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true
    });
    Object.defineProperty(error, "name", {
      enumerable: false,
      configurable: true,
      value: "DeprecationError",
      writable: true
    });
    Object.defineProperty(error, "namespace", {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error, "stack", {
      configurable: true,
      enumerable: false,
      get: function() {
        if (stackString !== undefined) {
          return stackString;
        }
        return stackString = createStackString.call(this, stack);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error;
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS((exports, module) => {
  module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS((exports, module) => {
  module.exports = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a Teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
});

// node_modules/statuses/index.js
var require_statuses = __commonJS((exports, module) => {
  /*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var codes = require_codes();
  module.exports = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map[message.toLowerCase()] = status2;
    });
    return map;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util2 = __require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module.exports = util2.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util2;
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS((exports, module) => {
  /*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS((exports, module) => {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var deprecate = require_depd()("http-errors");
  var setPrototypeOf = require_setprototypeof();
  var statuses = require_statuses();
  var inherits = require_inherits();
  var toIdentifier = require_toidentifier();
  module.exports = createError;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
  function codeClass(status) {
    return Number(String(status).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0;i < arguments.length; i++) {
      var arg = arguments[i];
      var type = typeof arg;
      if (type === "object" && arg instanceof Error) {
        err = arg;
        status = err.status || err.statusCode || status;
      } else if (type === "number" && i === 0) {
        status = arg;
      } else if (type === "string") {
        msg = arg;
      } else if (type === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
      }
    }
    if (typeof status === "number" && (status < 400 || status >= 600)) {
      deprecate("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
      status = 500;
    }
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
      var msg = message != null ? message : statuses.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
      var msg = message != null ? message : statuses.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports2, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses.message[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports2[code] = CodeError;
        exports2[name] = CodeError;
      }
    });
  }
  function toClassName(name) {
    return name.substr(-5) !== "Error" ? name + "Error" : name;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/raw-body/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {};
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {};
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {};
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  exports.utf32le = { type: "_utf32", isLE: true };
  exports.utf32be = { type: "_utf32", isLE: false };
  exports.ucs4le = "utf32le";
  exports.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0;i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (;i < src.length && overflow.length < 4; i++)
        overflow.push(src[i]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (;i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (;i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  exports.utf32 = Utf32AutoCodec;
  exports.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j2 = 0;j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 4) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254 && b2[2] === 0 && b2[3] === 0) {
                return "utf-32le";
              }
              if (b2[0] === 0 && b2[1] === 0 && b2[2] === 254 && b2[3] === 255) {
                return "utf-32be";
              }
            }
            if (b2[0] !== 0 || b2[1] > 16)
              invalidBE++;
            if (b2[3] !== 0 || b2[2] > 16)
              invalidLE++;
            if (b2[0] === 0 && b2[1] === 0 && (b2[2] !== 0 || b2[3] !== 0))
              bmpCharsBE++;
            if ((b2[0] !== 0 || b2[1] !== 0) && b2[2] === 0 && b2[3] === 0)
              bmpCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
      return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
      return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {};
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j2 = 2;
    }
    for (;i < buf.length - 1; i += 2, j2 += 2) {
      buf2[j2] = buf[i + 1];
      buf2[j2 + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0;i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0;i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j2 = 0;j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 2) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254)
                return "utf-16le";
              if (b2[0] === 254 && b2[1] === 255)
                return "utf-16be";
            }
            if (b2[0] === 0 && b2[1] !== 0)
              asciiCharsBE++;
            if (b2[0] !== 0 && b2[1] === 0)
              asciiCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE)
      return "utf-16be";
    if (asciiCharsBE < asciiCharsLE)
      return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {};
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex2 = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex2.test(String.fromCharCode(i));
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {};
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b	
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j2 = 48;j2 <= 57; j2++) {
          if (secondByteNode[j2] === UNASSIGNED) {
            secondByteNode[j2] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j2] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j2]];
          for (var k2 = 129;k2 <= 254; k2++) {
            if (thirdByteNode[k2] === UNASSIGNED) {
              thirdByteNode[k2] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k2] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k2] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k2]];
            for (var l = 48;l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from;j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k2 = 1;k2 < chunk.length; k2++) {
      var part = chunk[k2];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j2 = 1;j2 < seq.length - 1; j2++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {}
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >>> 24;
        newBuf[j2++] = dbcsCode >>> 16 & 255;
        newBuf[j2++] = dbcsCode >>> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      } else {}
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j2 = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k2 = 0;k2 < seq.length - 1; k2++) {
          uCode = seq[k2];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93],
    ["8135f437", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/raw-body/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  var modules = [
    require_internal(),
    require_utf32(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    for (enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
  var module;
  var enc;
  var i;
});

// node_modules/raw-body/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
});

// node_modules/raw-body/node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams = require_streams()(stream_module2);
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = __require("stream");
  } catch (e) {}
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
  if (false) {}
});

// node_modules/unpipe/index.js
var require_unpipe = __commonJS((exports, module) => {
  /*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = unpipe;
  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners("data");
    for (var i = 0;i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream) {
    if (!stream) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream.unpipe === "function") {
      stream.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners("close");
    for (var i = 0;i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream);
    }
  }
});

// node_modules/raw-body/index.js
var require_raw_body = __commonJS((exports, module) => {
  /*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var asyncHooks = tryRequireAsyncHooks();
  var bytes = require_bytes();
  var createError = require_http_errors();
  var iconv = require_lib();
  var unpipe = require_unpipe();
  module.exports = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding) {
    if (!encoding)
      return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream === undefined) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== undefined && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !global.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream.readable !== "undefined" && !stream.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return __require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS((exports) => {
  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  exports.format = format;
  exports.parse = parse;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || !TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = type;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = header.indexOf(";");
    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type.toLowerCase());
    if (index !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 34) {
          value = value.slice(1, -1);
          if (value.indexOf("\\") !== -1) {
            value = value.replace(QESC_REGEXP, "$1");
          }
        }
        obj.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type) {
    this.parameters = Object.create(null);
    this.type = type;
  }
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/sse.js
import { randomUUID } from "node:crypto";

class SSEServerTransport {
  constructor(_endpoint, res) {
    this._endpoint = _endpoint;
    this.res = res;
    this._sessionId = randomUUID();
  }
  async start() {
    if (this._sseResponse) {
      throw new Error("SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    }
    this.res.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    this.res.write(`event: endpoint
data: ${encodeURI(this._endpoint)}?sessionId=${this._sessionId}

`);
    this._sseResponse = this.res;
    this.res.on("close", () => {
      var _a;
      this._sseResponse = undefined;
      (_a = this.onclose) === null || _a === undefined || _a.call(this);
    });
  }
  async handlePostMessage(req, res, parsedBody) {
    var _a, _b, _c;
    if (!this._sseResponse) {
      const message = "SSE connection not established";
      res.writeHead(500).end(message);
      throw new Error(message);
    }
    let body;
    try {
      const ct = import_content_type.default.parse((_a = req.headers["content-type"]) !== null && _a !== undefined ? _a : "");
      if (ct.type !== "application/json") {
        throw new Error(`Unsupported content-type: ${ct}`);
      }
      body = parsedBody !== null && parsedBody !== undefined ? parsedBody : await import_raw_body.default(req, {
        limit: MAXIMUM_MESSAGE_SIZE,
        encoding: (_b = ct.parameters.charset) !== null && _b !== undefined ? _b : "utf-8"
      });
    } catch (error) {
      res.writeHead(400).end(String(error));
      (_c = this.onerror) === null || _c === undefined || _c.call(this, error);
      return;
    }
    try {
      await this.handleMessage(typeof body === "string" ? JSON.parse(body) : body);
    } catch (_d) {
      res.writeHead(400).end(`Invalid message: ${body}`);
      return;
    }
    res.writeHead(202).end("Accepted");
  }
  async handleMessage(message) {
    var _a, _b;
    let parsedMessage;
    try {
      parsedMessage = JSONRPCMessageSchema.parse(message);
    } catch (error) {
      (_a = this.onerror) === null || _a === undefined || _a.call(this, error);
      throw error;
    }
    (_b = this.onmessage) === null || _b === undefined || _b.call(this, parsedMessage);
  }
  async close() {
    var _a, _b;
    (_a = this._sseResponse) === null || _a === undefined || _a.end();
    this._sseResponse = undefined;
    (_b = this.onclose) === null || _b === undefined || _b.call(this);
  }
  async send(message) {
    if (!this._sseResponse) {
      throw new Error("Not connected");
    }
    this._sseResponse.write(`event: message
data: ${JSON.stringify(message)}

`);
  }
  get sessionId() {
    return this._sessionId;
  }
}
var import_raw_body, import_content_type, MAXIMUM_MESSAGE_SIZE = "4mb";
var init_sse = __esm(() => {
  init_types();
  import_raw_body = __toESM(require_raw_body(), 1);
  import_content_type = __toESM(require_content_type(), 1);
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
class ReadBuffer {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf(`
`);
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = undefined;
  }
}
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}
var init_stdio = __esm(() => {
  init_types();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
import process2 from "node:process";

class StdioServerTransport {
  constructor(_stdin = process2.stdin, _stdout = process2.stdout) {
    this._stdin = _stdin;
    this._stdout = _stdout;
    this._readBuffer = new ReadBuffer;
    this._started = false;
    this._ondata = (chunk) => {
      this._readBuffer.append(chunk);
      this.processReadBuffer();
    };
    this._onerror = (error) => {
      var _a;
      (_a = this.onerror) === null || _a === undefined || _a.call(this, error);
    };
  }
  async start() {
    if (this._started) {
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    }
    this._started = true;
    this._stdin.on("data", this._ondata);
    this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    var _a, _b;
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        (_a = this.onmessage) === null || _a === undefined || _a.call(this, message);
      } catch (error) {
        (_b = this.onerror) === null || _b === undefined || _b.call(this, error);
      }
    }
  }
  async close() {
    var _a;
    this._stdin.off("data", this._ondata);
    this._stdin.off("error", this._onerror);
    const remainingDataListeners = this._stdin.listenerCount("data");
    if (remainingDataListeners === 0) {
      this._stdin.pause();
    }
    this._readBuffer.clear();
    (_a = this.onclose) === null || _a === undefined || _a.call(this);
  }
  send(message) {
    return new Promise((resolve) => {
      const json = serializeMessage(message);
      if (this._stdout.write(json)) {
        resolve();
      } else {
        this._stdout.once("drain", resolve);
      }
    });
  }
}
var init_stdio2 = __esm(() => {
  init_stdio();
});

// node_modules/body-parser/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/body-parser/node_modules/debug/src/debug.js
var require_debug = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce2;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/body-parser/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports = module.exports = require_debug();
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/body-parser/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports = module.exports = require_debug();
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
      return k2.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log2() {
    return stream.write(util2.format.apply(util2, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/body-parser/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/destroy/index.js
var require_destroy = __commonJS((exports, module) => {
  /*!
   * destroy
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var EventEmitter = __require("events").EventEmitter;
  var ReadStream = __require("fs").ReadStream;
  var Stream = __require("stream");
  var Zlib = __require("zlib");
  module.exports = destroy;
  function destroy(stream, suppress) {
    if (isFsReadStream(stream)) {
      destroyReadStream(stream);
    } else if (isZlibStream(stream)) {
      destroyZlibStream(stream);
    } else if (hasDestroy(stream)) {
      stream.destroy();
    }
    if (isEventEmitter(stream) && suppress) {
      stream.removeAllListeners("error");
      stream.addListener("error", noop);
    }
    return stream;
  }
  function destroyReadStream(stream) {
    stream.destroy();
    if (typeof stream.close === "function") {
      stream.on("open", onOpenClose);
    }
  }
  function closeZlibStream(stream) {
    if (stream._hadError === true) {
      var prop = stream._binding === null ? "_binding" : "_handle";
      stream[prop] = {
        close: function() {
          this[prop] = null;
        }
      };
    }
    stream.close();
  }
  function destroyZlibStream(stream) {
    if (typeof stream.destroy === "function") {
      if (stream._binding) {
        stream.destroy();
        if (stream._processing) {
          stream._needDrain = true;
          stream.once("drain", onDrainClearBinding);
        } else {
          stream._binding.clear();
        }
      } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
        stream.destroy();
      } else if (stream._destroy && typeof stream.close === "function") {
        stream.destroyed = true;
        stream.close();
      } else {
        stream.destroy();
      }
    } else if (typeof stream.close === "function") {
      closeZlibStream(stream);
    }
  }
  function hasDestroy(stream) {
    return stream instanceof Stream && typeof stream.destroy === "function";
  }
  function isEventEmitter(val) {
    return val instanceof EventEmitter;
  }
  function isFsReadStream(stream) {
    return stream instanceof ReadStream;
  }
  function isZlibStream(stream) {
    return stream instanceof Zlib.Gzip || stream instanceof Zlib.Gunzip || stream instanceof Zlib.Deflate || stream instanceof Zlib.DeflateRaw || stream instanceof Zlib.Inflate || stream instanceof Zlib.InflateRaw || stream instanceof Zlib.Unzip;
  }
  function noop() {}
  function onDrainClearBinding() {
    this._binding.clear();
  }
  function onOpenClose() {
    if (typeof this.fd === "number") {
      this.close();
    }
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling2 = __commonJS((exports) => {
  var BOMChar = "\uFEFF";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal2 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "\uD83D\uDCA9") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = __require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {};
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {};
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {}
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0;i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {};
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0;i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf162 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {}
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {}
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0;i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {};
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j2 = 2;
    }
    for (;i < buf.length - 1; i += 2, j2 += 2) {
      buf2[j2] = buf[i + 1];
      buf2[j2 + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {};
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0;i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf72 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {};
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex2 = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (i = 0;i < 256; i++)
    base64Chars[i] = base64Regex2.test(String.fromCharCode(i));
  var i;
  var plusChar = 43;
  var minusChar = 45;
  var andChar = 38;
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0;i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[44] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0;i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec2 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0;i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0;i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0;i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {};
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0;i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {};
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data2 = __commonJS((exports, module) => {
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated2 = __commonJS((exports, module) => {
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\x00\x03\x07\b	
\v\f\r\x0E\x0F\x10\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\x00\x01\x03\x04\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x15\x16\x17\x18\x1A\x1B\x1C\x1D\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\x00\x01\x02\x03\x04\x05\x06\x07\b	
\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec2 = __commonJS((exports) => {
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1000;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (i = 0;i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  var i;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0;i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0;i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from;j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = 63;
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129;i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j2 = 48;j2 <= 57; j2++)
          secondByteNode[j2] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129;i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48;i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (;addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i2 = bytes.length - 1;i2 > 0; i2--) {
      var val = node[bytes[i2]];
      if (val == UNASSIGNED) {
        node[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k2 = 1;k2 < chunk.length; k2++) {
      var part = chunk[k2];
      if (typeof part === "string") {
        for (var l = 0;l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0;m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0;l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === undefined)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j2 = 1;j2 < seq.length - 1; j2++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== undefined)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i2 = 0;i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== undefined && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == undefined) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== undefined) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {}
        }
        seqObj = undefined;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== undefined)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== undefined) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      } else {}
      this.seqObj = undefined;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j2 = 0;i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k2 = 0;k2 < seq.length - 1; k2++) {
          uCode = seq[k2];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis2 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 128],
    ["a1", "", 62],
    ["8140", "", 9, ""],
    ["8180", ""],
    ["81b8", ""],
    ["81c8", ""],
    ["81da", ""],
    ["81f0", ""],
    ["81fc", ""],
    ["824f", "", 9],
    ["8260", "", 25],
    ["8281", "", 25],
    ["829f", "", 82],
    ["8340", "", 62],
    ["8380", "", 22],
    ["839f", "", 16, "", 6],
    ["83bf", "", 16, "", 6],
    ["8440", "", 5, "", 25],
    ["8470", "", 5, "", 7],
    ["8480", "", 17],
    ["849f", ""],
    ["8740", "", 19, "", 9],
    ["875f", ""],
    ["877e", ""],
    ["8780", "", 4, ""],
    ["889f", ""],
    ["8940", ""],
    ["8980", ""],
    ["8a40", ""],
    ["8a80", ""],
    ["8b40", ""],
    ["8b80", ""],
    ["8c40", ""],
    ["8c80", ""],
    ["8d40", ""],
    ["8d80", ""],
    ["8e40", ""],
    ["8e80", ""],
    ["8f40", ""],
    ["8f80", ""],
    ["9040", ""],
    ["9080", ""],
    ["9140", ""],
    ["9180", ""],
    ["9240", ""],
    ["9280", ""],
    ["9340", ""],
    ["9380", ""],
    ["9440", ""],
    ["9480", ""],
    ["9540", ""],
    ["9580", ""],
    ["9640", ""],
    ["9680", ""],
    ["9740", ""],
    ["9780", ""],
    ["9840", ""],
    ["989f", ""],
    ["9940", ""],
    ["9980", ""],
    ["9a40", ""],
    ["9a80", ""],
    ["9b40", ""],
    ["9b80", ""],
    ["9c40", ""],
    ["9c80", ""],
    ["9d40", ""],
    ["9d80", ""],
    ["9e40", ""],
    ["9e80", ""],
    ["9f40", ""],
    ["9f80", ""],
    ["e040", ""],
    ["e080", ""],
    ["e140", ""],
    ["e180", ""],
    ["e240", ""],
    ["e280", ""],
    ["e340", ""],
    ["e380", ""],
    ["e440", ""],
    ["e480", ""],
    ["e540", ""],
    ["e580", ""],
    ["e640", ""],
    ["e680", ""],
    ["e740", ""],
    ["e780", ""],
    ["e840", ""],
    ["e880", ""],
    ["e940", ""],
    ["e980", ""],
    ["ea40", ""],
    ["ea80", ""],
    ["ed40", ""],
    ["ed80", ""],
    ["ee40", ""],
    ["ee80", ""],
    ["eeef", "", 9, ""],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "", 9, "", 9, ""],
    ["fa80", ""],
    ["fb40", ""],
    ["fb80", ""],
    ["fc40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp2 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8ea1", "", 62],
    ["a1a1", "", 9, ""],
    ["a2a1", ""],
    ["a2ba", ""],
    ["a2ca", ""],
    ["a2dc", ""],
    ["a2f2", ""],
    ["a2fe", ""],
    ["a3b0", "", 9],
    ["a3c1", "", 25],
    ["a3e1", "", 25],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a8a1", ""],
    ["ada1", "", 19, "", 9],
    ["adc0", ""],
    ["addf", "", 4, ""],
    ["b0a1", ""],
    ["b1a1", ""],
    ["b2a1", ""],
    ["b3a1", ""],
    ["b4a1", ""],
    ["b5a1", ""],
    ["b6a1", ""],
    ["b7a1", ""],
    ["b8a1", ""],
    ["b9a1", ""],
    ["baa1", ""],
    ["bba1", ""],
    ["bca1", ""],
    ["bda1", ""],
    ["bea1", ""],
    ["bfa1", ""],
    ["c0a1", ""],
    ["c1a1", ""],
    ["c2a1", ""],
    ["c3a1", ""],
    ["c4a1", ""],
    ["c5a1", ""],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["c9a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", ""],
    ["d2a1", ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fcf1", "", 9, ""],
    ["8fa2af", ""],
    ["8fa2c2", ""],
    ["8fa2eb", ""],
    ["8fa6e1", ""],
    ["8fa6e7", ""],
    ["8fa6e9", ""],
    ["8fa6ec", ""],
    ["8fa6f1", ""],
    ["8fa7c2", "", 10, ""],
    ["8fa7f2", "", 10, ""],
    ["8fa9a1", ""],
    ["8fa9a4", ""],
    ["8fa9a6", ""],
    ["8fa9a8", ""],
    ["8fa9ab", ""],
    ["8fa9af", ""],
    ["8fa9c1", ""],
    ["8faaa1", ""],
    ["8faaba", ""],
    ["8faba1", ""],
    ["8fabbd", ""],
    ["8fabc5", ""],
    ["8fb0a1", ""],
    ["8fb1a1", ""],
    ["8fb2a1", "", 4, ""],
    ["8fb3a1", ""],
    ["8fb4a1", ""],
    ["8fb5a1", ""],
    ["8fb6a1", "", 5, "", 4, ""],
    ["8fb7a1", "", 4, ""],
    ["8fb8a1", ""],
    ["8fb9a1", ""],
    ["8fbaa1", "", 4, ""],
    ["8fbba1", ""],
    ["8fbca1", "", 4, ""],
    ["8fbda1", "", 4, ""],
    ["8fbea1", "", 4, ""],
    ["8fbfa1", ""],
    ["8fc0a1", ""],
    ["8fc1a1", ""],
    ["8fc2a1", ""],
    ["8fc3a1", "", 4, ""],
    ["8fc4a1", ""],
    ["8fc5a1", ""],
    ["8fc6a1", ""],
    ["8fc7a1", ""],
    ["8fc8a1", ""],
    ["8fc9a1", "", 4, "", 4, ""],
    ["8fcaa1", ""],
    ["8fcba1", ""],
    ["8fcca1", "", 9, ""],
    ["8fcda1", "", 5, ""],
    ["8fcea1", "", 6, ""],
    ["8fcfa1", ""],
    ["8fd0a1", ""],
    ["8fd1a1", ""],
    ["8fd2a1", "", 5],
    ["8fd3a1", ""],
    ["8fd4a1", "", 4, ""],
    ["8fd5a1", ""],
    ["8fd6a1", ""],
    ["8fd7a1", ""],
    ["8fd8a1", ""],
    ["8fd9a1", "", 4, "", 6, ""],
    ["8fdaa1", "", 4, ""],
    ["8fdba1", "", 6, ""],
    ["8fdca1", "", 4, ""],
    ["8fdda1", "", 4, ""],
    ["8fdea1", "", 4, ""],
    ["8fdfa1", ""],
    ["8fe0a1", ""],
    ["8fe1a1", "", 4, ""],
    ["8fe2a1", ""],
    ["8fe3a1", "", 5, "", 4, ""],
    ["8fe4a1", "", 4, ""],
    ["8fe5a1", "", 4, ""],
    ["8fe6a1", ""],
    ["8fe7a1", ""],
    ["8fe8a1", "", 4, ""],
    ["8fe9a1", "", 4],
    ["8feaa1", "", 4, ""],
    ["8feba1", "", 4, ""],
    ["8feca1", ""],
    ["8feda1", "", 4, "", 4, ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp9362 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127, ""],
    ["8140", "", 5, "", 9, "", 6, ""],
    ["8180", "", 6, "", 4, "", 4, "", 5, ""],
    ["8240", "", 4, "", 8, "", 4, "", 11],
    ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
    ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
    ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
    ["8440", "", 5, "", 5, ""],
    ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
    ["8540", "", 9, ""],
    ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
    ["8640", "", 4, "", 5, "", 4, "", 5, ""],
    ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
    ["8740", "", 7, "", 11, "", 4, "", 4],
    ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
    ["8840", "", 9, "", 4, "", 4, ""],
    ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
    ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
    ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
    ["8a40", "", 4, "", 12, ""],
    ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
    ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
    ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
    ["8c40", "", 7, ""],
    ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
    ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
    ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
    ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
    ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
    ["8f40", "", 5, "", 11, "", 8, ""],
    ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
    ["9040", "", 4, "", 4, "", 6, ""],
    ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
    ["9140", "", 6, "", 6, "", 18, "", 4, ""],
    ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
    ["9240", "", 6, "", 5, ""],
    ["9280", "", 5, "", 7, "", 6, ""],
    ["9340", "", 6, "", 4, "", 4, "", 5, ""],
    ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
    ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
    ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
    ["9540", "", 4, "", 4, "", 6, ""],
    ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
    ["9640", "", 5, "", 4, ""],
    ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
    ["9740", "", 7, "", 8, "", 7, "", 9, ""],
    ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
    ["9840", "", 4, "", 5, "", 9, ""],
    ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
    ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
    ["9980", "", 114, "", 6],
    ["9a40", "", 11, "", 7, "", 13, ""],
    ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
    ["9b40", "", 4, ""],
    ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
    ["9c40", "", 7, ""],
    ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
    ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
    ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
    ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
    ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
    ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
    ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
    ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
    ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
    ["a1a1", "", 7, ""],
    ["a2a1", "", 9],
    ["a2b1", "", 19, "", 19, "", 9],
    ["a2e5", "", 9],
    ["a2f1", "", 11],
    ["a3a1", "", 88, ""],
    ["a4a1", "", 82],
    ["a5a1", "", 85],
    ["a6a1", "", 16, "", 6],
    ["a6c1", "", 16, "", 6],
    ["a6e0", ""],
    ["a6ee", ""],
    ["a6f4", ""],
    ["a7a1", "", 5, "", 25],
    ["a7d1", "", 5, "", 25],
    ["a840", "", 35, "", 6],
    ["a880", "", 7, ""],
    ["a8a1", ""],
    ["a8bd", ""],
    ["a8c0", ""],
    ["a8c5", "", 36],
    ["a940", "", 8, ""],
    ["a959", ""],
    ["a95c", ""],
    ["a960", "", 9, "", 8],
    ["a980", "", 4, ""],
    ["a996", ""],
    ["a9a4", "", 75],
    ["aa40", "", 5, "", 5, "", 8],
    ["aa80", "", 7, "", 10, ""],
    ["ab40", "", 11, "", 4, "", 5, "", 4],
    ["ab80", "", 6, "", 4],
    ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
    ["ac80", "", 6, "", 12, "", 4, ""],
    ["ad40", "", 10, "", 7, "", 15, "", 12],
    ["ad80", "", 9, "", 8, "", 6, ""],
    ["ae40", "", 6, "", 7, "", 4, ""],
    ["ae80", "", 7, "", 6, "", 4, ""],
    ["af40", "", 4, ""],
    ["af80", ""],
    ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
    ["b080", "", 7, "", 8, "", 9, ""],
    ["b140", "", 4, "", 7, "", 10, ""],
    ["b180", "", 4, "", 7, "", 7, ""],
    ["b240", "", 11, "", 5, "", 11, "", 4],
    ["b280", "", 12, "", 8, "", 4, ""],
    ["b340", "", 5, ""],
    ["b380", "", 11, "", 7, "", 6, ""],
    ["b440", "", 7, "", 9],
    ["b480", "", 4, "", 5, "", 6, ""],
    ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
    ["b580", "", 6, "", 4, ""],
    ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
    ["b680", "", 6, "", 4, ""],
    ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
    ["b780", "", 6, ""],
    ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
    ["b880", "", 4, ""],
    ["b940", "", 5, "", 10, "", 6, ""],
    ["b980", "", 7, ""],
    ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
    ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
    ["bb40", "", 9, "", 36, "", 5, "", 9],
    ["bb80", "", 6, "", 4, ""],
    ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
    ["bc80", "", 14, "", 6, ""],
    ["bd40", "", 54, "", 7],
    ["bd80", "", 32, ""],
    ["be40", "", 12, "", 6, "", 42],
    ["be80", "", 32, ""],
    ["bf40", "", 62],
    ["bf80", "", 4, "", 4, "", 21, ""],
    ["c040", "", 35, "", 23, ""],
    ["c080", "", 6, "", 9, ""],
    ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
    ["c180", "", 4, "", 4, "", 5, ""],
    ["c240", "", 6, "", 5, ""],
    ["c280", "", 13, "", 5, "", 11, ""],
    ["c340", "", 5, "", 4, "", 6, ""],
    ["c380", "", 12, "", 4, ""],
    ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
    ["c480", "", 7, "", 5, "", 6, ""],
    ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
    ["c580", "", 7, "", 7, ""],
    ["c640", ""],
    ["c680", "", 4, "", 9, ""],
    ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
    ["c780", ""],
    ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
    ["c880", "", 6, "", 4, "", 4, ""],
    ["c940", "", 4, "", 7, "", 12, ""],
    ["c980", "", 4, "", 4, "", 10, ""],
    ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
    ["ca80", "", 4, "", 8, ""],
    ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
    ["cb80", "", 5, "", 6, "", 14, ""],
    ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
    ["cc80", "", 11, "", 4, "", 7, ""],
    ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
    ["cd80", ""],
    ["ce40", "", 6, "", 5, "", 7, ""],
    ["ce80", "", 4, "", 6, "", 4, ""],
    ["cf40", "", 4, "", 4, "", 6, "", 9],
    ["cf80", "", 5, "", 7, "", 4, ""],
    ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
    ["d080", "", 4, "", 4, "", 5, ""],
    ["d140", "", 4, "", 4, "", 6, "", 5],
    ["d180", "", 4, "", 4, "", 4, ""],
    ["d240", "", 8, "", 24, "", 5, "", 19, ""],
    ["d280", "", 26, ""],
    ["d340", "", 30, "", 6],
    ["d380", "", 4, "", 5, "", 21, ""],
    ["d440", "", 31, "", 8, "", 21],
    ["d480", "", 25, "", 6, ""],
    ["d540", "", 7, "", 7, "", 46],
    ["d580", "", 32, ""],
    ["d640", "", 34, "", 27],
    ["d680", "", 30, ""],
    ["d740", "", 31, "", 4, "", 25],
    ["d780", "", 24, ""],
    ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
    ["d880", "", 6, "", 20, ""],
    ["d940", "", 62],
    ["d980", "", 32, ""],
    ["da40", "", 14, "", 8, "", 4, "", 9, ""],
    ["da80", "", 12, ""],
    ["db40", "", 6, "", 7, "", 4, ""],
    ["db80", "", 4, "", 5, "", 11, ""],
    ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
    ["dc80", "", 10, "", 21, ""],
    ["dd40", "", 62],
    ["dd80", "", 32, ""],
    ["de40", "", 32, ""],
    ["de80", "", 4, ""],
    ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
    ["df80", "", 4, ""],
    ["e040", "", 19, ""],
    ["e080", "", 10, "", 6, "", 8, ""],
    ["e140", "", 4, "", 6, "", 5, "", 5, ""],
    ["e180", "", 10, "", 9, "", 8, ""],
    ["e240", "", 62],
    ["e280", "", 32, "", 5, ""],
    ["e340", "", 45, "", 16],
    ["e380", "", 7, "", 24, ""],
    ["e440", "", 5, "", 24, "", 31],
    ["e480", "", 32, ""],
    ["e540", "", 51, "", 10],
    ["e580", "", 31, ""],
    ["e640", "", 34, "", 27],
    ["e680", "", 29, ""],
    ["e740", "", 7, "", 54],
    ["e780", "", 32, "", 6, "", 4, ""],
    ["e840", "", 14, "", 43, ""],
    ["e880", "", 20, ""],
    ["e940", "", 7, "", 42],
    ["e980", "", 32, ""],
    ["ea40", "", 27, "", 6, ""],
    ["ea80", "", 4, "", 12, ""],
    ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
    ["eb80", "", 4, ""],
    ["ec40", "", 8, "", 4, "", 18, "", 7],
    ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
    ["ed40", "", 6, "", 46],
    ["ed80", "", 4, "", 23, ""],
    ["ee40", "", 62],
    ["ee80", "", 32, "", 4, "", 6, ""],
    ["ef40", "", 5, "", 37, "", 4],
    ["ef80", "", 30, "", 4, "", 8, ""],
    ["f040", "", 4, "", 28, "", 26],
    ["f080", "", 9, "", 12, "", 4, "", 6, ""],
    ["f140", "", 10, "", 47],
    ["f180", "", 32, ""],
    ["f240", "", 62],
    ["f280", "", 32, ""],
    ["f340", "", 17, "", 6, "", 4, ""],
    ["f380", "", 8, "", 6, ""],
    ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
    ["f480", "", 32, ""],
    ["f540", "", 62],
    ["f580", "", 32, ""],
    ["f640", "", 62],
    ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
    ["f740", "", 62],
    ["f780", "", 4, "", 4, ""],
    ["f840", "", 62],
    ["f880", "", 32],
    ["f940", "", 62],
    ["f980", "", 32],
    ["fa40", "", 62],
    ["fa80", "", 32],
    ["fb40", "", 27, "", 9, ""],
    ["fb80", "", 5, "", 8, "", 5, ""],
    ["fc40", "", 8, "", 4, "", 8, "", 6],
    ["fc80", "", 4, "", 5, "", 8, ""],
    ["fd40", "", 4, "", 4, "", 10, "", 38],
    ["fd80", "", 5, "", 11, "", 4, ""],
    ["fe40", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added2 = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", ""],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, ""],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", ""],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", ""],
    ["fe80", "", 6, "", 93]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges2 = __commonJS((exports, module) => {
  module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000] };
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp9492 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["8141", "", 4, "", 6, ""],
    ["8161", "", 9, "", 5, ""],
    ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
    ["8241", "", 7, "", 5],
    ["8261", "", 6, "", 5, ""],
    ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
    ["8341", "", 5, "", 5, "", 7],
    ["8361", "", 18, ""],
    ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
    ["8441", "", 5, "", 8],
    ["8461", "", 18],
    ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
    ["8541", "", 5, "", 4, "", 6, "", 4],
    ["8561", "", 5, "", 5, "", 6, ""],
    ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
    ["8641", "", 6, "", 5, ""],
    ["8661", "", 6, "", 10],
    ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
    ["8741", "", 9, "", 15],
    ["8761", "", 18, ""],
    ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
    ["8841", "", 4, "", 5, "", 6, "", 4],
    ["8861", "", 4, ""],
    ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
    ["8941", "", 6, "", 5, ""],
    ["8961", "", 10, "", 5, ""],
    ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
    ["8a41", "", 10, "", 6, ""],
    ["8a61", "", 4, "", 18, ""],
    ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
    ["8b41", "", 5, "", 4, "", 6, ""],
    ["8b61", "", 6, "", 8],
    ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
    ["8c41", "", 15, "", 4],
    ["8c61", "", 6, "", 5, "", 6, "", 5],
    ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
    ["8d41", "", 16, "", 8],
    ["8d61", "", 17, ""],
    ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
    ["8e41", "", 6, "", 5, "", 8],
    ["8e61", "", 4, "", 19],
    ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
    ["8f41", "", 7, "", 17],
    ["8f61", "", 7, "", 6, "", 4],
    ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
    ["9041", "", 6, "", 5, ""],
    ["9061", "", 5, "", 15],
    ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
    ["9141", "", 6, "", 5],
    ["9161", "", 9, "", 5],
    ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
    ["9241", "", 7, "", 4, ""],
    ["9261", "", 7, "", 7, "", 4],
    ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
    ["9341", "", 4, ""],
    ["9361", "", 6, "", 8],
    ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
    ["9441", "", 5, "", 5, "", 8],
    ["9461", "", 5, "", 6, "", 12],
    ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
    ["9541", "", 11, "", 5, ""],
    ["9561", "", 6, "", 5, ""],
    ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
    ["9641", "", 23, ""],
    ["9661", "", 6, "", 5, "", 8],
    ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
    ["9741", "", 16, "", 8],
    ["9761", "", 17, "", 7],
    ["9781", "", 11, "", 5, "", 6, "", 89, ""],
    ["9841", "", 16, "", 5, ""],
    ["9861", "", 6, "", 15],
    ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
    ["9941", "", 6, "", 5, ""],
    ["9961", "", 6, "", 5, ""],
    ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
    ["9a41", "", 16],
    ["9a61", "", 6, "", 6, ""],
    ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
    ["9b41", "", 6, "", 8],
    ["9b61", "", 17, "", 7],
    ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
    ["9c41", "", 4, "", 5, "", 5],
    ["9c61", "", 8, "", 6, "", 9],
    ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
    ["9d41", "", 13, "", 8],
    ["9d61", "", 25],
    ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
    ["9e41", "", 7, "", 9, ""],
    ["9e61", "", 4, "", 6, ""],
    ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
    ["9f41", "", 5, "", 4, "", 5, ""],
    ["9f61", "", 6, "", 5, ""],
    ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
    ["a041", "", 5, "", 6, ""],
    ["a061", "", 5, "", 13],
    ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
    ["a141", "", 18, ""],
    ["a161", "", 6, "", 5, ""],
    ["a181", "", 14, "", 5, "", 4, "", 9, ""],
    ["a241", "", 5, "", 18],
    ["a261", "", 6, "", 18],
    ["a281", "", 7, "", 6, "", 7, ""],
    ["a341", "", 6, "", 10, ""],
    ["a361", "", 6, "", 16],
    ["a381", "", 16, "", 4, "", 58, "", 32, ""],
    ["a441", "", 5, ""],
    ["a461", "", 5, "", 12],
    ["a481", "", 28, "", 93],
    ["a541", "", 4, "", 6, "", 5, ""],
    ["a561", "", 17, "", 5, ""],
    ["a581", "", 16, "", 14, "", 9],
    ["a5b0", "", 9],
    ["a5c1", "", 16, "", 6],
    ["a5e1", "", 16, "", 6],
    ["a641", "", 19, ""],
    ["a661", "", 5, "", 5, "", 6],
    ["a681", "", 6, "", 18, "", 7],
    ["a741", "", 4, "", 6, "", 7],
    ["a761", "", 22, ""],
    ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
    ["a841", "", 10, "", 14],
    ["a861", "", 18, "", 6],
    ["a881", "", 19, "", 11, ""],
    ["a8a6", ""],
    ["a8a8", ""],
    ["a8b1", "", 27, "", 25, "", 14, ""],
    ["a941", "", 14, "", 10],
    ["a961", "", 18],
    ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
    ["aa41", "", 6, "", 4, ""],
    ["aa61", "", 4, "", 5, "", 6, ""],
    ["aa81", "", 29, "", 82],
    ["ab41", "", 6, "", 5, ""],
    ["ab61", "", 6, "", 5, "", 5],
    ["ab81", "", 8, "", 6, "", 12, "", 85],
    ["ac41", "", 5, "", 6, ""],
    ["ac61", "", 11, "", 4],
    ["ac81", "", 28, "", 5, "", 25],
    ["acd1", "", 5, "", 25],
    ["ad41", "", 6, "", 5, "", 7],
    ["ad61", "", 6, "", 10, ""],
    ["ad81", "", 5, "", 18, ""],
    ["ae41", "", 5, "", 16],
    ["ae61", "", 5, "", 6, "", 4],
    ["ae81", "", 6, "", 5, ""],
    ["af41", "", 19],
    ["af61", "", 13, "", 5, ""],
    ["af81", "", 5, "", 6, "", 5, ""],
    ["b041", "", 5, "", 5, "", 12],
    ["b061", "", 5, "", 19],
    ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
    ["b141", "", 6, "", 5, ""],
    ["b161", "", 6, "", 5, "", 11],
    ["b181", "", 14, "", 6, ""],
    ["b241", "", 6, "", 5, ""],
    ["b261", "", 18, "", 5, ""],
    ["b281", "", 5, "", 18, "", 6, ""],
    ["b341", "", 19, ""],
    ["b361", "", 5, "", 5, "", 5],
    ["b381", "", 5, "", 5, "", 19, "", 4, ""],
    ["b441", "", 5, "", 6, "", 5],
    ["b461", "", 6, "", 10, ""],
    ["b481", "", 6, "", 18, "", 4, "", 4, ""],
    ["b541", "", 14, "", 5],
    ["b561", "", 5, "", 5, "", 4],
    ["b581", "", 6, "", 5, "", 11, ""],
    ["b641", "", 7, "", 17],
    ["b661", "", 15, ""],
    ["b681", "", 5, "", 6, "", 5, ""],
    ["b741", "", 13, "", 6, ""],
    ["b761", "", 20, ""],
    ["b781", "", 6, "", 14, ""],
    ["b841", "", 7, "", 17],
    ["b861", "", 8, "", 13],
    ["b881", "", 5, "", 24, "", 4, ""],
    ["b941", "", 6, "", 5, ""],
    ["b961", "", 14, "", 6, ""],
    ["b981", "", 22, "", 4, "", 4, ""],
    ["ba41", "", 5, "", 6, ""],
    ["ba61", "", 5, "", 4, "", 5],
    ["ba81", "", 6, "", 9, ""],
    ["bb41", "", 4, "", 5, "", 4, ""],
    ["bb61", "", 6, "", 5, ""],
    ["bb81", "", 31, ""],
    ["bc41", "", 17, ""],
    ["bc61", "", 5, "", 6, ""],
    ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
    ["bd41", "", 7, "", 7, ""],
    ["bd61", "", 5, "", 13],
    ["bd81", "", 5, "", 25, ""],
    ["be41", "", 7, "", 14],
    ["be61", "", 7, "", 7, ""],
    ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
    ["bf41", "", 10, "", 14],
    ["bf61", "", 18, ""],
    ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
    ["c041", "", 5, "", 6, "", 5],
    ["c061", "", 25],
    ["c081", "", 6, "", 5, "", 7, ""],
    ["c141", "", 5, "", 6, ""],
    ["c161", "", 19, ""],
    ["c181", "", 31, ""],
    ["c241", "", 4, "", 5, ""],
    ["c261", "", 4, "", 5, "", 6, ""],
    ["c281", "", 5, "", 7, "", 9, ""],
    ["c341", "", 4],
    ["c361", "", 4, "", 5, "", 11],
    ["c381", "", 5, "", 7, "", 5, ""],
    ["c441", "", 7, "", 7, ""],
    ["c461", "", 5, "", 4],
    ["c481", "", 5, "", 11, ""],
    ["c541", "", 6, "", 5, ""],
    ["c561", "", 6, "", 5, "", 4],
    ["c581", "", 6, "", 5, ""],
    ["c641", "", 6, "", 5],
    ["c6a1", ""],
    ["c7a1", ""],
    ["c8a1", ""],
    ["caa1", ""],
    ["cba1", ""],
    ["cca1", ""],
    ["cda1", ""],
    ["cea1", ""],
    ["cfa1", ""],
    ["d0a1", ""],
    ["d1a1", "", 5, "", 4, ""],
    ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
    ["d3a1", ""],
    ["d4a1", ""],
    ["d5a1", ""],
    ["d6a1", ""],
    ["d7a1", ""],
    ["d8a1", ""],
    ["d9a1", ""],
    ["daa1", ""],
    ["dba1", ""],
    ["dca1", ""],
    ["dda1", ""],
    ["dea1", ""],
    ["dfa1", ""],
    ["e0a1", ""],
    ["e1a1", ""],
    ["e2a1", ""],
    ["e3a1", ""],
    ["e4a1", ""],
    ["e5a1", ""],
    ["e6a1", ""],
    ["e7a1", ""],
    ["e8a1", ""],
    ["e9a1", ""],
    ["eaa1", ""],
    ["eba1", ""],
    ["eca1", ""],
    ["eda1", ""],
    ["eea1", ""],
    ["efa1", ""],
    ["f0a1", ""],
    ["f1a1", ""],
    ["f2a1", ""],
    ["f3a1", ""],
    ["f4a1", ""],
    ["f5a1", ""],
    ["f6a1", ""],
    ["f7a1", ""],
    ["f8a1", ""],
    ["f9a1", ""],
    ["faa1", ""],
    ["fba1", ""],
    ["fca1", ""],
    ["fda1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp9502 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\x00", 127],
    ["a140", ""],
    ["a1a1", "", 4, ""],
    ["a240", "", 7, ""],
    ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
    ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
    ["a3a1", "", 25, ""],
    ["a3e1", ""],
    ["a440", ""],
    ["a4a1", ""],
    ["a540", ""],
    ["a5a1", ""],
    ["a640", ""],
    ["a6a1", ""],
    ["a740", ""],
    ["a7a1", ""],
    ["a840", ""],
    ["a8a1", ""],
    ["a940", ""],
    ["a9a1", ""],
    ["aa40", ""],
    ["aaa1", ""],
    ["ab40", ""],
    ["aba1", ""],
    ["ac40", ""],
    ["aca1", ""],
    ["ad40", ""],
    ["ada1", ""],
    ["ae40", ""],
    ["aea1", ""],
    ["af40", ""],
    ["afa1", ""],
    ["b040", ""],
    ["b0a1", ""],
    ["b140", ""],
    ["b1a1", ""],
    ["b240", ""],
    ["b2a1", ""],
    ["b340", ""],
    ["b3a1", ""],
    ["b440", ""],
    ["b4a1", ""],
    ["b540", ""],
    ["b5a1", ""],
    ["b640", ""],
    ["b6a1", ""],
    ["b740", ""],
    ["b7a1", ""],
    ["b840", ""],
    ["b8a1", ""],
    ["b940", ""],
    ["b9a1", ""],
    ["ba40", ""],
    ["baa1", ""],
    ["bb40", ""],
    ["bba1", ""],
    ["bc40", ""],
    ["bca1", ""],
    ["bd40", ""],
    ["bda1", ""],
    ["be40", ""],
    ["bea1", ""],
    ["bf40", ""],
    ["bfa1", ""],
    ["c040", ""],
    ["c0a1", ""],
    ["c140", ""],
    ["c1a1", ""],
    ["c240", ""],
    ["c2a1", ""],
    ["c340", ""],
    ["c3a1", ""],
    ["c440", ""],
    ["c4a1", ""],
    ["c540", ""],
    ["c5a1", ""],
    ["c640", ""],
    ["c940", ""],
    ["c9a1", ""],
    ["ca40", ""],
    ["caa1", ""],
    ["cb40", ""],
    ["cba1", ""],
    ["cc40", ""],
    ["cca1", ""],
    ["cd40", ""],
    ["cda1", ""],
    ["ce40", ""],
    ["cea1", ""],
    ["cf40", ""],
    ["cfa1", ""],
    ["d040", ""],
    ["d0a1", ""],
    ["d140", ""],
    ["d1a1", ""],
    ["d240", ""],
    ["d2a1", ""],
    ["d340", ""],
    ["d3a1", ""],
    ["d440", ""],
    ["d4a1", ""],
    ["d540", ""],
    ["d5a1", ""],
    ["d640", ""],
    ["d6a1", ""],
    ["d740", ""],
    ["d7a1", ""],
    ["d840", ""],
    ["d8a1", ""],
    ["d940", ""],
    ["d9a1", ""],
    ["da40", ""],
    ["daa1", ""],
    ["db40", ""],
    ["dba1", ""],
    ["dc40", ""],
    ["dca1", ""],
    ["dd40", ""],
    ["dda1", ""],
    ["de40", ""],
    ["dea1", ""],
    ["df40", ""],
    ["dfa1", ""],
    ["e040", ""],
    ["e0a1", ""],
    ["e140", ""],
    ["e1a1", ""],
    ["e240", ""],
    ["e2a1", ""],
    ["e340", ""],
    ["e3a1", ""],
    ["e440", ""],
    ["e4a1", ""],
    ["e540", ""],
    ["e5a1", ""],
    ["e640", ""],
    ["e6a1", ""],
    ["e740", ""],
    ["e7a1", ""],
    ["e840", ""],
    ["e8a1", ""],
    ["e940", ""],
    ["e9a1", ""],
    ["ea40", ""],
    ["eaa1", ""],
    ["eb40", ""],
    ["eba1", ""],
    ["ec40", ""],
    ["eca1", ""],
    ["ed40", ""],
    ["eda1", ""],
    ["ee40", ""],
    ["eea1", ""],
    ["ef40", ""],
    ["efa1", ""],
    ["f040", ""],
    ["f0a1", ""],
    ["f140", ""],
    ["f1a1", ""],
    ["f240", ""],
    ["f2a1", ""],
    ["f340", ""],
    ["f3a1", ""],
    ["f440", ""],
    ["f4a1", ""],
    ["f540", ""],
    ["f5a1", ""],
    ["f640", ""],
    ["f6a1", ""],
    ["f740", ""],
    ["f7a1", ""],
    ["f840", ""],
    ["f8a1", ""],
    ["f940", ""],
    ["f9a1", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added2 = __commonJS((exports, module) => {
  module.exports = [
    ["8740", ""],
    ["8767", ""],
    ["87a1", ""],
    ["8840", "", 4, ""],
    ["88a1", ""],
    ["8940", ""],
    ["8943", ""],
    ["8946", ""],
    ["894c", ""],
    ["89a1", ""],
    ["89ab", ""],
    ["89b0", ""],
    ["89b5", ""],
    ["89c1", ""],
    ["89c5", ""],
    ["8a40", ""],
    ["8a43", ""],
    ["8a64", ""],
    ["8a76", ""],
    ["8aa1", ""],
    ["8aac", ""],
    ["8ab2", ""],
    ["8abb", ""],
    ["8ac9", ""],
    ["8ace", ""],
    ["8adf", ""],
    ["8af6", ""],
    ["8b40", ""],
    ["8b55", ""],
    ["8ba1", ""],
    ["8bde", ""],
    ["8c40", ""],
    ["8ca1", ""],
    ["8ca7", ""],
    ["8cc9", ""],
    ["8cce", ""],
    ["8ce6", ""],
    ["8d40", ""],
    ["8d42", ""],
    ["8da1", ""],
    ["8e40", ""],
    ["8ea1", ""],
    ["8f40", ""],
    ["8fa1", ""],
    ["9040", ""],
    ["90a1", ""],
    ["9140", ""],
    ["91a1", ""],
    ["9240", ""],
    ["92a1", ""],
    ["9340", ""],
    ["93a1", ""],
    ["9440", ""],
    ["94a1", ""],
    ["9540", ""],
    ["95a1", ""],
    ["9640", ""],
    ["96a1", ""],
    ["9740", ""],
    ["97a1", ""],
    ["9840", ""],
    ["98a1", ""],
    ["9940", ""],
    ["99a1", ""],
    ["9a40", ""],
    ["9aa1", ""],
    ["9b40", ""],
    ["9b62", ""],
    ["9ba1", ""],
    ["9c40", ""],
    ["9ca1", ""],
    ["9d40", ""],
    ["9da1", ""],
    ["9e40", ""],
    ["9ea1", ""],
    ["9ead", ""],
    ["9ec5", ""],
    ["9ef5", ""],
    ["9f40", ""],
    ["9f4f", ""],
    ["9fa1", ""],
    ["9fae", ""],
    ["9fb2", ""],
    ["9fc1", ""],
    ["9fc9", ""],
    ["9fdb", ""],
    ["9fe7", ""],
    ["9feb", ""],
    ["9ff0", ""],
    ["a040", ""],
    ["a055", ""],
    ["a058", ""],
    ["a05b", ""],
    ["a063", ""],
    ["a073", ""],
    ["a0a1", ""],
    ["a0a6", ""],
    ["a0ae", ""],
    ["a0b0", ""],
    ["a0d4", ""],
    ["a0e2", ""],
    ["a3c0", "", 31, ""],
    ["c6a1", "", 9, "", 9, "", 9, "", 23],
    ["c740", "", 58, ""],
    ["c7a1", "", 81, "", 5, "", 4],
    ["c840", "", 26, "", 25, ""],
    ["c8a1", ""],
    ["c8cd", ""],
    ["c8f5", ""],
    ["f9fe", ""],
    ["fa40", ""],
    ["faa1", ""],
    ["fb40", ""],
    ["fba1", ""],
    ["fc40", ""],
    ["fca1", ""],
    ["fd40", ""],
    ["fda1", ""],
    ["fe40", ""],
    ["fea1", ""]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data2 = __commonJS((exports, module) => {
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis2();
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp2();
      },
      encodeAdd: { "": 92, "": 126 }
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp9362();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp9362().concat(require_gbk_added2());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp9362().concat(require_gbk_added2());
      },
      gb18030: function() {
        return require_gb18030_ranges2();
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp9492();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp9502();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp9502().concat(require_big5_added2());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings2 = __commonJS((exports, module) => {
  var modules = [
    require_internal2(),
    require_utf162(),
    require_utf72(),
    require_sbcs_codec2(),
    require_sbcs_data2(),
    require_sbcs_data_generated2(),
    require_dbcs_codec2(),
    require_dbcs_data2()
  ];
  for (i = 0;i < modules.length; i++) {
    module = modules[i];
    for (enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
  var module;
  var enc;
  var i;
});

// node_modules/iconv-lite/lib/streams.js
var require_streams2 = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var Transform = __require("stream").Transform;
  module.exports = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
});

// node_modules/iconv-lite/lib/extend-node.js
var require_extend_node = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function(iconv) {
    var original = undefined;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        hex: true,
        utf8: true,
        "utf-8": true,
        ascii: true,
        binary: true,
        base64: true,
        ucs2: true,
        "ucs-2": true,
        utf16le: true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = __require("buffer").SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str, encoding);
        return iconv.encode(str, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding) {
        var _offset = offset, _length = length, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = __require("buffer").SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = __require("stream").Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = undefined;
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling2();
  var iconv = exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings2();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
  if (nodeVer) {
    nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
      require_streams2()(iconv);
    }
    require_extend_node()(iconv);
  }
  var nodeVerArr;
  if (false) {}
});

// node_modules/body-parser/node_modules/raw-body/index.js
var require_raw_body2 = __commonJS((exports, module) => {
  /*!
   * raw-body
   * Copyright(c) 2013-2014 Jonathan Ong
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var asyncHooks = tryRequireAsyncHooks();
  var bytes = require_bytes();
  var createError = require_http_errors();
  var iconv = require_lib2();
  var unpipe = require_unpipe();
  module.exports = getRawBody2;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding) {
    if (!encoding)
      return null;
    try {
      return iconv.getDecoder(encoding);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody2(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream === undefined) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== undefined && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !global.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve, reject) {
      readStream(stream, encoding, length, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state = stream._readableState;
    if (stream._decoder || state && (state.encoding || state.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream.readable !== "undefined" && !stream.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return __require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
});

// node_modules/ee-first/index.js
var require_ee_first = __commonJS((exports, module) => {
  /*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module.exports = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0;i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee2 = arr[0];
      for (var j2 = 1;j2 < arr.length; j2++) {
        var event = arr[j2];
        var fn = listener(event, callback);
        ee2.on(event, fn);
        cleanups.push({
          ee: ee2,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x2;
      for (var i2 = 0;i2 < cleanups.length; i2++) {
        x2 = cleanups[i2];
        x2.ee.removeListener(x2.event, x2.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee2 = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee2, event, args);
    };
  }
});

// node_modules/on-finished/index.js
var require_on_finished = __commonJS((exports, module) => {
  /*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = onFinished;
  module.exports.isFinished = isFinished;
  var asyncHooks = tryRequireAsyncHooks();
  var first = require_ee_first();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, wrap(listener));
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished)
        return;
      if (eeMsg !== eeSocket)
        return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === undefined) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener)
        msg.__onFinished = null;
      if (!listener.queue)
        return;
      var queue = listener.queue;
      listener.queue = null;
      for (var i = 0;i < queue.length; i++) {
        queue[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function")
      return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  function tryRequireAsyncHooks() {
    try {
      return __require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
});

// node_modules/body-parser/lib/read.js
var require_read = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var createError = require_http_errors();
  var destroy = require_destroy();
  var getBody = require_raw_body2();
  var iconv = require_lib2();
  var onFinished = require_on_finished();
  var unpipe = require_unpipe();
  var zlib = __require("zlib");
  module.exports = read;
  function read(req, res, next, parse, debug, options) {
    var length;
    var opts = options;
    var stream;
    req._body = true;
    var encoding = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug, opts.inflate);
      length = stream.length;
      stream.length = undefined;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding;
    if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {
      return next(createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
        charset: encoding.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug("read body");
    getBody(stream, opts, function(error, body) {
      if (error) {
        var _error;
        if (error.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
            charset: encoding.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error);
        }
        if (stream !== req) {
          unpipe(req);
          destroy(stream, true);
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug("verify body");
          verify(req, res, body, encoding);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug("parse body");
        str = typeof body !== "string" && encoding !== null ? iconv.decode(body, encoding) : body;
        req.body = parse(str);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug, inflate) {
    var encoding = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    var stream;
    debug('content-encoding "%s"', encoding);
    if (inflate === false && encoding !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding,
        type: "encoding.unsupported"
      });
    }
    switch (encoding) {
      case "deflate":
        stream = zlib.createInflate();
        debug("inflate body");
        req.pipe(stream);
        break;
      case "gzip":
        stream = zlib.createGunzip();
        debug("gunzip body");
        req.pipe(stream);
        break;
      case "identity":
        stream = req;
        stream.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding + '"', {
          encoding,
          type: "encoding.unsupported"
        });
    }
    return stream;
  }
  function dump(req, callback) {
    if (onFinished.isFinished(req)) {
      callback(null);
    } else {
      onFinished(req, callback);
      req.resume();
    }
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS((exports) => {
  /*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  exports.format = format;
  exports.parse = parse;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string === "object") {
      string = getcontenttype(string);
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = string.indexOf(";");
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type,
      subtype,
      suffix
    };
    return obj;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType2;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType2(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/type-is/index.js
var require_type_is = __commonJS((exports, module) => {
  /*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var typer = require_media_typer();
  var mime = require_mime_types();
  module.exports = typeofrequest;
  module.exports.is = typeis;
  module.exports.hasBody = hasbody;
  module.exports.normalize = normalize;
  module.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0;i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== undefined || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types);
  }
  function normalize(type) {
    if (typeof type !== "string") {
      return false;
    }
    switch (type) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type[0] === "+") {
      return "*/*" + type;
    }
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type = typer.parse(value);
    type.parameters = undefined;
    return typer.format(type);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
});

// node_modules/body-parser/lib/types/json.js
var require_json = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType2 = require_content_type();
  var createError = require_http_errors();
  var debug = require_src()("body-parser:json");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset.slice(0, 4) !== "utf-") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = "";
    if (index !== -1) {
      partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
      for (var i = index + 1;i < str.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index, index + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : undefined;
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function normalizeJsonSyntaxError(error, obj) {
    var keys = Object.getOwnPropertyNames(error);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error[key];
      }
    }
    error.stack = obj.stack.replace(error.message, obj.message);
    error.message = obj.message;
    return error;
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/lib/types/raw.js
var require_raw = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var debug = require_src()("body-parser:raw");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse, debug, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/lib/types/text.js
var require_text = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType2 = require_content_type();
  var debug = require_src()("body-parser:text");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || defaultCharset;
      read(req, res, next, parse, debug, {
        encoding: charset,
        inflate,
        limit,
        verify
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS((exports, module) => {
  module.exports = __require("util").inspect;
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS((exports, module) => {
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
    return O2.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require_util_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    double: '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "\t" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0;i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && ((toStringTag in obj) || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x2) {
    if (xs.indexOf) {
      return xs.indexOf(x2);
    }
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x2) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e) {}
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e) {}
    return false;
  }
  function isWeakRef(x2) {
    if (!weakRefDeref || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x2);
      return true;
    } catch (e) {}
    return false;
  }
  function isSet(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e) {}
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e) {}
    return false;
  }
  function isElement(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0;i < xs.length; i++) {
      if (indexOf(xs[i], `
`) >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "\t") {
      baseIndent = "\t";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = `
` + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + `
` + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0;i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k2 = 0;k2 < syms.length; k2++) {
        symMap["$" + syms[k2]] = syms[k2];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j2 = 0;j2 < syms.length; j2++) {
        if (isEnumerable.call(obj, syms[j2])) {
          xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
        }
      }
    }
    return xs;
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS((exports, module) => {
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (;(curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = {
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  module.exports = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = undefined;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: undefined
          };
        }
        listSet($o, key, value);
      }
    };
    return channel;
  };
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
  module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
  module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
  var $isNaN = require_isNaN();
  module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
  var $Object = require_es_object_atoms();
  module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b2) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0;j2 < b2.length; j2 += 1) {
      arr[j2 + a.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j2 = 0;i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module.exports = reflectGetProto ? function getProto(O2) {
    return reflectGetProto(O2);
  } : originalGetProto ? function getProto(O2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O2);
  } : getDunderProto ? function getProto(O2) {
    return getDunderProto(O2);
  } : null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBindBasic = require_call_bind_apply_helpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var $mapDelete = callBound("Map.prototype.delete", true);
  var $mapSize = callBound("Map.prototype.size", true);
  module.exports = !!$Map && function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = undefined;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map;
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var getSideChannelMap = require_side_channel_map();
  var $TypeError = require_type();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
  module.exports = $WeakMap ? function getSideChannelWeakMap() {
    var $wm;
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap) {
          if ($m) {
            return $m["delete"](key);
          }
        }
        return false;
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap;
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap) {
          if (!$m) {
            $m = getSideChannelMap();
          }
          $m.set(key, value);
        }
      }
    };
    return channel;
  } : getSideChannelMap;
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS((exports, module) => {
  var $TypeError = require_type();
  var inspect = require_object_inspect();
  var getSideChannelList = require_side_channel_list();
  var getSideChannelMap = require_side_channel_map();
  var getSideChannelWeakMap = require_side_channel_weakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  module.exports = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports, module) => {
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  module.exports = {
    default: Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0;i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j2 = 0;j2 < obj.length; ++j2) {
          if (typeof obj[j2] !== "undefined") {
            compacted.push(obj[j2]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0;i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode = function encode(str, defaultEncoder, charset, kind, format) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j2 = 0;j2 < string.length; j2 += limit) {
      var segment = string.length >= limit ? string.slice(j2, j2 + limit) : string;
      var arr = [];
      for (var i = 0;i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 128) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0;i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j2 = 0;j2 < keys.length; ++j2) {
        var key = keys[j2];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine(a, b2) {
    return [].concat(a, b2);
  };
  var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0;i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  module.exports = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    maybeMap,
    merge
  };
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getSideChannel = require_side_channel();
  var utils = require_utils();
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive(v2) {
    return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
  };
  var sentinel = {};
  var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== undefined && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = utils.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : undefined }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j2 = 0;j2 < objKeys.length; ++j2) {
      var key = objKeys[j2];
      var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var utils = require_utils();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0;i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0;i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        });
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1;i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };
});

// node_modules/qs/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var parse = require_parse();
  var formats = require_formats();
  module.exports = {
    formats,
    parse,
    stringify
  };
});

// node_modules/body-parser/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bytes = require_bytes();
  var contentType2 = require_content_type();
  var createError = require_http_errors();
  var debug = require_src()("body-parser:urlencoded");
  var deprecate = require_depd()("body-parser");
  var read = require_read();
  var typeis = require_type_is();
  module.exports = urlencoded;
  var parsers = Object.create(null);
  function urlencoded(options) {
    var opts = options || {};
    if (opts.extended === undefined) {
      deprecate("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes.parse(opts.limit || "100kb") : opts.limit;
    var type = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    var depth = typeof opts.depth !== "number" ? Number(opts.depth || 32) : opts.depth;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type !== "function" ? typeChecker(type) : type;
    function parse(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug("skip empty body");
        next();
        return;
      }
      debug("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug("skip parsing");
        next();
        return;
      }
      var charset = getCharset(req) || "utf-8";
      if (charset !== "utf-8") {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
          charset,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse, debug, {
        debug,
        encoding: charset,
        inflate,
        limit,
        verify,
        depth
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var depth = typeof options.depth !== "number" ? Number(options.depth || 32) : options.depth;
    var parse = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isNaN(depth) || depth < 0) {
      throw new TypeError("option depth must be a zero or a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug("parse extended urlencoding");
      try {
        return parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth,
          strictDepth: true,
          parameterLimit
        });
      } catch (err) {
        if (err instanceof RangeError) {
          throw createError(400, "The input exceeded the depth", {
            type: "querystring.parse.rangeError"
          });
        } else {
          throw err;
        }
      }
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index = 0;
    while ((index = body.indexOf("&", index)) !== -1) {
      count++;
      index++;
      if (count === limit) {
        return;
      }
    }
    return count;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== undefined) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = require_lib3();
        break;
      case "querystring":
        mod = __require("querystring");
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
    var parse = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === undefined) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug("parse urlencoding");
      return parse(body, undefined, undefined, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type) {
    return function checkType(req) {
      return Boolean(typeis(req, type));
    };
  }
});

// node_modules/body-parser/index.js
var require_body_parser = __commonJS((exports, module) => {
  /*!
   * body-parser
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var deprecate = require_depd()("body-parser");
  var parsers = Object.create(null);
  exports = module.exports = deprecate.function(bodyParser, "bodyParser: use individual json/urlencoded middlewares");
  Object.defineProperty(exports, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser(options) {
    var opts = Object.create(options || null, {
      type: {
        configurable: true,
        enumerable: true,
        value: undefined,
        writable: true
      }
    });
    var _urlencoded = exports.urlencoded(opts);
    var _json = exports.json(opts);
    return function bodyParser(req, res, next) {
      _json(req, res, function(err) {
        if (err)
          return next(err);
        _urlencoded(req, res, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== undefined) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = require_json();
        break;
      case "raw":
        parser = require_raw();
        break;
      case "text":
        parser = require_text();
        break;
      case "urlencoded":
        parser = require_urlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
});

// node_modules/merge-descriptors/index.js
var require_merge_descriptors = __commonJS((exports, module) => {
  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = merge;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function merge(dest, src, redefine) {
    if (!dest) {
      throw new TypeError("argument dest is required");
    }
    if (!src) {
      throw new TypeError("argument src is required");
    }
    if (redefine === undefined) {
      redefine = true;
    }
    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty.call(dest, name)) {
        return;
      }
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });
    return dest;
  }
});

// node_modules/finalhandler/node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/finalhandler/node_modules/debug/src/debug.js
var require_debug2 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce2;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms2();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/finalhandler/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  exports = module.exports = require_debug2();
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/finalhandler/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports = module.exports = require_debug2();
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
      return k2.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log2() {
    return stream.write(util2.format.apply(util2, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/finalhandler/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser2();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/encodeurl/index.js
var require_encodeurl = __commonJS((exports, module) => {
  /*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS((exports, module) => {
  /*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   */
  var matchHtmlRegExp = /["'&<>]/;
  module.exports = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for (index = match.index;index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape2;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
});

// node_modules/parseurl/index.js
var require_parseurl = __commonJS((exports, module) => {
  /*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var url = __require("url");
  var parse = url.parse;
  var Url = url.Url;
  module.exports = parseurl;
  module.exports.original = originalurl;
  function parseurl(req) {
    var url2 = req.url;
    if (url2 === undefined) {
      return;
    }
    var parsed = req._parsedUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url2 = req.originalUrl;
    if (typeof url2 !== "string") {
      return parseurl(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url2, parsed)) {
      return parsed;
    }
    parsed = fastparse(url2);
    parsed._raw = url2;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1;i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        case 10:
        case 12:
        case 13:
        case 32:
        case 35:
        case 160:
        case 65279:
          return parse(str);
      }
    }
    var url2 = Url !== undefined ? new Url : {};
    url2.path = str;
    url2.href = str;
    url2.pathname = pathname;
    if (search !== null) {
      url2.query = query;
      url2.search = search;
    }
    return url2;
  }
  function fresh(url2, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url2;
  }
});

// node_modules/finalhandler/index.js
var require_finalhandler = __commonJS((exports, module) => {
  /*!
   * finalhandler
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src2()("finalhandler");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var onFinished = require_on_finished();
  var parseUrl = require_parseurl();
  var statuses = require_statuses();
  var unpipe = require_unpipe();
  var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
  var NEWLINE_REGEXP = /\n/g;
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  var isFinished = onFinished.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + `<title>Error</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  module.exports = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env = opts.env || "development";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && headersSent(res)) {
        debug("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === undefined) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug("default %s", status);
      if (err && onerror) {
        defer(onerror, err, req, res);
      }
      if (headersSent(res)) {
        debug("cannot %d after headers sent", status);
        if (req.socket) {
          req.socket.destroy();
        }
        return;
      }
      send(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return;
    }
    var headers = Object.create(null);
    var keys = Object.keys(err.headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      headers[key] = err.headers[key];
    }
    return headers;
  }
  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses.message[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function send(req, res, status, headers, message) {
    function write() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      if (req.httpVersionMajor < 2) {
        res.statusMessage = statuses.message[status];
      }
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Range");
      setHeaders(res, headers);
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    unpipe(req);
    onFinished(req, write);
    req.resume();
  }
  function setHeaders(res, headers) {
    if (!headers) {
      return;
    }
    var keys = Object.keys(headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// node_modules/express/node_modules/ms/index.js
var require_ms3 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/express/node_modules/debug/src/debug.js
var require_debug3 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce2;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms3();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/express/node_modules/debug/src/browser.js
var require_browser3 = __commonJS((exports, module) => {
  exports = module.exports = require_debug3();
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/express/node_modules/debug/src/node.js
var require_node3 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports = module.exports = require_debug3();
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
      return k2.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log2() {
    return stream.write(util2.format.apply(util2, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/express/node_modules/debug/src/index.js
var require_src3 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser3();
  } else {
    module.exports = require_node3();
  }
});

// node_modules/array-flatten/array-flatten.js
var require_array_flatten = __commonJS((exports, module) => {
  module.exports = arrayFlatten;
  function flattenWithDepth(array, result, depth) {
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      if (depth > 0 && Array.isArray(value)) {
        flattenWithDepth(value, result, depth - 1);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function flattenForever(array, result) {
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        flattenForever(value, result);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function arrayFlatten(array, depth) {
    if (depth == null) {
      return flattenForever(array, []);
    }
    return flattenWithDepth(array, [], depth);
  }
});

// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS((exports, module) => {
  module.exports = pathToRegexp;
  var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
  function pathToRegexp(path, keys, options) {
    options = options || {};
    keys = keys || [];
    var strict = options.strict;
    var end = options.end !== false;
    var flags = options.sensitive ? "" : "i";
    var lookahead = options.lookahead !== false;
    var extraOffset = 0;
    var keysOffset = keys.length;
    var i = 0;
    var name = 0;
    var pos = 0;
    var backtrack = "";
    var m;
    if (path instanceof RegExp) {
      while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
        if (m[0][0] === "\\")
          continue;
        keys.push({
          name: m[1] || name++,
          optional: false,
          offset: m.index
        });
      }
      return path;
    }
    if (Array.isArray(path)) {
      path = path.map(function(value) {
        return pathToRegexp(value, keys, options).source;
      });
      return new RegExp(path.join("|"), flags);
    }
    if (typeof path !== "string") {
      throw new TypeError("path must be a string, array of strings, or regular expression");
    }
    path = path.replace(/\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g, function(match, slash, format, key, capture, star, optional, offset) {
      if (match[0] === "\\") {
        backtrack += match;
        pos += 2;
        return match;
      }
      if (match === ".") {
        backtrack += "\\.";
        extraOffset += 1;
        pos += 1;
        return "\\.";
      }
      if (slash || format) {
        backtrack = "";
      } else {
        backtrack += path.slice(pos, offset);
      }
      pos = offset + match.length;
      if (match === "*") {
        extraOffset += 3;
        return "(.*)";
      }
      if (match === "/(") {
        backtrack += "/";
        extraOffset += 2;
        return "/(?:";
      }
      slash = slash || "";
      format = format ? "\\." : "";
      optional = optional || "";
      capture = capture ? capture.replace(/\\.|\*/, function(m2) {
        return m2 === "*" ? "(.*)" : m2;
      }) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format + "]+?)";
      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });
      var result = "(?:" + format + slash + capture + (star ? "((?:[/" + format + "].+?)?)" : "") + ")" + optional;
      extraOffset += result.length - match.length;
      return result;
    });
    while (m = MATCHING_GROUP_REGEXP.exec(path)) {
      if (m[0][0] === "\\")
        continue;
      if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
        keys.splice(keysOffset + i, 0, {
          name: name++,
          optional: false,
          offset: m.index
        });
      }
      i++;
    }
    path += strict ? "" : path[path.length - 1] === "/" ? "?" : "/?";
    if (end) {
      path += "$";
    } else if (path[path.length - 1] !== "/") {
      path += lookahead ? "(?=/|$)" : "(?:/|$)";
    }
    return new RegExp("^" + path, flags);
  }
});

// node_modules/express/lib/router/layer.js
var require_layer = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var pathRegexp = require_path_to_regexp();
  var debug = require_src3()("express:router:layer");
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = Layer;
  function Layer(path, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path, options, fn);
    }
    debug("new %o", path);
    var opts = options || {};
    this.handle = fn;
    this.name = fn.name || "<anonymous>";
    this.params = undefined;
    this.path = undefined;
    this.regexp = pathRegexp(path, this.keys = [], opts);
    this.regexp.fast_star = path === "*";
    this.regexp.fast_slash = path === "/" && opts.end === false;
  }
  Layer.prototype.handle_error = function handle_error(error, req, res, next) {
    var fn = this.handle;
    if (fn.length !== 4) {
      return next(error);
    }
    try {
      fn(error, req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handle_request = function handle(req, res, next) {
    var fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      fn(req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path) {
    var match;
    if (path != null) {
      if (this.regexp.fast_slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      if (this.regexp.fast_star) {
        this.params = { "0": decode_param(path) };
        this.path = path;
        return true;
      }
      match = this.regexp.exec(path);
    }
    if (!match) {
      this.params = undefined;
      this.path = undefined;
      return false;
    }
    this.params = {};
    this.path = match[0];
    var keys = this.keys;
    var params = this.params;
    for (var i = 1;i < match.length; i++) {
      var key = keys[i - 1];
      var prop = key.name;
      var val = decode_param(match[i]);
      if (val !== undefined || !hasOwnProperty.call(params, prop)) {
        params[prop] = val;
      }
    }
    return true;
  };
  function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = err.statusCode = 400;
      }
      throw err;
    }
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS((exports, module) => {
  /*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var http = __require("http");
  module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
  function getCurrentNodeMethods() {
    return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
      return method.toLowerCase();
    });
  }
  function getBasicNodeMethods() {
    return [
      "get",
      "post",
      "put",
      "head",
      "delete",
      "options",
      "trace",
      "copy",
      "lock",
      "mkcol",
      "move",
      "purge",
      "propfind",
      "proppatch",
      "unlock",
      "report",
      "mkactivity",
      "checkout",
      "merge",
      "m-search",
      "notify",
      "subscribe",
      "unsubscribe",
      "patch",
      "search",
      "connect"
    ];
  }
});

// node_modules/express/lib/router/route.js
var require_route = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src3()("express:router:route");
  var flatten = require_array_flatten();
  var Layer = require_layer();
  var methods = require_methods();
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  module.exports = Route;
  function Route(path) {
    this.path = path;
    this.stack = [];
    debug("new %o", path);
    this.methods = {};
  }
  Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
      return true;
    }
    var name = typeof method === "string" ? method.toLowerCase() : method;
    if (name === "head" && !this.methods["head"]) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._options = function _options() {
    var methods2 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods2.push("head");
    }
    for (var i = 0;i < methods2.length; i++) {
      methods2[i] = methods2[i].toUpperCase();
    }
    return methods2;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    var idx = 0;
    var stack = this.stack;
    var sync = 0;
    if (stack.length === 0) {
      return done();
    }
    var method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
    if (method === "head" && !this.methods["head"]) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      var layer = stack[idx++];
      if (!layer) {
        return done(err);
      }
      if (layer.method && layer.method !== method) {
        next(err);
      } else if (err) {
        layer.handle_error(err, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
      sync = 0;
    }
  };
  Route.prototype.all = function all() {
    var handles = flatten(slice.call(arguments));
    for (var i = 0;i < handles.length; i++) {
      var handle = handles[i];
      if (typeof handle !== "function") {
        var type = toString.call(handle);
        var msg = "Route.all() requires a callback function but got a " + type;
        throw new TypeError(msg);
      }
      var layer = Layer("/", {}, handle);
      layer.method = undefined;
      this.methods._all = true;
      this.stack.push(layer);
    }
    return this;
  };
  methods.forEach(function(method) {
    Route.prototype[method] = function() {
      var handles = flatten(slice.call(arguments));
      for (var i = 0;i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type = toString.call(handle);
          var msg = "Route." + method + "() requires a callback function but got a " + type;
          throw new Error(msg);
        }
        debug("%s %o", method, this.path);
        var layer = Layer("/", {}, handle);
        layer.method = method;
        this.methods[method] = true;
        this.stack.push(layer);
      }
      return this;
    };
  });
});

// node_modules/utils-merge/index.js
var require_utils_merge = __commonJS((exports, module) => {
  exports = module.exports = function(a, b2) {
    if (a && b2) {
      for (var key in b2) {
        a[key] = b2[key];
      }
    }
    return a;
  };
});

// node_modules/express/lib/router/index.js
var require_router = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Route = require_route();
  var Layer = require_layer();
  var methods = require_methods();
  var mixin = require_utils_merge();
  var debug = require_src3()("express:router");
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var parseUrl = require_parseurl();
  var setPrototypeOf = require_setprototypeof();
  var objectRegExp = /^\[object (\S+)\]$/;
  var slice = Array.prototype.slice;
  var toString = Object.prototype.toString;
  var proto = module.exports = function(options) {
    var opts = options || {};
    function router(req, res, next) {
      router.handle(req, res, next);
    }
    setPrototypeOf(router, proto);
    router.params = {};
    router._params = [];
    router.caseSensitive = opts.caseSensitive;
    router.mergeParams = opts.mergeParams;
    router.strict = opts.strict;
    router.stack = [];
    return router;
  };
  proto.param = function param(name, fn) {
    if (typeof name === "function") {
      deprecate("router.param(fn): Refactor to use path params");
      this._params.push(name);
      return;
    }
    var params = this._params;
    var len = params.length;
    var ret;
    if (name[0] === ":") {
      deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
      name = name.slice(1);
    }
    for (var i = 0;i < len; ++i) {
      if (ret = params[i](name, fn)) {
        fn = ret;
      }
    }
    if (typeof fn !== "function") {
      throw new Error("invalid param() call for " + name + ", got " + fn);
    }
    (this.params[name] = this.params[name] || []).push(fn);
    return this;
  };
  proto.handle = function handle(req, res, out) {
    var self = this;
    debug("dispatching %s %s", req.method, req.url);
    var idx = 0;
    var protohost = getProtohost(req.url) || "";
    var removed = "";
    var slashAdded = false;
    var sync = 0;
    var paramcalled = {};
    var options = [];
    var stack = self.stack;
    var parentParams = req.params;
    var parentUrl = req.baseUrl || "";
    var done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      done = wrap(done, function(old, err) {
        if (err || options.length === 0)
          return old(err);
        sendOptionsResponse(res, options, old);
      });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      var layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.slice(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.slice(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack.length) {
        setImmediate(done, layerError);
        return;
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      var path = getPathname(req);
      if (path == null) {
        return done(layerError);
      }
      var layer;
      var match;
      var route;
      while (match !== true && idx < stack.length) {
        layer = stack[idx++];
        match = matchLayer(layer, path);
        route = layer.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        var method = req.method;
        var has_method = route._handles_method(method);
        if (!has_method && method === "OPTIONS") {
          appendMethods(options, route._options());
        }
        if (!has_method && method !== "HEAD") {
          match = false;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route) {
        req.route = route;
      }
      req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
      var layerPath = layer.path;
      self.process_params(layer, paramcalled, req, res, function(err2) {
        if (err2) {
          next(layerError || err2);
        } else if (route) {
          layer.handle_request(req, res, next);
        } else {
          trim_prefix(layer, layerError, layerPath, path);
        }
        sync = 0;
      });
    }
    function trim_prefix(layer, layerError, layerPath, path) {
      if (layerPath.length !== 0) {
        if (layerPath !== path.slice(0, layerPath.length)) {
          next(layerError);
          return;
        }
        var c = path[layerPath.length];
        if (c && c !== "/" && c !== ".")
          return next(layerError);
        debug("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.slice(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug("%s %s : %s", layer.name, layerPath, req.originalUrl);
      if (layerError) {
        layer.handle_error(layerError, req, res, next);
      } else {
        layer.handle_request(req, res, next);
      }
    }
  };
  proto.process_params = function process_params(layer, called, req, res, done) {
    var params = this.params;
    var keys = layer.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    var i = 0;
    var name;
    var paramIndex = 0;
    var key;
    var paramVal;
    var paramCallbacks;
    var paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key = keys[i++];
      name = key.name;
      paramVal = req.params[name];
      paramCallbacks = params[name];
      paramCalled = called[name];
      if (paramVal === undefined || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[name] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[name] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      var fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key.name];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn)
        return param();
      try {
        fn(req, res, paramCallback, paramVal, key.name);
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  };
  proto.use = function use(fn) {
    var offset = 0;
    var path = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path = fn;
      }
    }
    var callbacks = flatten(slice.call(arguments, offset));
    if (callbacks.length === 0) {
      throw new TypeError("Router.use() requires a middleware function");
    }
    for (var i = 0;i < callbacks.length; i++) {
      var fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
      }
      debug("use %o %s", path, fn.name || "<anonymous>");
      var layer = new Layer(path, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer.route = undefined;
      this.stack.push(layer);
    }
    return this;
  };
  proto.route = function route(path) {
    var route = new Route(path);
    var layer = new Layer(path, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, route.dispatch.bind(route));
    layer.route = route;
    this.stack.push(layer);
    return route;
  };
  methods.concat("all").forEach(function(method) {
    proto[method] = function(path) {
      var route = this.route(path);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  function appendMethods(list, addition) {
    for (var i = 0;i < addition.length; i++) {
      var method = addition[i];
      if (list.indexOf(method) === -1) {
        list.push(method);
      }
    }
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return;
    }
  }
  function getProtohost(url) {
    if (typeof url !== "string" || url.length === 0 || url[0] === "/") {
      return;
    }
    var searchIndex = url.indexOf("?");
    var pathLength = searchIndex !== -1 ? searchIndex : url.length;
    var fqdnIndex = url.slice(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url.substring(0, url.indexOf("/", 3 + fqdnIndex)) : undefined;
  }
  function gettype(obj) {
    var type = typeof obj;
    if (type !== "object") {
      return type;
    }
    return toString.call(obj).replace(objectRegExp, "$1");
  }
  function matchLayer(layer, path) {
    try {
      return layer.match(path);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    var obj = mixin({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return mixin(obj, params);
    }
    var i = 0;
    var o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--;i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return mixin(obj, params);
  }
  function restore(fn, obj) {
    var props = new Array(arguments.length - 2);
    var vals = new Array(arguments.length - 2);
    for (var i = 0;i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (var i2 = 0;i2 < props.length; i2++) {
        obj[props[i2]] = vals[i2];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, options, next) {
    try {
      var body = options.join(",");
      res.set("Allow", body);
      res.send(body);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn) {
    return function proxy() {
      var args = new Array(arguments.length + 1);
      args[0] = old;
      for (var i = 0, len = arguments.length;i < len; i++) {
        args[i + 1] = arguments[i];
      }
      fn.apply(this, args);
    };
  }
});

// node_modules/express/lib/middleware/init.js
var require_init = __commonJS((exports) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var setPrototypeOf = require_setprototypeof();
  exports.init = function(app) {
    return function expressInit(req, res, next) {
      if (app.enabled("x-powered-by"))
        res.setHeader("X-Powered-By", "Express");
      req.res = res;
      res.req = req;
      req.next = next;
      setPrototypeOf(req, app.request);
      setPrototypeOf(res, app.response);
      res.locals = res.locals || Object.create(null);
      next();
    };
  };
});

// node_modules/express/lib/middleware/query.js
var require_query = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var merge = require_utils_merge();
  var parseUrl = require_parseurl();
  var qs = require_lib3();
  module.exports = function query(options) {
    var opts = merge({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = undefined;
    }
    if (opts !== undefined && opts.allowPrototypes === undefined) {
      opts.allowPrototypes = true;
    }
    return function query(req, res, next) {
      if (!req.query) {
        var val = parseUrl(req).query;
        req.query = queryparse(val, opts);
      }
      next();
    };
  };
});

// node_modules/express/lib/view.js
var require_view = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var debug = require_src3()("express:view");
  var path = __require("path");
  var fs = __require("fs");
  var dirname = path.dirname;
  var basename = path.basename;
  var extname = path.extname;
  var join = path.join;
  var resolve = path.resolve;
  module.exports = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod = this.ext.slice(1);
      debug('require "%s"', mod);
      var fn = __require(mod).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path2;
    var roots = [].concat(this.root);
    debug('lookup "%s"', name);
    for (var i = 0;i < roots.length && !path2; i++) {
      var root = roots[i];
      var loc = resolve(root, name);
      var dir = dirname(loc);
      var file = basename(loc);
      path2 = this.resolve(dir, file);
    }
    return path2;
  };
  View.prototype.render = function render(options, callback) {
    debug('render "%s"', this.path);
    this.engine(this.path, options, callback);
  };
  View.prototype.resolve = function resolve(dir, file) {
    var ext = this.ext;
    var path2 = join(dir, file);
    var stat = tryStat(path2);
    if (stat && stat.isFile()) {
      return path2;
    }
    path2 = join(dir, basename(file, ext), "index" + ext);
    stat = tryStat(path2);
    if (stat && stat.isFile()) {
      return path2;
    }
  };
  function tryStat(path2) {
    debug('stat "%s"', path2);
    try {
      return fs.statSync(path2);
    } catch (e) {
      return;
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS((exports, module) => {
  /*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = contentDisposition;
  module.exports.parse = parse;
  var basename = __require("path").basename;
  var Buffer2 = require_safe_buffer().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition(filename, options) {
    var opts = options || {};
    var type = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format(new ContentDisposition(type, params));
  }
  function createparams(filename, fallback) {
    if (filename === undefined) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === undefined) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format(obj) {
    var parameters = obj.parameters;
    var type = obj.type;
    if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
      throw new TypeError("invalid type");
    }
    var string = String(type).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index = match[0].length;
    var type = match[1].toLowerCase();
    var key;
    var names = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type, parameters) {
    this.type = type;
    this.parameters = parameters;
  }
});

// node_modules/send/node_modules/debug/node_modules/ms/index.js
var require_ms4 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    return plural(ms, d, "day") || plural(ms, h2, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  }
  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  }
});

// node_modules/send/node_modules/debug/src/debug.js
var require_debug4 = __commonJS((exports, module) => {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce2;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms4();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});

// node_modules/send/node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports, module) => {
  exports = module.exports = require_debug4();
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {}
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }
});

// node_modules/send/node_modules/debug/src/node.js
var require_node4 = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports = module.exports = require_debug4();
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
      return k2.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util2.deprecate(function() {}, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  }
  exports.formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
  function formatArgs(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  }
  function log2() {
    return stream.write(util2.format.apply(util2, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs = __require("fs");
        stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = __require("net");
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  exports.enable(load());
});

// node_modules/send/node_modules/debug/src/index.js
var require_src4 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser4();
  } else {
    module.exports = require_node4();
  }
});

// node_modules/send/node_modules/encodeurl/index.js
var require_encodeurl2 = __commonJS((exports, module) => {
  /*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url) {
    return String(url).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
});

// node_modules/etag/index.js
var require_etag = __commonJS((exports, module) => {
  /*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = etag;
  var crypto = __require("crypto");
  var Stats = __require("fs").Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
});

// node_modules/fresh/index.js
var require_fresh = __commonJS((exports, module) => {
  /*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  module.exports = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch && noneMatch !== "*") {
      var etag = resHeaders["etag"];
      if (!etag) {
        return false;
      }
      var etagStale = true;
      var matches = parseTokenList(noneMatch);
      for (var i = 0;i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          etagStale = false;
          break;
        }
      }
      if (etagStale) {
        return false;
      }
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length;i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
});

// node_modules/mime/types.json
var require_types = __commonJS((exports, module) => {
  module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
});

// node_modules/mime/mime.js
var require_mime = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  function Mime() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  }
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0;i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
        }
        this.types[exts[i]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path2, fallback) {
    var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime;
  mime.define(require_types());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module.exports = mime;
});

// node_modules/ms/index.js
var require_ms5 = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h2 = m * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/range-parser/index.js
var require_range_parser = __commonJS((exports, module) => {
  /*!
   * range-parser
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
      return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for (var i = 0;i < arr.length; i++) {
      var range = arr[i].split("-");
      var start = parseInt(range[0], 10);
      var end = parseInt(range[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j2 = 0, i = 1;i < ordered.length; i++) {
      var range = ordered[i];
      var current = ordered[j2];
      if (range.start > current.end + 1) {
        ordered[++j2] = range;
      } else if (range.end > current.end) {
        current.end = range.end;
        current.index = Math.min(current.index, range.index);
      }
    }
    ordered.length = j2 + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range, index) {
    return {
      start: range.start,
      end: range.end,
      index
    };
  }
  function mapWithoutIndex(range) {
    return {
      start: range.start,
      end: range.end
    };
  }
  function sortByRangeIndex(a, b2) {
    return a.index - b2.index;
  }
  function sortByRangeStart(a, b2) {
    return a.start - b2.start;
  }
});

// node_modules/send/index.js
var require_send = __commonJS((exports, module) => {
  /*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  var createError = require_http_errors();
  var debug = require_src4()("send");
  var deprecate = require_depd()("send");
  var destroy = require_destroy();
  var encodeUrl = require_encodeurl2();
  var escapeHtml = require_escape_html();
  var etag = require_etag();
  var fresh = require_fresh();
  var fs = __require("fs");
  var mime = require_mime();
  var ms = require_ms5();
  var onFinished = require_on_finished();
  var parseRange = require_range_parser();
  var path = __require("path");
  var statuses = require_statuses();
  var Stream = __require("stream");
  var util2 = __require("util");
  var extname = path.extname;
  var join = path.join;
  var normalize = path.normalize;
  var resolve = path.resolve;
  var sep = path.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  module.exports = send;
  module.exports.mime = mime;
  function send(req, path2, options) {
    return new SendStream(req, path2, options);
  }
  function SendStream(req, path2, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path2;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._hidden = Boolean(opts.hidden);
    if (opts.hidden !== undefined) {
      deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
    }
    if (opts.dotfiles === undefined) {
      this._dotfiles = undefined;
    }
    this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;
    this._index = opts.index !== undefined ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve(opts.root) : null;
    if (!this._root && opts.from) {
      this.from(opts.from);
    }
  }
  util2.inherits(SendStream, Stream);
  SendStream.prototype.etag = deprecate.function(function etag(val) {
    this._etag = Boolean(val);
    debug("etag %s", this._etag);
    return this;
  }, "send.etag: pass etag as option");
  SendStream.prototype.hidden = deprecate.function(function hidden(val) {
    this._hidden = Boolean(val);
    this._dotfiles = undefined;
    debug("hidden %s", this._hidden);
    return this;
  }, "send.hidden: use dotfiles option");
  SendStream.prototype.index = deprecate.function(function index(paths) {
    var index = !paths ? [] : normalizeList(paths, "paths argument");
    debug("index %o", paths);
    this._index = index;
    return this;
  }, "send.index: pass index as option");
  SendStream.prototype.root = function root(path2) {
    this._root = resolve(String(path2));
    debug("root %s", this._root);
    return this;
  };
  SendStream.prototype.from = deprecate.function(SendStream.prototype.root, "send.from: pass root as option");
  SendStream.prototype.root = deprecate.function(SendStream.prototype.root, "send.root: pass root as option");
  SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
    this._maxage = typeof maxAge === "string" ? ms(maxAge) : Number(maxAge);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    debug("max-age %d", this._maxage);
    return this;
  }, "send.maxage: pass maxAge as option");
  SendStream.prototype.error = function error(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses.message[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader("Content-Encoding");
    res.removeHeader("Content-Language");
    res.removeHeader("Content-Length");
    res.removeHeader("Content-Range");
    res.removeHeader("Content-Type");
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error) {
    switch (error.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error);
        break;
      default:
        this.error(500, error);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path2) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path2);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe(res) {
    var root = this._root;
    this.res = res;
    var path2 = decode(this.path);
    if (path2 === -1) {
      this.error(400);
      return res;
    }
    if (~path2.indexOf("\x00")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      if (path2) {
        path2 = normalize("." + sep + path2);
      }
      if (UP_PATH_REGEXP.test(path2)) {
        debug('malicious path "%s"', path2);
        this.error(403);
        return res;
      }
      parts = path2.split(sep);
      path2 = normalize(join(root, path2));
    } else {
      if (UP_PATH_REGEXP.test(path2)) {
        debug('malicious path "%s"', path2);
        this.error(403);
        return res;
      }
      parts = normalize(path2).split(sep);
      path2 = resolve(path2);
    }
    if (containsDotFile(parts)) {
      var access = this._dotfiles;
      if (access === undefined) {
        access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
      }
      debug('%s dotfile "%s"', access, path2);
      switch (access) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path2);
      return res;
    }
    this.sendFile(path2);
    return res;
  };
  SendStream.prototype.send = function send(path2, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (headersSent(res)) {
      this.headersAlreadySent();
      return;
    }
    debug('pipe "%s"', path2);
    this.setHeader(path2, stat);
    this.type(path2);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== undefined) {
      var bytes = options.end - offset + 1;
      if (len > bytes)
        len = bytes;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path2, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path2) {
    var i = 0;
    var self = this;
    debug('stat "%s"', path2);
    fs.stat(path2, function onstat(err, stat) {
      if (err && err.code === "ENOENT" && !extname(path2) && path2[path2.length - 1] !== sep) {
        return next(err);
      }
      if (err)
        return self.onStatError(err);
      if (stat.isDirectory())
        return self.redirect(path2);
      self.emit("file", path2, stat);
      self.send(path2, stat);
    });
    function next(err) {
      if (self._extensions.length <= i) {
        return err ? self.onStatError(err) : self.error(404);
      }
      var p = path2 + "." + self._extensions[i++];
      debug('stat "%s"', p);
      fs.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self.emit("file", p, stat);
        self.send(p, stat);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path2) {
    var i = -1;
    var self = this;
    function next(err) {
      if (++i >= self._index.length) {
        if (err)
          return self.onStatError(err);
        return self.error(404);
      }
      var p = join(path2, self._index[i]);
      debug('stat "%s"', p);
      fs.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self.emit("file", p, stat);
        self.send(p, stat);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream(path2, options) {
    var self = this;
    var res = this.res;
    var stream = fs.createReadStream(path2, options);
    this.emit("stream", stream);
    stream.pipe(res);
    function cleanup() {
      destroy(stream, true);
    }
    onFinished(res, cleanup);
    stream.on("error", function onerror(err) {
      cleanup();
      self.onStatError(err);
    });
    stream.on("end", function onend() {
      self.emit("end");
    });
  };
  SendStream.prototype.type = function type(path2) {
    var res = this.res;
    if (res.getHeader("Content-Type"))
      return;
    var type = mime.lookup(path2);
    if (!type) {
      debug("no content-type");
      return;
    }
    var charset = mime.charsets.lookup(type);
    debug("content-type %s", type);
    res.setHeader("Content-Type", type + (charset ? "; charset=" + charset : ""));
  };
  SendStream.prototype.setHeader = function setHeader(path2, stat) {
    var res = this.res;
    this.emit("headers", res, path2, stat);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1000);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat.mtime.toUTCString();
      debug("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat);
      debug("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    var headers = getHeaderNames(res);
    for (var i = 0;i < headers.length; i++) {
      res.removeHeader(headers[i]);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0;i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0;i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type, size, range) {
    return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + "<title>" + title + `</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
  }
  function decode(path2) {
    try {
      return decodeURIComponent(path2);
    } catch (err) {
      return -1;
    }
  }
  function getHeaderNames(res) {
    return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
  }
  function hasListeners(emitter, type) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
    return count > 0;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0;i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp = date && Date.parse(date);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length;i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0;i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
});

// node_modules/forwarded/index.js
var require_forwarded = __commonJS((exports, module) => {
  /*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1;i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function() {
    var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
    ipaddr = {};
    root = this;
    if (typeof module !== "undefined" && module !== null && module.exports) {
      module.exports = ipaddr;
    } else {
      root["ipaddr"] = ipaddr;
    }
    matchCIDR = function(first, second, partSize, cidrBits) {
      var part, shift;
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      var k2, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k2 = 0, len = rangeSubnets.length;k2 < len; k2++) {
          subnet = rangeSubnets[k2];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        var k2, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k2 = 0, len = octets.length;k2 < len; k2++) {
          octet = octets[k2];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k2, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k2 = 3;k2 >= 0; i = k2 += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr.IPv4.parser = function(string) {
      var match, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k2, len, ref, results;
          ref = match.slice(1, 6);
          results = [];
          for (k2 = 0, len = ref.length;k2 < len; k2++) {
            part = ref[k2];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k2, results;
          results = [];
          for (shift = k2 = 0;k2 <= 24; shift = k2 += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k2, l, len, part, ref;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k2 = 0;k2 <= 14; i = k2 += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref = this.parts;
        for (l = 0, len = ref.length;l < len; l++) {
          part = ref[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match, regex, string;
        regex = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match = regex.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes, k2, len, part, ref;
        bytes = [];
        ref = this.parts;
        for (k2 = 0, len = ref.length;k2 < len; k2++) {
          part = ref[k2];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = function() {
          var k2, len, ref, results;
          ref = this.parts;
          results = [];
          for (k2 = 0, len = ref.length;k2 < len; k2++) {
            part = ref[k2];
            results.push(part.toString(16));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = function() {
          var k2, len, ref, results;
          ref = this.parts;
          results = [];
          for (k2 = 0, len = ref.length;k2 < len; k2++) {
            part = ref[k2];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref;
        if (cidrRange === undefined) {
          ref = other, other = ref[0], cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref = this.parts.slice(-2), high = ref[0], low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k2, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k2 = 7;k2 >= 0; i = k2 += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k2, len, ref, results;
        ref = string.split(":");
        results = [];
        for (k2 = 0, len = ref.length;k2 < len; k2++) {
          part = ref[k2];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr.IPv6.parser = function(string) {
      var addr, k2, len, match, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match = string.match(ipv6Regexes["transitional"])) {
        zoneId = match[6] || "";
        addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
          for (k2 = 0, len = octets.length;k2 < len; k2++) {
            octet = octets[k2];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      var e;
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv6.isValid = function(string) {
      var addr, e;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        e = error1;
        return false;
      }
    };
    ipaddr.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j2, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j2 = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j2 < filledOctetCount) {
        octets[j2] = 255;
        j2++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, error, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        error = error1;
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      var maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      var e;
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (error1) {
        e = error1;
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (error12) {
          e = error12;
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.fromByteArray = function(bytes) {
      var length;
      length = bytes.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(exports);
});

// node_modules/proxy-addr/index.js
var require_proxy_addr = __commonJS((exports, module) => {
  /*!
   * proxy-addr
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = proxyaddr;
  module.exports.all = alladdrs;
  module.exports.compile = compile;
  var forwarded = require_forwarded();
  var ipaddr = require_ipaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0;i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0;i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0;i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max = ip.kind() === "ipv6" ? 128 : 32;
    var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0;i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
});

// node_modules/express/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var contentType2 = require_content_type();
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var mime = require_send().mime;
  var etag = require_etag();
  var proxyaddr = require_proxy_addr();
  var qs = require_lib3();
  var querystring = __require("querystring");
  exports.etag = createETagGenerator({ weak: false });
  exports.wetag = createETagGenerator({ weak: true });
  exports.isAbsolute = function(path) {
    if (path[0] === "/")
      return true;
    if (path[1] === ":" && (path[2] === "\\" || path[2] === "/"))
      return true;
    if (path.substring(0, 2) === "\\\\")
      return true;
  };
  exports.flatten = deprecate.function(flatten, "utils.flatten: use array-flatten npm module instead");
  exports.normalizeType = function(type) {
    return ~type.indexOf("/") ? acceptParams(type) : { value: mime.lookup(type), params: {} };
  };
  exports.normalizeTypes = function(types) {
    var ret = [];
    for (var i = 0;i < types.length; ++i) {
      ret.push(exports.normalizeType(types[i]));
    }
    return ret;
  };
  exports.contentDisposition = deprecate.function(contentDisposition, "utils.contentDisposition: use content-disposition npm module instead");
  function acceptParams(str) {
    var parts = str.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {} };
    for (var i = 1;i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if (pms[0] === "q") {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "weak":
        fn = exports.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "simple":
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports.compileTrust = function(val) {
    if (typeof val === "function")
      return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(",").map(function(v2) {
        return v2.trim();
      });
    }
    return proxyaddr.compile(val || []);
  };
  exports.setCharset = function setCharset(type, charset) {
    if (!type || !charset) {
      return type;
    }
    var parsed = contentType2.parse(type);
    parsed.parameters.charset = charset;
    return contentType2.format(parsed);
  };
  function createETagGenerator(options) {
    return function generateETag(body, encoding) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding) : body;
      return etag(buf, options);
    };
  }
  function parseExtendedQueryString(str) {
    return qs.parse(str, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
});

// node_modules/express/lib/application.js
var require_application = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler = require_finalhandler();
  var Router = require_router();
  var methods = require_methods();
  var middleware = require_init();
  var query = require_query();
  var debug = require_src3()("express:application");
  var View = require_view();
  var http = __require("http");
  var compileETag = require_utils2().compileETag;
  var compileQueryParser = require_utils2().compileQueryParser;
  var compileTrust = require_utils2().compileTrust;
  var deprecate = require_depd()("express");
  var flatten = require_array_flatten();
  var merge = require_utils_merge();
  var resolve = __require("path").resolve;
  var setPrototypeOf = require_setprototypeof();
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var slice = Array.prototype.slice;
  var app = exports = module.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app.init = function init() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app.defaultConfiguration = function defaultConfiguration() {
    var env = "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug("booting in %s mode", env);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf(this.request, parent.request);
      setPrototypeOf(this.response, parent.response);
      setPrototypeOf(this.engines, parent.engines);
      setPrototypeOf(this.settings, parent.settings);
    });
    this.locals = Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View);
    this.set("views", resolve("views"));
    this.set("jsonp callback name", "callback");
    if (env === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error(`'app.router' is deprecated!
Please see the 3.x to 4.x migration guide for details on how to update your app.`);
      }
    });
  };
  app.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app.handle = function handle(req, res, callback) {
    var router = this._router;
    var done = callback || finalhandler(req, res, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router) {
      debug("no routes defined on app");
      done();
      return;
    }
    router.handle(req, res, done);
  };
  app.use = function use(fn) {
    var offset = 0;
    var path = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path = fn;
      }
    }
    var fns = flatten(slice.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router.use(path, fn2);
      }
      debug(".use app under %s", path);
      fn2.mountpath = path;
      fn2.parent = this;
      router.use(path, function mounted_app(req, res, next) {
        var orig = req.app;
        fn2.handle(req, res, function(err) {
          setPrototypeOf(req, orig.request);
          setPrototypeOf(res, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app.route = function route(path) {
    this.lazyrouter();
    return this._router.route(path);
  };
  app.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn;
    return this;
  };
  app.param = function param(name, fn) {
    this.lazyrouter();
    if (Array.isArray(name)) {
      for (var i = 0;i < name.length; i++) {
        this.param(name[i], fn);
      }
      return this;
    }
    this._router.param(name, fn);
    return this;
  };
  app.set = function set(setting, val) {
    if (arguments.length === 1) {
      var settings = this.settings;
      while (settings && settings !== Object.prototype) {
        if (hasOwnProperty.call(settings, setting)) {
          return settings[setting];
        }
        settings = Object.getPrototypeOf(settings);
      }
      return;
    }
    debug('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app.path = function path() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods.forEach(function(method) {
    app[method] = function(path) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path);
      }
      this.lazyrouter();
      var route = this._router.route(path);
      route[method].apply(route, slice.call(arguments, 1));
      return this;
    };
  });
  app.all = function all(path) {
    this.lazyrouter();
    var route = this._router.route(path);
    var args = slice.call(arguments, 1);
    for (var i = 0;i < methods.length; i++) {
      route[methods[i]].apply(route, args);
    }
    return this;
  };
  app.del = deprecate.function(app.delete, "app.del: Use app.delete instead");
  app.render = function render(name, options, callback) {
    var cache = this.cache;
    var done = callback;
    var engines = this.engines;
    var opts = options;
    var renderOptions = {};
    var view;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    merge(renderOptions, this.locals);
    if (opts._locals) {
      merge(renderOptions, opts._locals);
    }
    merge(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view = cache[name];
    }
    if (!view) {
      var View2 = this.get("view");
      view = new View2(name, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines
      });
      if (!view.path) {
        var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"';
        var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
        err.view = view;
        return done(err);
      }
      if (renderOptions.cache) {
        cache[name] = view;
      }
    }
    tryRender(view, renderOptions, done);
  };
  app.listen = function listen() {
    var server = http.createServer(this);
    return server.listen.apply(server, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test")
      console.error(err.stack || err.toString());
  }
  function tryRender(view, options, callback) {
    try {
      view.render(options, callback);
    } catch (err) {
      callback(err);
    }
  }
});

// node_modules/negotiator/lib/charset.js
var require_charset = __commonJS((exports, module) => {
  module.exports = preferredCharsets;
  module.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j2 = 0;i < accepts.length; i++) {
      var charset = parseCharset(accepts[i].trim(), i);
      if (charset) {
        accepts[j2++] = charset;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset = match[1];
    var q2 = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p = params[j2].trim().split("=");
        if (p[0] === "q") {
          q2 = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset,
      q: q2,
      i
    };
  }
  function getCharsetPriority(charset, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(charset, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts = parseAcceptCharset(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getCharsetPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b2) {
    return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  module.exports = preferredEncodings;
  module.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j2 = 0;i < accepts.length; i++) {
      var encoding = parseEncoding(accepts[i].trim(), i);
      if (encoding) {
        accepts[j2++] = encoding;
        hasIdentity = hasIdentity || specify("identity", encoding);
        minQuality = Math.min(minQuality, encoding.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts[j2++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts.length = j2;
    return accepts;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding = match[1];
    var q2 = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p = params[j2].trim().split("=");
        if (p[0] === "q") {
          q2 = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding,
      q: q2,
      i
    };
  }
  function getEncodingPriority(encoding, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(encoding, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided) {
    var accepts = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getEncodingPriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b2) {
    return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/language.js
var require_language = __commonJS((exports, module) => {
  module.exports = preferredLanguages;
  module.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts = accept.split(",");
    for (var i = 0, j2 = 0;i < accepts.length; i++) {
      var language = parseLanguage(accepts[i].trim(), i);
      if (language) {
        accepts[j2++] = language;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q2 = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j2 = 0;j2 < params.length; j2++) {
        var p = params[j2].split("=");
        if (p[0] === "q")
          q2 = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q: q2,
      i,
      full
    };
  }
  function getLanguagePriority(language, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(language, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language, spec, index) {
    var p = parseLanguage(language);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts = parseAcceptLanguage(accept === undefined ? "*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getLanguagePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b2) {
    return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
});

// node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS((exports, module) => {
  module.exports = preferredMediaTypes;
  module.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts = splitMediaTypes(accept);
    for (var i = 0, j2 = 0;i < accepts.length; i++) {
      var mediaType = parseMediaType(accepts[i].trim(), i);
      if (mediaType) {
        accepts[j2++] = mediaType;
      }
    }
    accepts.length = j2;
    return accepts;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = Object.create(null);
    var q2 = 1;
    var subtype = match[2];
    var type = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j2 = 0;j2 < kvps.length; j2++) {
        var pair = kvps[j2];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === "q") {
          q2 = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type,
      subtype,
      params,
      q: q2,
      i
    };
  }
  function getMediaTypePriority(type, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0;i < accepted.length; i++) {
      var spec = specify(type, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type, spec, index) {
    var p = parseMediaType(type);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k2) {
        return spec.params[k2] == "*" || (spec.params[k2] || "").toLowerCase() == (p.params[k2] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
    if (!provided) {
      return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type, index) {
      return getMediaTypePriority(type, accepts, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b2) {
    return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count++;
      index++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts = accept.split(",");
    for (var i = 1, j2 = 0;i < accepts.length; i++) {
      if (quoteCount(accepts[j2]) % 2 == 0) {
        accepts[++j2] = accepts[i];
      } else {
        accepts[j2] += "," + accepts[i];
      }
    }
    accepts.length = j2 + 1;
    return accepts;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j2 = 0;i < parameters.length; i++) {
      if (quoteCount(parameters[j2]) % 2 == 0) {
        parameters[++j2] = parameters[i];
      } else {
        parameters[j2] += ";" + parameters[i];
      }
    }
    parameters.length = j2 + 1;
    for (var i = 0;i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
});

// node_modules/negotiator/index.js
var require_negotiator = __commonJS((exports, module) => {
  /*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var preferredCharsets = require_charset();
  var preferredEncodings = require_encoding();
  var preferredLanguages = require_language();
  var preferredMediaTypes = require_mediaType();
  module.exports = Negotiator;
  module.exports.Negotiator = Negotiator;
  function Negotiator(request) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request);
    }
    this.request = request;
  }
  Negotiator.prototype.charset = function charset(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings(available) {
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
});

// node_modules/accepts/index.js
var require_accepts = __commonJS((exports, module) => {
  /*!
   * accepts
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Negotiator = require_negotiator();
  var mime = require_mime_types();
  module.exports = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types = types_;
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length);
      for (var i = 0;i < types.length; i++) {
        types[i] = arguments[i];
      }
    }
    if (!types || types.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types[0];
    }
    var mimes = types.map(extToMime);
    var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts[0];
    return first ? types[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings = encodings_;
    if (encodings && !Array.isArray(encodings)) {
      encodings = new Array(arguments.length);
      for (var i = 0;i < encodings.length; i++) {
        encodings[i] = arguments[i];
      }
    }
    if (!encodings || encodings.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0;i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0;i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type) {
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function validMime(type) {
    return typeof type === "string";
  }
});

// node_modules/express/lib/request.js
var require_request = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var accepts = require_accepts();
  var deprecate = require_depd()("express");
  var isIP = __require("net").isIP;
  var typeis = require_type_is();
  var http = __require("http");
  var fresh = require_fresh();
  var parseRange = require_range_parser();
  var parse = require_parseurl();
  var proxyaddr = require_proxy_addr();
  var req = Object.create(http.IncomingMessage.prototype);
  module.exports = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead");
  req.acceptsCharsets = function() {
    var accept = accepts(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead");
  req.acceptsLanguages = function() {
    var accept = accepts(this);
    return accept.languages.apply(accept, arguments);
  };
  req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead");
  req.range = function range(size, options) {
    var range = this.get("Range");
    if (!range)
      return;
    return parseRange(size, range, options);
  };
  req.param = function param(name, defaultValue) {
    var params = this.params || {};
    var body = this.body || {};
    var query = this.query || {};
    var args = arguments.length === 1 ? "name" : "name, default";
    deprecate("req.param(" + args + "): Use req.params, req.body, or req.query instead");
    if (params[name] != null && params.hasOwnProperty(name))
      return params[name];
    if (body[name] != null)
      return body[name];
    if (query[name] != null)
      return query[name];
    return defaultValue;
  };
  req.is = function is(types) {
    var arr = types;
    if (!Array.isArray(types)) {
      arr = new Array(arguments.length);
      for (var i = 0;i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname)
      return [];
    var offset = this.app.get("subdomain offset");
    var subdomains = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains.slice(offset);
  });
  defineGetter(req, "path", function path() {
    return parse(this).pathname;
  });
  defineGetter(req, "hostname", function hostname() {
    var trust = this.app.get("trust proxy fn");
    var host = this.get("X-Forwarded-Host");
    if (!host || !trust(this.connection.remoteAddress, 0)) {
      host = this.get("Host");
    } else if (host.indexOf(",") !== -1) {
      host = host.substring(0, host.indexOf(",")).trimRight();
    }
    if (!host)
      return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, "host", deprecate.function(function host() {
    return this.hostname;
  }, "req.host: Use req.hostname instead"));
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if (method !== "GET" && method !== "HEAD")
      return false;
    if (status >= 200 && status < 300 || status === 304) {
      return fresh(this.headers, {
        etag: res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS((exports) => {
  var crypto = __require("crypto");
  exports.sign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(val, secret) {
    if (typeof val != "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (typeof secret != "string")
      throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf(".")), mac = exports.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto.createHash("sha1").update(str).digest("hex");
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse;
  exports.serialize = serialize;
  var __toString = Object.prototype.toString;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  function parse(str, opt) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var len = str.length;
    if (len < 2)
      return obj;
    var dec = opt && opt.decode || decode;
    var index = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
      eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = len;
      } else if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var keyStartIdx = startIndex(str, index, eqIdx);
      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      var key = str.slice(keyStartIdx, keyEndIdx);
      if (!obj.hasOwnProperty(key)) {
        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        var valEndIdx = endIndex(str, endIdx, valStartIdx);
        if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
          valStartIdx++;
          valEndIdx--;
        }
        var val = str.slice(valStartIdx, valEndIdx);
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      var code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      var code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (!opt)
      return str;
    if (opt.maxAge != null) {
      var maxAge = Math.floor(opt.maxAge);
      if (!isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + maxAge;
    }
    if (opt.domain) {
      if (!domainValueRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!pathValueRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
});

// node_modules/vary/index.js
var require_vary = __commonJS((exports, module) => {
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse(String(field)) : field;
    for (var j2 = 0;j2 < fields.length; j2++) {
      if (!FIELD_NAME_REGEXP.test(fields[j2])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0;i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length;i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
});

// node_modules/express/lib/response.js
var require_response = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var Buffer2 = require_safe_buffer().Buffer;
  var contentDisposition = require_content_disposition();
  var createError = require_http_errors();
  var deprecate = require_depd()("express");
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var http = __require("http");
  var isAbsolute = require_utils2().isAbsolute;
  var onFinished = require_on_finished();
  var path = __require("path");
  var statuses = require_statuses();
  var merge = require_utils_merge();
  var sign = require_cookie_signature().sign;
  var normalizeType = require_utils2().normalizeType;
  var normalizeTypes = require_utils2().normalizeTypes;
  var setCharset = require_utils2().setCharset;
  var cookie = require_cookie();
  var send = require_send();
  var extname = path.extname;
  var mime = send.mime;
  var resolve = path.resolve;
  var vary = require_vary();
  var res = Object.create(http.ServerResponse.prototype);
  module.exports = res;
  var charsetRegExp = /;\s*charset\s*=/;
  res.status = function status(code) {
    if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1000) {
      deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
    }
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link = this.get("Link") || "";
    if (link)
      link += ", ";
    return this.set("Link", link + Object.keys(links).map(function(rel) {
      return "<" + links[rel] + '>; rel="' + rel + '"';
    }).join(", "));
  };
  res.send = function send(body) {
    var chunk = body;
    var encoding;
    var req = this.req;
    var type;
    var app = this.app;
    if (arguments.length === 2) {
      if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
        deprecate("res.send(body, status): Use res.status(status).send(body) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.send(status, body): Use res.status(status).send(body) instead");
        this.statusCode = arguments[0];
        chunk = arguments[1];
      }
    }
    if (typeof chunk === "number" && arguments.length === 1) {
      if (!this.get("Content-Type")) {
        this.type("txt");
      }
      deprecate("res.send(status): Use res.sendStatus(status) instead");
      this.statusCode = chunk;
      chunk = statuses.message[chunk];
    }
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer2.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding = "utf8";
      type = this.get("Content-Type");
      if (typeof type === "string") {
        this.set("Content-Type", setCharset(type, "utf-8"));
      }
    }
    var etagFn = app.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== undefined) {
      if (Buffer2.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1000) {
        len = Buffer2.byteLength(chunk, encoding);
      } else {
        chunk = Buffer2.from(chunk, encoding);
        encoding = undefined;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== undefined) {
      if (etag = etagFn(chunk, encoding)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh)
      this.statusCode = 304;
    if (this.statusCode === 204 || this.statusCode === 304) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (this.statusCode === 205) {
      this.set("Content-Length", "0");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding);
    }
    return this;
  };
  res.json = function json(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    var callback = this.req.query[app.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      if (body === undefined) {
        body = "";
      } else if (typeof body === "string") {
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses.message[statusCode] || String(statusCode);
    this.statusCode = statusCode;
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path2, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path2) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path2 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !isAbsolute(path2)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path2);
    var file = send(req, pathname, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = function(path2, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    var file = send(req, path2, opts);
    sendfile(res2, file, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead");
  res.download = function download(path2, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    if (typeof filename === "object" && (typeof options === "function" || options === undefined)) {
      name = null;
      opts = filename;
    }
    var headers = {
      "Content-Disposition": contentDisposition(name || path2)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0;i < keys.length; i++) {
        var key = keys[i];
        if (key.toLowerCase() !== "content-disposition") {
          headers[key] = opts.headers[key];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = !opts.root ? resolve(path2) : path2;
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType(type) {
    var ct = type.indexOf("/") === -1 ? mime.lookup(type) : type;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v2) {
      return v2 !== "default";
    });
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
      this.set("Content-Type", normalizeType(key).value);
      obj[key](req, this, next);
    } else if (obj.default) {
      obj.default(req, this, next);
    } else {
      next(createError(406, {
        types: normalizeTypes(keys).map(function(o) {
          return o.value;
        })
      }));
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition(filename));
    return this;
  };
  res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        if (!charsetRegExp.test(value)) {
          var charset = mime.charsets.lookup(value.split(";")[0]);
          if (charset)
            value += "; charset=" + charset.toLowerCase();
        }
      }
      this.setHeader(field, value);
    } else {
      for (var key in field) {
        this.set(key, field[key]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    if (options) {
      if (options.maxAge) {
        deprecate('res.clearCookie: Passing "options.maxAge" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
      }
      if (options.expires) {
        deprecate('res.clearCookie: Passing "options.expires" is deprecated. In v5.0.0 of Express, this option will be ignored, as res.clearCookie will automatically set cookies to expire immediately. Please update your code to omit this option.');
      }
    }
    var opts = merge({ expires: new Date(1), path: "/" }, options);
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = merge({}, options);
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign(val, secret);
    }
    if (opts.maxAge != null) {
      var maxAge = opts.maxAge - 0;
      if (!isNaN(maxAge)) {
        opts.expires = new Date(Date.now() + maxAge);
        opts.maxAge = Math.floor(maxAge / 1000);
      }
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url) {
    var loc;
    if (url === "back") {
      deprecate('res.location("back"): use res.location(req.get("Referrer") || "/") and refer to https://dub.sh/security-redirect for best practices');
      loc = this.req.get("Referrer") || "/";
    } else {
      loc = String(url);
    }
    return this.set("Location", encodeUrl(loc));
  };
  res.redirect = function redirect(url) {
    var address = url;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        status = arguments[0];
        address = arguments[1];
      } else {
        deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
        status = arguments[1];
      }
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses.message[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses.message[status] + ". Redirecting to " + u + "</p>";
      },
      default: function() {
        body = "";
      }
    });
    this.statusCode = status;
    this.set("Content-Length", Buffer2.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    if (!field || Array.isArray(field) && !field.length) {
      deprecate("res.vary(): Provide a field name");
      return this;
    }
    vary(this, field);
    return this;
  };
  res.render = function render(view, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self.locals;
    done = done || function(err, str) {
      if (err)
        return req.next(err);
      self.send(str);
    };
    app.render(view, opts, done);
  };
  function sendfile(res2, file, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done)
        return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done)
        return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done)
        return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done)
        return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET")
        return onaborted();
      if (err)
        return onerror(err);
      if (done)
        return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done)
          return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file.on("directory", ondirectory);
    file.on("end", onend);
    file.on("error", onerror);
    file.on("file", onfile);
    file.on("stream", onstream);
    onFinished(res2, onfinish);
    if (options.headers) {
      file.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0;i < keys.length; i++) {
          var k2 = keys[i];
          res3.setHeader(k2, obj[k2]);
        }
      });
    }
    file.pipe(res2);
  }
  function stringify(value, replacer, spaces, escape2) {
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2 && typeof json === "string") {
      json = json.replace(/[<>&]/g, function(c) {
        switch (c.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return c;
        }
      });
    }
    return json;
  }
});

// node_modules/serve-static/index.js
var require_serve_static = __commonJS((exports, module) => {
  /*!
   * serve-static
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var encodeUrl = require_encodeurl();
  var escapeHtml = require_escape_html();
  var parseUrl = require_parseurl();
  var resolve = __require("path").resolve;
  var send = require_send();
  var url = __require("url");
  module.exports = serveStatic;
  module.exports.mime = send.mime;
  function serveStatic(root, options) {
    if (!root) {
      throw new TypeError("root path required");
    }
    if (typeof root !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve(root);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path = parseUrl(req).pathname;
      if (path === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path = "";
      }
      var stream = send(req, path, opts);
      stream.on("directory", onDirectory);
      if (setHeaders) {
        stream.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream.on("error", function error(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0;i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return `<!DOCTYPE html>
` + `<html lang="en">
` + `<head>
` + `<meta charset="utf-8">
` + "<title>" + title + `</title>
` + `</head>
` + `<body>
` + "<pre>" + body + `</pre>
` + `</body>
` + `</html>
`;
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
});

// node_modules/express/lib/express.js
var require_express = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var bodyParser = require_body_parser();
  var EventEmitter = __require("events").EventEmitter;
  var mixin = require_merge_descriptors();
  var proto = require_application();
  var Route = require_route();
  var Router = require_router();
  var req = require_request();
  var res = require_response();
  exports = module.exports = createApplication;
  function createApplication() {
    var app = function(req2, res2, next) {
      app.handle(req2, res2, next);
    };
    mixin(app, EventEmitter.prototype, false);
    mixin(app, proto, false);
    app.request = Object.create(req, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.response = Object.create(res, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.init();
    return app;
  }
  exports.application = proto;
  exports.request = req;
  exports.response = res;
  exports.Route = Route;
  exports.Router = Router;
  exports.json = bodyParser.json;
  exports.query = require_query();
  exports.raw = bodyParser.raw;
  exports.static = require_serve_static();
  exports.text = bodyParser.text;
  exports.urlencoded = bodyParser.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name) {
    Object.defineProperty(exports, name, {
      get: function() {
        throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
});

// node_modules/express/index.js
var require_express2 = __commonJS((exports, module) => {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_express();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
class Protocol {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = new Map;
    this._requestHandlerAbortControllers = new Map;
    this._notificationHandlers = new Map;
    this._responseHandlers = new Map;
    this._progressHandlers = new Map;
    this._timeoutInfo = new Map;
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
      controller === null || controller === undefined || controller.abort(notification.params.reason);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(PingRequestSchema, (_request) => ({}));
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  async connect(transport) {
    this._transport = transport;
    this._transport.onclose = () => {
      this._onclose();
    };
    this._transport.onerror = (error) => {
      this._onerror(error);
    };
    this._transport.onmessage = (message) => {
      if (!("method" in message)) {
        this._onresponse(message);
      } else if ("id" in message) {
        this._onrequest(message);
      } else {
        this._onnotification(message);
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = new Map;
    this._progressHandlers.clear();
    this._transport = undefined;
    (_a = this.onclose) === null || _a === undefined || _a.call(this);
    const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    var _a;
    (_a = this.onerror) === null || _a === undefined || _a.call(this, error);
  }
  _onnotification(notification) {
    var _a;
    const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== undefined ? _a : this.fallbackNotificationHandler;
    if (handler === undefined) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request) {
    var _a, _b, _c;
    const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== undefined ? _a : this.fallbackRequestHandler;
    if (handler === undefined) {
      (_b = this._transport) === null || _b === undefined || _b.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      return;
    }
    const abortController = new AbortController;
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const extra = {
      signal: abortController.signal,
      sessionId: (_c = this._transport) === null || _c === undefined ? undefined : _c.sessionId
    };
    Promise.resolve().then(() => handler(request, extra)).then((result) => {
      var _a2;
      if (abortController.signal.aborted) {
        return;
      }
      return (_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.send({
        result,
        jsonrpc: "2.0",
        id: request.id
      });
    }, (error) => {
      var _a2, _b2;
      if (abortController.signal.aborted) {
        return;
      }
      return (_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: (_b2 = error.message) !== null && _b2 !== undefined ? _b2 : "Internal error"
        }
      });
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const handler = this._responseHandlers.get(messageId);
    if (handler === undefined) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._progressHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    if ("result" in response) {
      handler(response);
    } else {
      const error = new McpError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  async close() {
    var _a;
    await ((_a = this._transport) === null || _a === undefined ? undefined : _a.close());
  }
  request(request, resultSchema, options) {
    return new Promise((resolve, reject) => {
      var _a, _b, _c, _d, _e;
      if (!this._transport) {
        reject(new Error("Not connected"));
        return;
      }
      if (((_a = this._options) === null || _a === undefined ? undefined : _a.enforceStrictCapabilities) === true) {
        this.assertCapabilityForMethod(request.method);
      }
      (_b = options === null || options === undefined ? undefined : options.signal) === null || _b === undefined || _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options === null || options === undefined ? undefined : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: { progressToken: messageId }
        };
      }
      const cancel = (reason) => {
        var _a2;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a2 = this._transport) === null || _a2 === undefined || _a2.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
        reject(reason);
      };
      this._responseHandlers.set(messageId, (response) => {
        var _a2;
        if ((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const result = resultSchema.parse(response.result);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      (_c = options === null || options === undefined ? undefined : options.signal) === null || _c === undefined || _c.addEventListener("abort", () => {
        var _a2;
        cancel((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.reason);
      });
      const timeout = (_d = options === null || options === undefined ? undefined : options.timeout) !== null && _d !== undefined ? _d : DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options === null || options === undefined ? undefined : options.maxTotalTimeout, timeoutHandler, (_e = options === null || options === undefined ? undefined : options.resetTimeoutOnProgress) !== null && _e !== undefined ? _e : false);
      this._transport.send(jsonrpcRequest).catch((error) => {
        this._cleanupTimeout(messageId);
        reject(error);
      });
    });
  }
  async notification(notification) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    await this._transport.send(jsonrpcNotification);
  }
  setRequestHandler(requestSchema, handler) {
    const method = requestSchema.shape.method.value;
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => Promise.resolve(handler(requestSchema.parse(request), extra)));
  }
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  setNotificationHandler(notificationSchema, handler) {
    this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
  }
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
}
function mergeCapabilities(base, additional) {
  return Object.entries(additional).reduce((acc, [key, value]) => {
    if (value && typeof value === "object") {
      acc[key] = acc[key] ? { ...acc[key], ...value } : value;
    } else {
      acc[key] = value;
    }
    return acc;
  }, { ...base });
}
var DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
var init_protocol = __esm(() => {
  init_types();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server;
var init_server = __esm(() => {
  init_protocol();
  init_types();
  Server = class Server extends Protocol {
    constructor(_serverInfo, options) {
      var _a;
      super(options);
      this._serverInfo = _serverInfo;
      this._capabilities = (_a = options === null || options === undefined ? undefined : options.capabilities) !== null && _a !== undefined ? _a : {};
      this._instructions = options === null || options === undefined ? undefined : options.instructions;
      this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
      this.setNotificationHandler(InitializedNotificationSchema, () => {
        var _a2;
        return (_a2 = this.oninitialized) === null || _a2 === undefined ? undefined : _a2.call(this);
      });
    }
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    assertCapabilityForMethod(method) {
      var _a, _b;
      switch (method) {
        case "sampling/createMessage":
          if (!((_a = this._clientCapabilities) === null || _a === undefined ? undefined : _a.sampling)) {
            throw new Error(`Client does not support sampling (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!((_b = this._clientCapabilities) === null || _b === undefined ? undefined : _b.roots)) {
            throw new Error(`Client does not support listing roots (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      switch (method) {
        case "notifications/message":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "notifications/resources/updated":
        case "notifications/resources/list_changed":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support notifying about resources (required for ${method})`);
          }
          break;
        case "notifications/tools/list_changed":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
          }
          break;
        case "notifications/prompts/list_changed":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
          }
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      switch (method) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) {
            throw new Error(`Server does not support sampling (required for ${method})`);
          }
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "ping":
        case "initialize":
          break;
      }
    }
    async _oninitialize(request) {
      const requestedVersion = request.params.protocolVersion;
      this._clientCapabilities = request.params.capabilities;
      this._clientVersion = request.params.clientInfo;
      return {
        protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
        capabilities: this.getCapabilities(),
        serverInfo: this._serverInfo,
        ...this._instructions && { instructions: this._instructions }
      };
    }
    getClientCapabilities() {
      return this._clientCapabilities;
    }
    getClientVersion() {
      return this._clientVersion;
    }
    getCapabilities() {
      return this._capabilities;
    }
    async ping() {
      return this.request({ method: "ping" }, EmptyResultSchema);
    }
    async createMessage(params, options) {
      return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
    }
    async listRoots(params, options) {
      return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
    }
    async sendLoggingMessage(params) {
      return this.notification({ method: "notifications/message", params });
    }
    async sendResourceUpdated(params) {
      return this.notification({
        method: "notifications/resources/updated",
        params
      });
    }
    async sendResourceListChanged() {
      return this.notification({
        method: "notifications/resources/list_changed"
      });
    }
    async sendToolListChanged() {
      return this.notification({ method: "notifications/tools/list_changed" });
    }
    async sendPromptListChanged() {
      return this.notification({ method: "notifications/prompts/list_changed" });
    }
  };
});

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride, defaultOptions, getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};
var init_Options = __esm(() => {
  ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
  defaultOptions = {
    name: undefined,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
});

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        jsonSchema: undefined
      }
    ]))
  };
};
var init_Refs = __esm(() => {
  init_Options();
});

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
var init_array = __esm(() => {
  init_lib();
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
var init_bigint = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var init_branded = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var init_catch = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        break;
      case "max":
        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        break;
    }
  }
  return res;
};
var init_date = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
var init_default = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
var init_effects = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x2) => !!x2);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === undefined) {
        unevaluatedProperties = undefined;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = undefined;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : undefined;
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
var init_intersection = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_2) => {})(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x2) => x2.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x2) => x2.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}
var emojiRegex2 = undefined, zodPatterns, ALPHA_NUMERIC;
var init_string = __esm(() => {
  zodPatterns = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => {
      if (emojiRegex2 === undefined) {
        emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex2;
    },
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  };
  ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
});

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
var init_record = __esm(() => {
  init_lib();
  init_parseDef();
  init_string();
  init_branded();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
var init_map = __esm(() => {
  init_parseDef();
  init_record();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x2) => (x2._def.typeName in primitiveMappings) && (!x2._def.checks || !x2._def.checks.length))) {
    const types = options.reduce((types2, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types = options.reduce((acc, x2) => {
      const type = typeof x2._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x2._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x2, i, a) => a.indexOf(x2) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x2) => {
          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
        }, [])
      };
    }
  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x2) => [
        ...acc,
        ...x2._def.values.filter((x3) => !acc.includes(x3))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var primitiveMappings, asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i) => parseDef(x2._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};
var init_union = __esm(() => {
  init_parseDef();
  primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
});

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
var init_nullable = __esm(() => {
  init_parseDef();
  init_union();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
var init_number = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === undefined || propDef._def === undefined) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef instanceof ZodOptional) {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === undefined) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== undefined) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var init_object = __esm(() => {
  init_lib();
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};
var init_optional = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b2 = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b2].filter((x2) => x2 !== undefined)
  };
};
var init_pipeline = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
var init_promise = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
var init_set = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x2, i) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x2) => x2 === undefined ? acc : [...acc, x2], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x2, i) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x2) => x2 === undefined ? acc : [...acc, x2], [])
    };
  }
}
var init_tuple = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var init_readonly = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return;
    default:
      return ((_2) => {
        return;
      })(typeName);
  }
};
var init_selectParser = __esm(() => {
  init_lib();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_union();
  init_readonly();
});

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : undefined;
    }
  }
}, getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
var init_parseDef = __esm(() => {
  init_Options();
  init_selectParser();
});

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
var init_parseTypes = () => {};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? {}
  }), {}) : undefined;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? undefined : options?.name;
  const main = parseDef(schema._def, name === undefined ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  const combined = name === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && (("anyOf" in combined) || ("oneOf" in combined) || ("allOf" in combined) || ("type" in combined) && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};
var init_zodToJsonSchema = __esm(() => {
  init_parseDef();
  init_Refs();
});

// node_modules/zod-to-json-schema/dist/esm/index.js
var init_esm = __esm(() => {
  init_Options();
  init_Refs();
  init_parseDef();
  init_parseTypes();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_readonly();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_union();
  init_selectParser();
  init_zodToJsonSchema();
  init_zodToJsonSchema();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js
function processCreateParams2(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var McpZodTypeKind, Completable;
var init_completable = __esm(() => {
  init_lib();
  (function(McpZodTypeKind2) {
    McpZodTypeKind2["Completable"] = "McpCompletable";
  })(McpZodTypeKind || (McpZodTypeKind = {}));
  Completable = class Completable extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  Completable.create = (type, params) => {
    return new Completable({
      type,
      typeName: McpZodTypeKind.Completable,
      complete: params.complete,
      ...processCreateParams2(params)
    });
  };
});
// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
class McpServer {
  constructor(serverInfo, options) {
    this._registeredResources = {};
    this._registeredResourceTemplates = {};
    this._registeredTools = {};
    this._registeredPrompts = {};
    this._toolHandlersInitialized = false;
    this._completionHandlerInitialized = false;
    this._resourceHandlersInitialized = false;
    this._promptHandlersInitialized = false;
    this.server = new Server(serverInfo, options);
  }
  async connect(transport) {
    return await this.server.connect(transport);
  }
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    if (this._toolHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      tools: {}
    });
    this.server.setRequestHandler(ListToolsRequestSchema, () => ({
      tools: Object.entries(this._registeredTools).map(([name, tool]) => {
        return {
          name,
          description: tool.description,
          inputSchema: tool.inputSchema ? zodToJsonSchema(tool.inputSchema, {
            strictUnions: true
          }) : EMPTY_OBJECT_JSON_SCHEMA
        };
      })
    }));
    this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
      const tool = this._registeredTools[request.params.name];
      if (!tool) {
        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);
      }
      if (tool.inputSchema) {
        const parseResult = await tool.inputSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = tool.callback;
        try {
          return await Promise.resolve(cb(args, extra));
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: error instanceof Error ? error.message : String(error)
              }
            ],
            isError: true
          };
        }
      } else {
        const cb = tool.callback;
        try {
          return await Promise.resolve(cb(extra));
        } catch (error) {
          return {
            content: [
              {
                type: "text",
                text: error instanceof Error ? error.message : String(error)
              }
            ],
            isError: true
          };
        }
      }
    });
    this._toolHandlersInitialized = true;
  }
  setCompletionRequestHandler() {
    if (this._completionHandlerInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);
    this.server.setRequestHandler(CompleteRequestSchema, async (request) => {
      switch (request.params.ref.type) {
        case "ref/prompt":
          return this.handlePromptCompletion(request, request.params.ref);
        case "ref/resource":
          return this.handleResourceCompletion(request, request.params.ref);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);
      }
    });
    this._completionHandlerInitialized = true;
  }
  async handlePromptCompletion(request, ref) {
    const prompt = this._registeredPrompts[ref.name];
    if (!prompt) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.ref.name} not found`);
    }
    if (!prompt.argsSchema) {
      return EMPTY_COMPLETION_RESULT;
    }
    const field = prompt.argsSchema.shape[request.params.argument.name];
    if (!(field instanceof Completable)) {
      return EMPTY_COMPLETION_RESULT;
    }
    const def = field._def;
    const suggestions = await def.complete(request.params.argument.value);
    return createCompletionResult(suggestions);
  }
  async handleResourceCompletion(request, ref) {
    const template = Object.values(this._registeredResourceTemplates).find((t) => t.resourceTemplate.uriTemplate.toString() === ref.uri);
    if (!template) {
      if (this._registeredResources[ref.uri]) {
        return EMPTY_COMPLETION_RESULT;
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);
    }
    const completer = template.resourceTemplate.completeCallback(request.params.argument.name);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request.params.argument.value);
    return createCompletionResult(suggestions);
  }
  setResourceRequestHandlers() {
    if (this._resourceHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      resources: {}
    });
    this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {
      const resources = Object.entries(this._registeredResources).map(([uri, resource]) => ({
        uri,
        name: resource.name,
        ...resource.metadata
      }));
      const templateResources = [];
      for (const template of Object.values(this._registeredResourceTemplates)) {
        if (!template.resourceTemplate.listCallback) {
          continue;
        }
        const result = await template.resourceTemplate.listCallback(extra);
        for (const resource of result.resources) {
          templateResources.push({
            ...resource,
            ...template.metadata
          });
        }
      }
      return { resources: [...resources, ...templateResources] };
    });
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({
        name,
        uriTemplate: template.resourceTemplate.uriTemplate.toString(),
        ...template.metadata
      }));
      return { resourceTemplates };
    });
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
      const uri = new URL(request.params.uri);
      const resource = this._registeredResources[uri.toString()];
      if (resource) {
        return resource.readCallback(uri, extra);
      }
      for (const template of Object.values(this._registeredResourceTemplates)) {
        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
        if (variables) {
          return template.readCallback(uri, variables, extra);
        }
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
    });
    this.setCompletionRequestHandler();
    this._resourceHandlersInitialized = true;
  }
  setPromptRequestHandlers() {
    if (this._promptHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);
    this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);
    this.server.registerCapabilities({
      prompts: {}
    });
    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
      prompts: Object.entries(this._registeredPrompts).map(([name, prompt]) => {
        return {
          name,
          description: prompt.description,
          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : undefined
        };
      })
    }));
    this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
      const prompt = this._registeredPrompts[request.params.name];
      if (!prompt) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);
      }
      if (prompt.argsSchema) {
        const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`);
        }
        const args = parseResult.data;
        const cb = prompt.callback;
        return await Promise.resolve(cb(args, extra));
      } else {
        const cb = prompt.callback;
        return await Promise.resolve(cb(extra));
      }
    });
    this.setCompletionRequestHandler();
    this._promptHandlersInitialized = true;
  }
  resource(name, uriOrTemplate, ...rest) {
    let metadata;
    if (typeof rest[0] === "object") {
      metadata = rest.shift();
    }
    const readCallback = rest[0];
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      this._registeredResources[uriOrTemplate] = {
        name,
        metadata,
        readCallback
      };
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      this._registeredResourceTemplates[name] = {
        resourceTemplate: uriOrTemplate,
        metadata,
        readCallback
      };
    }
    this.setResourceRequestHandlers();
  }
  tool(name, ...rest) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let paramsSchema;
    if (rest.length > 1) {
      paramsSchema = rest.shift();
    }
    const cb = rest[0];
    this._registeredTools[name] = {
      description,
      inputSchema: paramsSchema === undefined ? undefined : z2.object(paramsSchema),
      callback: cb
    };
    this.setToolRequestHandlers();
  }
  prompt(name, ...rest) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let argsSchema;
    if (rest.length > 1) {
      argsSchema = rest.shift();
    }
    const cb = rest[0];
    this._registeredPrompts[name] = {
      description,
      argsSchema: argsSchema === undefined ? undefined : z2.object(argsSchema),
      callback: cb
    };
    this.setPromptRequestHandlers();
  }
}
function promptArgumentsFromSchema(schema) {
  return Object.entries(schema.shape).map(([name, field]) => ({
    name,
    description: field.description,
    required: !field.isOptional()
  }));
}
function createCompletionResult(suggestions) {
  return {
    completion: {
      values: suggestions.slice(0, 100),
      total: suggestions.length,
      hasMore: suggestions.length > 100
    }
  };
}
var EMPTY_OBJECT_JSON_SCHEMA, EMPTY_COMPLETION_RESULT;
var init_mcp = __esm(() => {
  init_server();
  init_esm();
  init_lib();
  init_types();
  init_completable();
  EMPTY_OBJECT_JSON_SCHEMA = {
    type: "object"
  };
  EMPTY_COMPLETION_RESULT = {
    completion: {
      values: [],
      hasMore: false
    }
  };
});

// src/hooks/registration.ts
function initHooks(hooks) {}

// src/hooks/hooks.ts
class SDKHooks {
  sdkInitHooks = [];
  beforeCreateRequestHooks = [];
  beforeRequestHooks = [];
  afterSuccessHooks = [];
  afterErrorHooks = [];
  constructor() {
    const presetHooks = [];
    for (const hook of presetHooks) {
      if ("sdkInit" in hook) {
        this.registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        this.registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        this.registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        this.registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        this.registerAfterErrorHook(hook);
      }
    }
    initHooks(this);
  }
  registerSDKInitHook(hook) {
    this.sdkInitHooks.push(hook);
  }
  registerBeforeCreateRequestHook(hook) {
    this.beforeCreateRequestHooks.push(hook);
  }
  registerBeforeRequestHook(hook) {
    this.beforeRequestHooks.push(hook);
  }
  registerAfterSuccessHook(hook) {
    this.afterSuccessHooks.push(hook);
  }
  registerAfterErrorHook(hook) {
    this.afterErrorHooks.push(hook);
  }
  sdkInit(opts) {
    return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
  }
  beforeCreateRequest(hookCtx, input) {
    let inp = input;
    for (const hook of this.beforeCreateRequestHooks) {
      inp = hook.beforeCreateRequest(hookCtx, inp);
    }
    return inp;
  }
  async beforeRequest(hookCtx, request) {
    let req = request;
    for (const hook of this.beforeRequestHooks) {
      req = await hook.beforeRequest(hookCtx, req);
    }
    return req;
  }
  async afterSuccess(hookCtx, response) {
    let res = response;
    for (const hook of this.afterSuccessHooks) {
      res = await hook.afterSuccess(hookCtx, res);
    }
    return res;
  }
  async afterError(hookCtx, response, error) {
    let res = response;
    let err = error;
    for (const hook of this.afterErrorHooks) {
      const result = await hook.afterError(hookCtx, res, err);
      res = result.response;
      err = result.error;
    }
    return { response: res, error: err };
  }
}
var init_hooks = () => {};

// src/models/errors/httpclienterrors.ts
var HTTPClientError, UnexpectedClientError, InvalidRequestError, RequestAbortedError, RequestTimeoutError, ConnectionError;
var init_httpclienterrors = __esm(() => {
  HTTPClientError = class HTTPClientError extends Error {
    cause;
    name = "HTTPClientError";
    constructor(message, opts) {
      let msg = message;
      if (opts?.cause) {
        msg += `: ${opts.cause}`;
      }
      super(msg, opts);
      if (typeof this.cause === "undefined") {
        this.cause = opts?.cause;
      }
    }
  };
  UnexpectedClientError = class UnexpectedClientError extends HTTPClientError {
    name = "UnexpectedClientError";
  };
  InvalidRequestError = class InvalidRequestError extends HTTPClientError {
    name = "InvalidRequestError";
  };
  RequestAbortedError = class RequestAbortedError extends HTTPClientError {
    name = "RequestAbortedError";
  };
  RequestTimeoutError = class RequestTimeoutError extends HTTPClientError {
    name = "RequestTimeoutError";
  };
  ConnectionError = class ConnectionError extends HTTPClientError {
    name = "ConnectionError";
  };
});

// src/types/fp.ts
function OK2(value) {
  return { ok: true, value };
}
function ERR(error) {
  return { ok: false, error };
}

// src/lib/base64.ts
function bytesToBase64(u8arr) {
  return btoa(String.fromCodePoint(...u8arr));
}
function bytesFromBase64(encoded) {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}
function stringToBytes(str) {
  return new TextEncoder().encode(str);
}
function stringToBase64(str) {
  return bytesToBase64(stringToBytes(str));
}
var zodOutbound, zodInbound;
var init_base64 = __esm(() => {
  init_lib();
  zodOutbound = instanceOfType(Uint8Array).or(stringType().transform(stringToBytes));
  zodInbound = instanceOfType(Uint8Array).or(stringType().transform(bytesFromBase64));
});

// src/lib/url.ts
function pathToFunc(pathPattern, options) {
  const paramRE = /\{([a-zA-Z0-9_]+?)\}/g;
  return function buildURLPath(params = {}) {
    return pathPattern.replace(paramRE, function(_2, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }
      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Parameter '${placeholder}' must be a string or number`);
      }
      return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
    });
  };
}
var hasOwn;
var init_url = __esm(() => {
  hasOwn = Object.prototype.hasOwnProperty;
});

// src/lib/config.ts
function serverURLFromOptions(options) {
  let serverURL = options.serverURL;
  const params = {};
  if (!serverURL) {
    const serverIdx = options.serverIdx ?? 0;
    if (serverIdx < 0 || serverIdx >= ServerList.length) {
      throw new Error(`Invalid server index ${serverIdx}`);
    }
    serverURL = ServerList[serverIdx] || "";
  }
  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}
var ServerList, SDK_METADATA;
var init_config = __esm(() => {
  init_url();
  ServerList = [
    "https://api.servicem8.com/api_1.0"
  ];
  SDK_METADATA = {
    language: "typescript",
    openapiDocVersion: "1.0.0",
    sdkVersion: "0.3.8",
    genVersion: "2.593.4",
    userAgent: "speakeasy-sdk/typescript 0.3.8 2.593.4 1.0.0 servicem8"
  };
});

// src/lib/is-plain-object.ts
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// src/lib/encodings.ts
function formEncoder(sep) {
  return (key, value, options) => {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [[key, value]];
    if (pairs.every(([_2, v2]) => v2 == null)) {
      return;
    }
    const encodeString = (v2) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
    };
    const encodeValue = (v2) => encodeString(serializeValue(v2));
    const encodedSep = encodeString(sep);
    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      let encValue = null;
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(encodedSep);
      } else if (isPlainObject(pv)) {
        encValue = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
          return `${encodeString(k2)}${encodedSep}${encodeValue(v2)}`;
        })?.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }
      if (encValue == null) {
        return;
      }
      tmp = `${encodeString(pk)}=${encValue}`;
      if (!tmp || tmp === "=") {
        return;
      }
      out += `&${tmp}`;
    });
    return out.slice(1);
  };
}
function encodeDeepObject(key, value, options) {
  if (value == null) {
    return;
  }
  if (!isPlainObject(value)) {
    throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
  }
  return encodeDeepObjectObject(key, value, options);
}
function encodeDeepObjectObject(key, value, options) {
  if (value == null) {
    return;
  }
  let out = "";
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  if (!isPlainObject(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }
  Object.entries(value).forEach(([ck, cv]) => {
    if (cv == null) {
      return;
    }
    const pk = `${key}[${ck}]`;
    if (isPlainObject(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);
      out += objOut == null ? "" : `&${objOut}`;
      return;
    }
    const pairs = Array.isArray(cv) ? cv : [cv];
    const encoded = mapDefined(pairs, (v2) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v2))}`;
    })?.join("&");
    out += encoded == null ? "" : `&${encoded}`;
  });
  return out.slice(1);
}
function encodeJSON(key, value, options) {
  if (typeof value === "undefined") {
    return;
  }
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  const encVal = encodeString(JSON.stringify(value, jsonReplacer));
  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}
function explode(key, value) {
  if (Array.isArray(value)) {
    return value.map((v2) => [key, v2]);
  } else if (isPlainObject(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k2, v2]) => [k2, v2]);
  } else {
    return [[key, value]];
  }
}
function serializeValue(value) {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }
  return `${value}`;
}
function jsonReplacer(_2, value) {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}
function mapDefined(inp, mapper) {
  const res = inp.reduce((acc, v2) => {
    if (v2 == null) {
      return acc;
    }
    const m = mapper(v2);
    if (m == null) {
      return acc;
    }
    acc.push(m);
    return acc;
  }, []);
  return res.length ? res : null;
}
function mapDefinedEntries(inp, mapper) {
  const acc = [];
  for (const [k2, v2] of inp) {
    if (v2 == null) {
      continue;
    }
    const m = mapper([k2, v2]);
    if (m == null) {
      continue;
    }
    acc.push(m);
  }
  return acc.length ? acc : null;
}
function queryJoin(...args) {
  return args.filter(Boolean).join("&");
}
function queryEncoder(f) {
  const bulkEncode = function(values, options) {
    const opts = {
      ...options,
      explode: options?.explode ?? true,
      charEncoding: options?.charEncoding ?? "percent"
    };
    const encoded = Object.entries(values).map(([key, value]) => {
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };
  return bulkEncode;
}
var EncodingError, encodeForm, encodeSpaceDelimited, encodePipeDelimited, encodeSimple = (key, value, options) => {
  let out = "";
  const pairs = options?.explode ? explode(key, value) : [[key, value]];
  if (pairs.every(([_2, v2]) => v2 == null)) {
    return;
  }
  const encodeString = (v2) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v2) : v2;
  };
  const encodeValue = (v2) => encodeString(serializeValue(v2));
  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      tmp = mapDefined(pv, (v2) => `${encodeValue(v2)}`)?.join(",");
    } else if (isPlainObject(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k2, v2]) => {
        return `,${encodeString(k2)},${encodeValue(v2)}`;
      });
      tmp = mapped?.join("").slice(1);
    } else {
      const k2 = options?.explode && isPlainObject(value) ? `${pk}=` : "";
      tmp = `${k2}${encodeValue(pv)}`;
    }
    out += tmp ? `,${tmp}` : "";
  });
  return out.slice(1);
}, encodeJSONQuery, encodeFormQuery, encodeSpaceDelimitedQuery, encodePipeDelimitedQuery, encodeDeepObjectQuery;
var init_encodings = __esm(() => {
  init_base64();
  EncodingError = class EncodingError extends Error {
    constructor(message) {
      super(message);
      this.name = "EncodingError";
    }
  };
  encodeForm = formEncoder(",");
  encodeSpaceDelimited = formEncoder(" ");
  encodePipeDelimited = formEncoder("|");
  encodeJSONQuery = queryEncoder(encodeJSON);
  encodeFormQuery = queryEncoder(encodeForm);
  encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
  encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
  encodeDeepObjectQuery = queryEncoder(encodeDeepObject);
});

// src/lib/dlv.ts
function dlv(obj, key, def, p, undef) {
  key = Array.isArray(key) ? key : key.split(".");
  for (p = 0;p < key.length; p++) {
    const k2 = key[p];
    obj = k2 != null && obj ? obj[k2] : undef;
  }
  return obj === undef ? def : obj;
}

// src/lib/env.ts
function env() {
  if (envMemo) {
    return envMemo;
  }
  envMemo = envSchema.parse(dlv(globalThis, "process.env") ?? dlv(globalThis, "Deno.env") ?? {});
  return envMemo;
}
var envSchema, envMemo = undefined;
var init_env = __esm(() => {
  init_lib();
  envSchema = objectType({
    SERVICEM8_OAUTH2: stringType().optional(),
    SERVICEM8_API_KEY_AUTH: stringType().optional(),
    SERVICEM8_DEBUG: coerce.boolean().optional()
  });
});

// src/lib/http.ts
class HTTPClient {
  options;
  fetcher;
  requestHooks = [];
  requestErrorHooks = [];
  responseHooks = [];
  constructor(options = {}) {
    this.options = options;
    this.fetcher = options.fetcher || DEFAULT_FETCHER;
  }
  async request(request) {
    let req = request;
    for (const hook of this.requestHooks) {
      const nextRequest = await hook(req);
      if (nextRequest) {
        req = nextRequest;
      }
    }
    try {
      const res = await this.fetcher(req);
      for (const hook of this.responseHooks) {
        await hook(res, req);
      }
      return res;
    } catch (err) {
      for (const hook of this.requestErrorHooks) {
        await hook(err, req);
      }
      throw err;
    }
  }
  addHook(...args) {
    if (args[0] === "beforeRequest") {
      this.requestHooks.push(args[1]);
    } else if (args[0] === "requestError") {
      this.requestErrorHooks.push(args[1]);
    } else if (args[0] === "response") {
      this.responseHooks.push(args[1]);
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    return this;
  }
  removeHook(...args) {
    let target;
    if (args[0] === "beforeRequest") {
      target = this.requestHooks;
    } else if (args[0] === "requestError") {
      target = this.requestErrorHooks;
    } else if (args[0] === "response") {
      target = this.responseHooks;
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    const index = target.findIndex((v2) => v2 === args[1]);
    if (index >= 0) {
      target.splice(index, 1);
    }
    return this;
  }
  clone() {
    const child = new HTTPClient(this.options);
    child.requestHooks = this.requestHooks.slice();
    child.requestErrorHooks = this.requestErrorHooks.slice();
    child.responseHooks = this.responseHooks.slice();
    return child;
  }
}
function matchContentType(response, pattern) {
  if (pattern === "*") {
    return true;
  }
  let contentType2 = response.headers.get("content-type")?.trim() || "application/octet-stream";
  contentType2 = contentType2.toLowerCase();
  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;
  if (wantType.split("/").length !== 2) {
    return false;
  }
  const gotParts = contentType2.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;
  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }
  if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
    return false;
  }
  if (gotParams.length < wantParams.length) {
    return false;
  }
  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }
  return true;
}
function matchStatusCode(response, codes) {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }
  return expectedCodes.some((ec) => {
    const code = `${ec}`;
    if (code === "default") {
      return true;
    }
    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
function matchResponse(response, code, contentTypePattern) {
  return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
}
function isConnectionError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
  const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
  const isBunErr = "name" in err && err.name === "ConnectionError";
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}
function isTimeoutError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
function isAbortError(err) {
  if (typeof err !== "object" || err == null) {
    return false;
  }
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;
  const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
  return isNative || isLegacyNative || isGenericErr;
}
var DEFAULT_FETCHER = (input, init) => {
  if (init == null) {
    return fetch(input);
  } else {
    return fetch(input, init);
  }
}, mediaParamSeparator, codeRangeRE;
var init_http = __esm(() => {
  mediaParamSeparator = /\s*;\s*/g;
  codeRangeRE = new RegExp("^[0-9]xx$", "i");
});

// src/lib/retries.ts
async function retry(fetchFn, options) {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(wrapFetcher(fetchFn, {
        statusCodes: options.statusCodes,
        retryConnectionErrors: !!options.config.retryConnectionErrors
      }), options.config.backoff ?? defaultBackoff);
    default:
      return await fetchFn();
  }
}
function wrapFetcher(fn, options) {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError("Response failed with retryable status code", res);
      }
      return res;
    } catch (err) {
      if (err instanceof TemporaryError) {
        throw err;
      }
      if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
        throw err;
      }
      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}
function isRetryableResponse(res, statusCodes) {
  const actual = `${res.status}`;
  return statusCodes.some((code) => {
    if (!codeRangeRE2.test(code)) {
      return code === actual;
    }
    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }
    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }
    return actualFamily === expectFamily;
  });
}
async function retryBackoff(fn, strategy) {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
  const start = Date.now();
  let x2 = 0;
  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }
        throw err;
      }
      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }
      if (retryInterval <= 0) {
        retryInterval = initialInterval * Math.pow(x2, exponent) + Math.random() * 1000;
      }
      const d = Math.min(retryInterval, maxInterval);
      await delay(d);
      x2++;
    }
  }
}
function retryIntervalFromResponse(res) {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }
  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1000;
  }
  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }
  return 0;
}
async function delay(delay2) {
  return new Promise((resolve) => setTimeout(resolve, delay2));
}
var defaultBackoff, PermanentError, TemporaryError, codeRangeRE2;
var init_retries = __esm(() => {
  init_http();
  defaultBackoff = {
    initialInterval: 500,
    maxInterval: 60000,
    exponent: 1.5,
    maxElapsedTime: 3600000
  };
  PermanentError = class PermanentError extends Error {
    cause;
    constructor(message, options) {
      let msg = message;
      if (options?.cause) {
        msg += `: ${options.cause}`;
      }
      super(msg, options);
      this.name = "PermanentError";
      if (typeof this.cause === "undefined") {
        this.cause = options?.cause;
      }
      Object.setPrototypeOf(this, PermanentError.prototype);
    }
  };
  TemporaryError = class TemporaryError extends Error {
    response;
    constructor(message, response) {
      super(message);
      this.response = response;
      this.name = "TemporaryError";
      Object.setPrototypeOf(this, TemporaryError.prototype);
    }
  };
  codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
});

// src/lib/sdks.ts
class ClientSDK {
  #httpClient;
  #hooks;
  #logger;
  _baseURL;
  _options;
  constructor(options = {}) {
    const opt = options;
    if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof SDKHooks) {
      this.#hooks = opt.hooks;
    } else {
      this.#hooks = new SDKHooks;
    }
    this._options = { ...options, hooks: this.#hooks };
    const url = serverURLFromOptions(options);
    if (url) {
      url.pathname = url.pathname.replace(/\/+$/, "") + "/";
    }
    const { baseURL, client } = this.#hooks.sdkInit({
      baseURL: url,
      client: options.httpClient || new HTTPClient
    });
    this._baseURL = baseURL;
    this.#httpClient = client;
    this.#logger = options.debugLogger;
    if (!this.#logger && env().SERVICEM8_DEBUG) {
      this.#logger = console;
    }
  }
  _createRequest(context, conf, options) {
    const { method, path, query, headers: opHeaders, security } = conf;
    const base = conf.baseURL ?? this._baseURL;
    if (!base) {
      return ERR(new InvalidRequestError("No base URL provided for operation"));
    }
    const reqURL = new URL(base);
    const inputURL = new URL(path, reqURL);
    if (path) {
      reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
      reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
    }
    let finalQuery = query || "";
    const secQuery = [];
    for (const [k2, v2] of Object.entries(security?.queryParams || {})) {
      const q2 = encodeForm(k2, v2, { charEncoding: "percent" });
      if (typeof q2 !== "undefined") {
        secQuery.push(q2);
      }
    }
    if (secQuery.length) {
      finalQuery += `&${secQuery.join("&")}`;
    }
    if (finalQuery) {
      const q2 = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
      reqURL.search = `?${q2}`;
    }
    const headers = new Headers(opHeaders);
    const username = security?.basic.username;
    const password = security?.basic.password;
    if (username != null || password != null) {
      const encoded = stringToBase64([username || "", password || ""].join(":"));
      headers.set("Authorization", `Basic ${encoded}`);
    }
    const securityHeaders = new Headers(security?.headers || {});
    for (const [k2, v2] of securityHeaders) {
      headers.set(k2, v2);
    }
    let cookie = headers.get("cookie") || "";
    for (const [k2, v2] of Object.entries(security?.cookies || {})) {
      cookie += `; ${k2}=${v2}`;
    }
    cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
    headers.set("cookie", cookie);
    const userHeaders = new Headers(options?.fetchOptions?.headers);
    for (const [k2, v2] of userHeaders) {
      headers.set(k2, v2);
    }
    if (!isBrowserLike) {
      headers.set(conf.uaHeader ?? "user-agent", SDK_METADATA.userAgent);
    }
    let fetchOptions = options?.fetchOptions;
    if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
      const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
      if (!fetchOptions) {
        fetchOptions = { signal: timeoutSignal };
      } else {
        fetchOptions.signal = timeoutSignal;
      }
    }
    if (conf.body instanceof ReadableStream) {
      if (!fetchOptions) {
        fetchOptions = {};
      }
      Object.assign(fetchOptions, { duplex: "half" });
    }
    let input;
    try {
      input = this.#hooks.beforeCreateRequest(context, {
        url: reqURL,
        options: {
          ...fetchOptions,
          body: conf.body ?? null,
          headers,
          method
        }
      });
    } catch (err) {
      return ERR(new UnexpectedClientError("Create request hook failed to execute", {
        cause: err
      }));
    }
    return OK2(new Request(input.url, input.options));
  }
  async _do(request, options) {
    const { context, errorCodes } = options;
    return retry(async () => {
      const req = await this.#hooks.beforeRequest(context, request.clone());
      await logRequest(this.#logger, req).catch((e) => this.#logger?.log("Failed to log request:", e));
      let response = await this.#httpClient.request(req);
      try {
        if (matchStatusCode(response, errorCodes)) {
          const result = await this.#hooks.afterError(context, response, null);
          if (result.error) {
            throw result.error;
          }
          response = result.response || response;
        } else {
          response = await this.#hooks.afterSuccess(context, response);
        }
      } finally {
        await logResponse(this.#logger, response, req).catch((e) => this.#logger?.log("Failed to log response:", e));
      }
      return response;
    }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK2(r), (err) => {
      switch (true) {
        case isAbortError(err):
          return ERR(new RequestAbortedError("Request aborted by client", {
            cause: err
          }));
        case isTimeoutError(err):
          return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
        case isConnectionError(err):
          return ERR(new ConnectionError("Unable to make request", { cause: err }));
        default:
          return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
            cause: err
          }));
      }
    });
  }
}
async function logRequest(logger, req) {
  if (!logger) {
    return;
  }
  const contentType2 = req.headers.get("content-type");
  const ct = contentType2?.split(";")[0] || "";
  logger.group(`> Request: ${req.method} ${req.url}`);
  logger.group("Headers:");
  for (const [k2, v2] of req.headers.entries()) {
    logger.log(`${k2}: ${v2}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct):
      logger.log(await req.clone().json());
      break;
    case ct.startsWith("text/"):
      logger.log(await req.clone().text());
      break;
    case ct === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k2, v2] of body) {
        const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
        logger.log(`${k2}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType2}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}
async function logResponse(logger, res, req) {
  if (!logger) {
    return;
  }
  const contentType2 = res.headers.get("content-type");
  const ct = contentType2?.split(";")[0] || "";
  logger.group(`< Response: ${req.method} ${req.url}`);
  logger.log("Status Code:", res.status, res.statusText);
  logger.group("Headers:");
  for (const [k2, v2] of res.headers.entries()) {
    logger.log(`${k2}: ${v2}`);
  }
  logger.groupEnd();
  logger.group("Body:");
  switch (true) {
    case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().json());
      break;
    case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct)):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger.log(`<${contentType2}>`);
      break;
    case matchContentType(res, "text/*"):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k2, v2] of body) {
        const vlabel = v2 instanceof Blob ? "<Blob>" : v2;
        logger.log(`${k2}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType2}>`);
      break;
  }
  logger.groupEnd();
  logger.groupEnd();
}
var gt, webWorkerLike, isBrowserLike, jsonLikeContentTypeRE, jsonlLikeContentTypeRE;
var init_sdks = __esm(() => {
  init_hooks();
  init_httpclienterrors();
  init_base64();
  init_config();
  init_encodings();
  init_env();
  init_http();
  init_retries();
  gt = typeof globalThis === "undefined" ? null : globalThis;
  webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
  isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
  jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
  jsonlLikeContentTypeRE = /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
});

// src/core.ts
var ServiceM8Core;
var init_core = __esm(() => {
  init_sdks();
  ServiceM8Core = class ServiceM8Core extends ClientSDK {
  };
});

// src/mcp-server/prompts.ts
function createRegisterPrompt(logger, server, sdk, allowedScopes) {
  return (prompt) => {
    const scopes = prompt.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }
    if (allowedScopes.size > 0 && !scopes.every((s) => allowedScopes.has(s))) {
      return;
    }
    if (prompt.args) {
      if (prompt.description) {
        server.prompt(prompt.name, prompt.description, prompt.args, async (args, ctx) => prompt.prompt(sdk, args, ctx));
      } else {
        server.prompt(prompt.name, prompt.args, async (args, ctx) => prompt.prompt(sdk, args, ctx));
      }
    } else {
      if (prompt.description) {
        server.prompt(prompt.name, prompt.description, async (ctx) => prompt.prompt(sdk, ctx));
      } else {
        server.prompt(prompt.name, async (ctx) => prompt.prompt(sdk, ctx));
      }
    }
    logger.debug("Registered prompt", { name: prompt.name });
  };
}

// src/mcp-server/shared.ts
async function consumeStream(stream) {
  const reader = stream.getReader();
  const chunks = [];
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (value != null)
        chunks.push(value);
      if (done)
        break;
    }
  } finally {
    reader.releaseLock();
  }
  return new Uint8Array(await new Blob(chunks).arrayBuffer());
}
function isAsyncIterable(value) {
  return typeof value === "object" && value != null && Symbol.asyncIterator in value;
}
function isBinaryData(value) {
  return value instanceof Uint8Array || value instanceof ArrayBuffer || value instanceof Blob || value instanceof ReadableStream || value instanceof Response || typeof value === "string";
}
async function valueToBase64(value) {
  if (value == null) {
    return null;
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (value instanceof ArrayBuffer) {
    return bytesToBase64(new Uint8Array(value));
  } else if (value instanceof Response || value instanceof Blob) {
    return bytesToBase64(new Uint8Array(await value.arrayBuffer()));
  } else if (value instanceof ReadableStream) {
    return bytesToBase64(await consumeStream(value));
  } else if (typeof value === "string") {
    return base64Schema.parse(value);
  } else {
    throw new Error(`Unsupported image value type: ${typeof value}`);
  }
}
var base64Schema;
var init_shared = __esm(() => {
  init_lib();
  init_base64();
  base64Schema = stringType().base64();
});

// src/mcp-server/resources.ts
function createRegisterResource(logger, server, sdk, allowedScopes) {
  return (resource) => {
    const scopes = resource.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }
    if (allowedScopes.size > 0 && !scopes.every((s) => allowedScopes.has(s))) {
      return;
    }
    const metadata = {
      ...resource.metadata,
      description: resource.description
    };
    server.resource(resource.name, resource.resource, metadata, async (uri, ctx) => resource.read(sdk, uri, ctx));
    logger.debug("Registered resource", { name: resource.name });
  };
}
function createRegisterResourceTemplate(logger, server, sdk, allowedScopes) {
  return (resource) => {
    const scopes = resource.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }
    if (allowedScopes.size > 0 && !scopes.every((s) => allowedScopes.has(s))) {
      return;
    }
    const metadata = {
      ...resource.metadata,
      description: resource.description
    };
    server.resource(resource.name, resource.resource, metadata, async (uri, vars, ctx) => resource.read(sdk, uri, vars, ctx));
    logger.debug("Registered resource template", { name: resource.name });
  };
}
var init_resources = () => {};

// src/mcp-server/tools.ts
async function formatResult(value, init) {
  if (typeof value === "undefined") {
    return { content: [] };
  }
  const { response } = init;
  const contentType2 = response?.headers.get("content-type") ?? "";
  let content = [];
  if (contentType2.search(/\bjson\b/g)) {
    content = [{ type: "text", text: JSON.stringify(value) }];
  } else if (contentType2.startsWith("text/event-stream") && isAsyncIterable(value)) {
    content = await consumeSSE(value);
  } else if (contentType2.startsWith("text/") && typeof value === "string") {
    content = [{ type: "text", text: value }];
  } else if (isBinaryData(value) && contentType2.startsWith("image/")) {
    const data = await valueToBase64(value);
    content = data == null ? [] : [{ type: "image", data, mimeType: contentType2 }];
  } else {
    return {
      content: [{
        type: "text",
        text: `Unsupported content type: "${contentType2}"`
      }],
      isError: true
    };
  }
  return { content };
}
async function consumeSSE(value) {
  const content = [];
  for await (const chunk of value) {
    if (typeof chunk === "string") {
      content.push({ type: "text", text: chunk });
    } else {
      content.push({ type: "text", text: JSON.stringify(chunk) });
    }
  }
  return content;
}
function createRegisterTool(logger, server, sdk, allowedScopes, allowedTools) {
  return (tool) => {
    if (allowedTools && !allowedTools.has(tool.name)) {
      return;
    }
    const scopes = tool.scopes ?? [];
    if (allowedScopes.size > 0 && scopes.length === 0) {
      return;
    }
    if (allowedScopes.size > 0 && !scopes.every((s) => allowedScopes.has(s))) {
      return;
    }
    if (tool.args) {
      server.tool(tool.name, tool.description, tool.args, async (args, ctx) => {
        return tool.tool(sdk, args, ctx);
      });
    } else {
      server.tool(tool.name, tool.description, async (ctx) => {
        return tool.tool(sdk, ctx);
      });
    }
    logger.debug("Registered tool", { name: tool.name });
  };
}
var init_tools = __esm(() => {
  init_shared();
});

// src/models/errors/apierror.ts
var APIError;
var init_apierror = __esm(() => {
  APIError = class APIError extends Error {
    rawResponse;
    body;
    statusCode;
    contentType;
    constructor(message, rawResponse, body = "") {
      const statusCode = rawResponse.status;
      const contentType2 = rawResponse.headers.get("content-type") || "";
      const bodyString = body.length > 0 ? `
${body}` : "";
      super(`${message}: Status ${statusCode} Content-Type ${contentType2} Body ${bodyString}`);
      this.rawResponse = rawResponse;
      this.body = body;
      this.statusCode = statusCode;
      this.contentType = contentType2;
      this.name = "APIError";
    }
  };
});

// src/models/errors/sdkvalidationerror.ts
function formatZodError(err, level = 0) {
  let pre = "  ".repeat(level);
  pre = level > 0 ? `${pre}` : pre;
  pre += " ".repeat(level);
  let message = "";
  const append = (str) => message += `
${pre}${str}`;
  const len = err.issues.length;
  const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
  if (len) {
    append(` ${headline}:`);
  }
  for (const issue of err.issues) {
    let path = issue.path.join(".");
    path = path ? `<root>.${path}` : "<root>";
    append(`  [${path}]: ${issue.message} (${issue.code})`);
    switch (issue.code) {
      case "invalid_literal":
      case "invalid_type": {
        append(`     Want: ${issue.expected}`);
        append(`      Got: ${issue.received}`);
        break;
      }
      case "unrecognized_keys": {
        append(`     Keys: ${issue.keys.join(", ")}`);
        break;
      }
      case "invalid_enum_value": {
        append(`     Allowed: ${issue.options.join(", ")}`);
        append(`         Got: ${issue.received}`);
        break;
      }
      case "invalid_union_discriminator": {
        append(`     Allowed: ${issue.options.join(", ")}`);
        break;
      }
      case "invalid_union": {
        const len2 = issue.unionErrors.length;
        append(`    Attemped to deserialize into one of ${len2} union members:`);
        issue.unionErrors.forEach((err2, i) => {
          append(`    Member ${i + 1} of ${len2}`);
          append(`${formatZodError(err2, level + 1)}`);
        });
      }
    }
  }
  if (err.issues.length) {
    append(`*`);
  }
  return message.slice(1);
}
var SDKValidationError;
var init_sdkvalidationerror = __esm(() => {
  init_lib();
  SDKValidationError = class SDKValidationError extends Error {
    rawValue;
    rawMessage;
    constructor(message, cause, rawValue) {
      super(`${message}: ${cause}`);
      this.name = "SDKValidationError";
      this.cause = cause;
      this.rawValue = rawValue;
      this.rawMessage = message;
    }
    pretty() {
      if (this.cause instanceof ZodError) {
        return `${this.rawMessage}
${formatZodError(this.cause)}`;
      } else {
        return this.toString();
      }
    }
  };
});

// src/lib/schemas.ts
function safeParse(rawValue, fn, errorMessage) {
  try {
    return OK2(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}
var init_schemas = __esm(() => {
  init_sdkvalidationerror();
});

// src/lib/matchers.ts
function jsonErr(codes, schema, options) {
  return { ...options, err: true, enc: "json", codes, schema };
}
function json(codes, schema, options) {
  return { ...options, enc: "json", codes, schema };
}
function fail(codes) {
  return { enc: "fail", codes };
}
function match(...matchers) {
  return async function matchFunc(response, options) {
    let raw;
    let matcher;
    for (const match2 of matchers) {
      const { codes } = match2;
      const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match2;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match2;
        break;
      }
    }
    if (!matcher) {
      const responseBody = await response.text();
      return [{
        ok: false,
        error: new APIError("Unexpected API response status or content-type", response, responseBody)
      }, responseBody];
    }
    const encoding = matcher.enc;
    switch (encoding) {
      case "json":
        raw = await response.json();
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        raw = await response.text();
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        raw = await discardResponseBody(response);
        break;
      case "fail":
        raw = await response.text();
        break;
      default:
        throw new Error(`Unsupported response type: ${encoding}`);
    }
    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new APIError("API error occurred", response, typeof raw === "string" ? raw : "")
      }, raw];
    }
    const resultKey = matcher.key || options?.resultKey;
    let data;
    if ("err" in matcher) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject(raw) ? raw : null
      };
    } else if (resultKey) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        [resultKey]: raw
      };
    } else if (matcher.hdrs) {
      data = {
        ...options?.extraFields,
        ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
        ...isPlainObject(raw) ? raw : null
      };
    } else {
      data = raw;
    }
    if ("err" in matcher) {
      const result = safeParse(data, (v2) => matcher.schema.parse(v2), "Response validation failed");
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParse(data, (v2) => matcher.schema.parse(v2), "Response validation failed"),
        raw
      ];
    }
  };
}
function unpackHeaders(headers) {
  const out = {};
  for (const [k2, v2] of headers.entries()) {
    out[k2] = v2.split(headerValRE);
  }
  return out;
}
async function discardResponseBody(res) {
  const reader = res.body?.getReader();
  if (reader == null) {
    return;
  }
  try {
    let done = false;
    while (!done) {
      const res2 = await reader.read();
      done = res2.done;
    }
  } finally {
    reader.releaseLock();
  }
}
var DEFAULT_CONTENT_TYPES, headerValRE;
var init_matchers = __esm(() => {
  init_apierror();
  init_http();
  init_schemas();
  DEFAULT_CONTENT_TYPES = {
    jsonl: "application/jsonl",
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
  };
  headerValRE = /, */;
});

// src/lib/primitives.ts
function remap(inp, mappings) {
  let out = {};
  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }
  for (const [k2, v2] of Object.entries(inp)) {
    const j2 = mappings[k2];
    if (j2 === null) {
      continue;
    }
    out[j2 ?? k2] = v2;
  }
  return out;
}
function compactMap(values) {
  const out = {};
  for (const [k2, v2] of Object.entries(values)) {
    if (typeof v2 !== "undefined") {
      out[k2] = v2;
    }
  }
  return out;
}
var init_primitives = () => {};

// src/lib/security.ts
function resolveSecurity(...options) {
  const state = {
    basic: {},
    headers: {},
    queryParams: {},
    cookies: {},
    oauth2: { type: "none" }
  };
  const option = options.find((opts) => {
    return opts.every((o) => {
      if (o.value == null) {
        return false;
      } else if (o.type === "http:basic") {
        return o.value.username != null || o.value.password != null;
      } else if (o.type === "http:custom") {
        return null;
      } else if (o.type === "oauth2:password") {
        return typeof o.value === "string" && !!o.value;
      } else if (o.type === "oauth2:client_credentials") {
        if (typeof o.value == "string") {
          return !!o.value;
        }
        return o.value.clientID != null || o.value.clientSecret != null;
      } else if (typeof o.value === "string") {
        return !!o.value;
      } else {
        throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
      }
    });
  });
  if (option == null) {
    return null;
  }
  option.forEach((spec) => {
    if (spec.value == null) {
      return;
    }
    const { type } = spec;
    switch (type) {
      case "apiKey:header":
        state.headers[spec.fieldName] = spec.value;
        break;
      case "apiKey:query":
        state.queryParams[spec.fieldName] = spec.value;
        break;
      case "apiKey:cookie":
        state.cookies[spec.fieldName] = spec.value;
        break;
      case "http:basic":
        applyBasic(state, spec);
        break;
      case "http:custom":
        break;
      case "http:bearer":
        applyBearer(state, spec);
        break;
      case "oauth2":
        applyBearer(state, spec);
        break;
      case "oauth2:password":
        applyBearer(state, spec);
        break;
      case "oauth2:client_credentials":
        break;
      case "openIdConnect":
        applyBearer(state, spec);
        break;
      default:
        throw SecurityError.unrecognizedType(type);
    }
  });
  return state;
}
function applyBasic(state, spec) {
  if (spec.value == null) {
    return;
  }
  state.basic = spec.value;
}
function applyBearer(state, spec) {
  if (typeof spec.value !== "string" || !spec.value) {
    return;
  }
  let value = spec.value;
  if (value.slice(0, 7).toLowerCase() !== "bearer ") {
    value = `Bearer ${value}`;
  }
  if (spec.fieldName !== undefined) {
    state.headers[spec.fieldName] = value;
  }
}
function resolveGlobalSecurity(security) {
  return resolveSecurity([
    {
      fieldName: "Authorization",
      type: "oauth2",
      value: security?.oauth2 ?? env().SERVICEM8_OAUTH2
    }
  ], [
    {
      fieldName: "X-Api-Key",
      type: "apiKey:header",
      value: security?.apiKeyAuth ?? env().SERVICEM8_API_KEY_AUTH
    }
  ]);
}
async function extractSecurity(sec) {
  if (sec == null) {
    return;
  }
  return typeof sec === "function" ? sec() : sec;
}
var SecurityError;
var init_security = __esm(() => {
  init_env();
  SecurityError = class SecurityError extends Error {
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "SecurityError";
    }
    static incomplete() {
      return new SecurityError("incomplete" /* Incomplete */, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(type) {
      return new SecurityError("unrecognized_security_type" /* UnrecognisedSecurityType */, `Unrecognised security type: ${type}`);
    }
  };
});

// src/models/components/allocationwindow.ts
var AllocationWindowActive, AllocationWindowActive$inboundSchema, AllocationWindowActive$outboundSchema, AllocationWindowActive$, AllocationWindow$inboundSchema, AllocationWindow$outboundSchema, AllocationWindow$, AllocationWindowInput$inboundSchema, AllocationWindowInput$outboundSchema, AllocationWindowInput$;
var init_allocationwindow = __esm(() => {
  init_lib();
  init_primitives();
  AllocationWindowActive = {
    Zero: 0,
    One: 1
  };
  AllocationWindowActive$inboundSchema = nativeEnumType(AllocationWindowActive);
  AllocationWindowActive$outboundSchema = AllocationWindowActive$inboundSchema;
  ((AllocationWindowActive$) => {
    AllocationWindowActive$.inboundSchema = AllocationWindowActive$inboundSchema;
    AllocationWindowActive$.outboundSchema = AllocationWindowActive$outboundSchema;
  })(AllocationWindowActive$ ||= {});
  AllocationWindow$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AllocationWindowActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType().optional(),
    start_time: numberType().int().optional(),
    end_time: numberType().int().optional(),
    sort_priority: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      start_time: "startTime",
      end_time: "endTime",
      sort_priority: "sortPriority"
    });
  });
  AllocationWindow$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AllocationWindowActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType().optional(),
    startTime: numberType().int().optional(),
    endTime: numberType().int().optional(),
    sortPriority: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      startTime: "start_time",
      endTime: "end_time",
      sortPriority: "sort_priority"
    });
  });
  ((AllocationWindow$) => {
    AllocationWindow$.inboundSchema = AllocationWindow$inboundSchema;
    AllocationWindow$.outboundSchema = AllocationWindow$outboundSchema;
  })(AllocationWindow$ ||= {});
  AllocationWindowInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AllocationWindowActive$inboundSchema.default(1),
    name: stringType().optional(),
    start_time: numberType().int().optional(),
    end_time: numberType().int().optional(),
    sort_priority: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      start_time: "startTime",
      end_time: "endTime",
      sort_priority: "sortPriority"
    });
  });
  AllocationWindowInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AllocationWindowActive$outboundSchema.default(1),
    name: stringType().optional(),
    startTime: numberType().int().optional(),
    endTime: numberType().int().optional(),
    sortPriority: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      startTime: "start_time",
      endTime: "end_time",
      sortPriority: "sort_priority"
    });
  });
  ((AllocationWindowInput$) => {
    AllocationWindowInput$.inboundSchema = AllocationWindowInput$inboundSchema;
    AllocationWindowInput$.outboundSchema = AllocationWindowInput$outboundSchema;
  })(AllocationWindowInput$ ||= {});
});

// src/models/components/asset.ts
var AssetActive, AssetActive$inboundSchema, AssetActive$outboundSchema, AssetActive$, FieldDatum$inboundSchema, FieldDatum$outboundSchema, FieldDatum$, Asset$inboundSchema, Asset$outboundSchema, Asset$, AssetInput$inboundSchema, AssetInput$outboundSchema, AssetInput$;
var init_asset = __esm(() => {
  init_lib();
  init_primitives();
  AssetActive = {
    Zero: 0,
    One: 1
  };
  AssetActive$inboundSchema = nativeEnumType(AssetActive);
  AssetActive$outboundSchema = AssetActive$inboundSchema;
  ((AssetActive$) => {
    AssetActive$.inboundSchema = AssetActive$inboundSchema;
    AssetActive$.outboundSchema = AssetActive$outboundSchema;
  })(AssetActive$ ||= {});
  FieldDatum$inboundSchema = objectType({
    uuid: stringType(),
    fieldType: stringType(),
    fieldName: stringType(),
    fieldValue: stringType(),
    sortOrder: numberType()
  });
  FieldDatum$outboundSchema = objectType({
    uuid: stringType(),
    fieldType: stringType(),
    fieldName: stringType(),
    fieldValue: stringType(),
    sortOrder: numberType()
  });
  ((FieldDatum$) => {
    FieldDatum$.inboundSchema = FieldDatum$inboundSchema;
    FieldDatum$.outboundSchema = FieldDatum$outboundSchema;
  })(FieldDatum$ ||= {});
  Asset$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    company_uuid: stringType().optional(),
    asset_code: stringType().optional(),
    asset_type_uuid: stringType().optional(),
    name: stringType(),
    lat: numberType().optional(),
    lng: numberType().optional(),
    geo_timestamp: stringType().optional(),
    altitude: numberType().optional(),
    field_data: arrayType(lazyType(() => FieldDatum$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      company_uuid: "companyUuid",
      asset_code: "assetCode",
      asset_type_uuid: "assetTypeUuid",
      geo_timestamp: "geoTimestamp",
      field_data: "fieldData"
    });
  });
  Asset$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    companyUuid: stringType().optional(),
    assetCode: stringType().optional(),
    assetTypeUuid: stringType().optional(),
    name: stringType(),
    lat: numberType().optional(),
    lng: numberType().optional(),
    geoTimestamp: stringType().optional(),
    altitude: numberType().optional(),
    fieldData: arrayType(lazyType(() => FieldDatum$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      companyUuid: "company_uuid",
      assetCode: "asset_code",
      assetTypeUuid: "asset_type_uuid",
      geoTimestamp: "geo_timestamp",
      fieldData: "field_data"
    });
  });
  ((Asset$) => {
    Asset$.inboundSchema = Asset$inboundSchema;
    Asset$.outboundSchema = Asset$outboundSchema;
  })(Asset$ ||= {});
  AssetInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetActive$inboundSchema.default(1),
    company_uuid: stringType().optional(),
    asset_code: stringType().optional(),
    asset_type_uuid: stringType().optional(),
    name: stringType(),
    lat: numberType().optional(),
    lng: numberType().optional(),
    geo_timestamp: stringType().optional(),
    altitude: numberType().optional(),
    field_data: arrayType(lazyType(() => FieldDatum$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      company_uuid: "companyUuid",
      asset_code: "assetCode",
      asset_type_uuid: "assetTypeUuid",
      geo_timestamp: "geoTimestamp",
      field_data: "fieldData"
    });
  });
  AssetInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetActive$outboundSchema.default(1),
    companyUuid: stringType().optional(),
    assetCode: stringType().optional(),
    assetTypeUuid: stringType().optional(),
    name: stringType(),
    lat: numberType().optional(),
    lng: numberType().optional(),
    geoTimestamp: stringType().optional(),
    altitude: numberType().optional(),
    fieldData: arrayType(lazyType(() => FieldDatum$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      companyUuid: "company_uuid",
      assetCode: "asset_code",
      assetTypeUuid: "asset_type_uuid",
      geoTimestamp: "geo_timestamp",
      fieldData: "field_data"
    });
  });
  ((AssetInput$) => {
    AssetInput$.inboundSchema = AssetInput$inboundSchema;
    AssetInput$.outboundSchema = AssetInput$outboundSchema;
  })(AssetInput$ ||= {});
});

// src/models/components/assettype.ts
var AssetTypeActive, AssetTypeActive$inboundSchema, AssetTypeActive$outboundSchema, AssetTypeActive$, AssetType$inboundSchema, AssetType$outboundSchema, AssetType$, AssetTypeInput$inboundSchema, AssetTypeInput$outboundSchema, AssetTypeInput$;
var init_assettype = __esm(() => {
  init_lib();
  init_primitives();
  AssetTypeActive = {
    Zero: 0,
    One: 1
  };
  AssetTypeActive$inboundSchema = nativeEnumType(AssetTypeActive);
  AssetTypeActive$outboundSchema = AssetTypeActive$inboundSchema;
  ((AssetTypeActive$) => {
    AssetTypeActive$.inboundSchema = AssetTypeActive$inboundSchema;
    AssetTypeActive$.outboundSchema = AssetTypeActive$outboundSchema;
  })(AssetTypeActive$ ||= {});
  AssetType$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate"
    });
  });
  AssetType$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date"
    });
  });
  ((AssetType$) => {
    AssetType$.inboundSchema = AssetType$inboundSchema;
    AssetType$.outboundSchema = AssetType$outboundSchema;
  })(AssetType$ ||= {});
  AssetTypeInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeActive$inboundSchema.default(1),
    name: stringType().optional()
  });
  AssetTypeInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeActive$outboundSchema.default(1),
    name: stringType().optional()
  });
  ((AssetTypeInput$) => {
    AssetTypeInput$.inboundSchema = AssetTypeInput$inboundSchema;
    AssetTypeInput$.outboundSchema = AssetTypeInput$outboundSchema;
  })(AssetTypeInput$ ||= {});
});

// src/models/components/assettypefield.ts
var AssetTypeFieldActive, AssetTypeFieldFieldType, AssetTypeFieldActive$inboundSchema, AssetTypeFieldActive$outboundSchema, AssetTypeFieldActive$, AssetTypeFieldFieldType$inboundSchema, AssetTypeFieldFieldType$outboundSchema, AssetTypeFieldFieldType$, FieldData$inboundSchema, FieldData$outboundSchema, FieldData$, AssetTypeField$inboundSchema, AssetTypeField$outboundSchema, AssetTypeField$, AssetTypeFieldInput$inboundSchema, AssetTypeFieldInput$outboundSchema, AssetTypeFieldInput$;
var init_assettypefield = __esm(() => {
  init_lib();
  init_primitives();
  AssetTypeFieldActive = {
    Zero: 0,
    One: 1
  };
  AssetTypeFieldFieldType = {
    Text: "Text",
    Number: "Number",
    Date: "Date",
    MultipleChoice: "Multiple Choice"
  };
  AssetTypeFieldActive$inboundSchema = nativeEnumType(AssetTypeFieldActive);
  AssetTypeFieldActive$outboundSchema = AssetTypeFieldActive$inboundSchema;
  ((AssetTypeFieldActive$) => {
    AssetTypeFieldActive$.inboundSchema = AssetTypeFieldActive$inboundSchema;
    AssetTypeFieldActive$.outboundSchema = AssetTypeFieldActive$outboundSchema;
  })(AssetTypeFieldActive$ ||= {});
  AssetTypeFieldFieldType$inboundSchema = nativeEnumType(AssetTypeFieldFieldType);
  AssetTypeFieldFieldType$outboundSchema = AssetTypeFieldFieldType$inboundSchema;
  ((AssetTypeFieldFieldType$) => {
    AssetTypeFieldFieldType$.inboundSchema = AssetTypeFieldFieldType$inboundSchema;
    AssetTypeFieldFieldType$.outboundSchema = AssetTypeFieldFieldType$outboundSchema;
  })(AssetTypeFieldFieldType$ ||= {});
  FieldData$inboundSchema = objectType({
    fieldType: AssetTypeFieldFieldType$inboundSchema,
    mandatory: booleanType(),
    choices: arrayType(stringType()).optional()
  });
  FieldData$outboundSchema = objectType({
    fieldType: AssetTypeFieldFieldType$outboundSchema,
    mandatory: booleanType(),
    choices: arrayType(stringType()).optional()
  });
  ((FieldData$) => {
    FieldData$.inboundSchema = FieldData$inboundSchema;
    FieldData$.outboundSchema = FieldData$outboundSchema;
  })(FieldData$ ||= {});
  AssetTypeField$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeFieldActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    asset_type_uuid: stringType().optional(),
    name: stringType(),
    field_data: lazyType(() => FieldData$inboundSchema).optional(),
    sort_order: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      asset_type_uuid: "assetTypeUuid",
      field_data: "fieldData",
      sort_order: "sortOrder"
    });
  });
  AssetTypeField$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeFieldActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    assetTypeUuid: stringType().optional(),
    name: stringType(),
    fieldData: lazyType(() => FieldData$outboundSchema).optional(),
    sortOrder: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      assetTypeUuid: "asset_type_uuid",
      fieldData: "field_data",
      sortOrder: "sort_order"
    });
  });
  ((AssetTypeField$) => {
    AssetTypeField$.inboundSchema = AssetTypeField$inboundSchema;
    AssetTypeField$.outboundSchema = AssetTypeField$outboundSchema;
  })(AssetTypeField$ ||= {});
  AssetTypeFieldInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeFieldActive$inboundSchema.default(1),
    asset_type_uuid: stringType().optional(),
    name: stringType(),
    field_data: lazyType(() => FieldData$inboundSchema).optional(),
    sort_order: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      asset_type_uuid: "assetTypeUuid",
      field_data: "fieldData",
      sort_order: "sortOrder"
    });
  });
  AssetTypeFieldInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AssetTypeFieldActive$outboundSchema.default(1),
    assetTypeUuid: stringType().optional(),
    name: stringType(),
    fieldData: lazyType(() => FieldData$outboundSchema).optional(),
    sortOrder: numberType().int().optional()
  }).transform((v2) => {
    return remap(v2, {
      assetTypeUuid: "asset_type_uuid",
      fieldData: "field_data",
      sortOrder: "sort_order"
    });
  });
  ((AssetTypeFieldInput$) => {
    AssetTypeFieldInput$.inboundSchema = AssetTypeFieldInput$inboundSchema;
    AssetTypeFieldInput$.outboundSchema = AssetTypeFieldInput$outboundSchema;
  })(AssetTypeFieldInput$ ||= {});
});

// src/models/components/attachment.ts
var AttachmentActive, AttachmentActive$inboundSchema, AttachmentActive$outboundSchema, AttachmentActive$, Attachment$inboundSchema, Attachment$outboundSchema, Attachment$, AttachmentInput$inboundSchema, AttachmentInput$outboundSchema, AttachmentInput$;
var init_attachment = __esm(() => {
  init_lib();
  init_primitives();
  AttachmentActive = {
    Zero: 0,
    One: 1
  };
  AttachmentActive$inboundSchema = nativeEnumType(AttachmentActive);
  AttachmentActive$outboundSchema = AttachmentActive$inboundSchema;
  ((AttachmentActive$) => {
    AttachmentActive$.inboundSchema = AttachmentActive$inboundSchema;
    AttachmentActive$.outboundSchema = AttachmentActive$outboundSchema;
  })(AttachmentActive$ ||= {});
  Attachment$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AttachmentActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    attachment_name: stringType().optional(),
    file_type: stringType().optional(),
    created_by_staff_uuid: stringType().optional(),
    timestamp: stringType().optional(),
    attachment_source: stringType().optional(),
    tags: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    photo_width: stringType().optional(),
    photo_height: stringType().optional(),
    extracted_info: stringType().optional(),
    is_favourite: stringType().optional(),
    class_name: stringType().optional(),
    metadata: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      attachment_name: "attachmentName",
      file_type: "fileType",
      created_by_staff_uuid: "createdByStaffUuid",
      attachment_source: "attachmentSource",
      photo_width: "photoWidth",
      photo_height: "photoHeight",
      extracted_info: "extractedInfo",
      is_favourite: "isFavourite",
      class_name: "className"
    });
  });
  Attachment$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AttachmentActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    attachmentName: stringType().optional(),
    fileType: stringType().optional(),
    createdByStaffUuid: stringType().optional(),
    timestamp: stringType().optional(),
    attachmentSource: stringType().optional(),
    tags: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    photoWidth: stringType().optional(),
    photoHeight: stringType().optional(),
    extractedInfo: stringType().optional(),
    isFavourite: stringType().optional(),
    className: stringType().optional(),
    metadata: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      attachmentName: "attachment_name",
      fileType: "file_type",
      createdByStaffUuid: "created_by_staff_uuid",
      attachmentSource: "attachment_source",
      photoWidth: "photo_width",
      photoHeight: "photo_height",
      extractedInfo: "extracted_info",
      isFavourite: "is_favourite",
      className: "class_name"
    });
  });
  ((Attachment$) => {
    Attachment$.inboundSchema = Attachment$inboundSchema;
    Attachment$.outboundSchema = Attachment$outboundSchema;
  })(Attachment$ ||= {});
  AttachmentInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: AttachmentActive$inboundSchema.default(1),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    attachment_name: stringType().optional(),
    file_type: stringType().optional(),
    created_by_staff_uuid: stringType().optional(),
    timestamp: stringType().optional(),
    attachment_source: stringType().optional(),
    tags: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    photo_width: stringType().optional(),
    photo_height: stringType().optional(),
    extracted_info: stringType().optional(),
    is_favourite: stringType().optional(),
    class_name: stringType().optional(),
    metadata: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      attachment_name: "attachmentName",
      file_type: "fileType",
      created_by_staff_uuid: "createdByStaffUuid",
      attachment_source: "attachmentSource",
      photo_width: "photoWidth",
      photo_height: "photoHeight",
      extracted_info: "extractedInfo",
      is_favourite: "isFavourite",
      class_name: "className"
    });
  });
  AttachmentInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: AttachmentActive$outboundSchema.default(1),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    attachmentName: stringType().optional(),
    fileType: stringType().optional(),
    createdByStaffUuid: stringType().optional(),
    timestamp: stringType().optional(),
    attachmentSource: stringType().optional(),
    tags: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    photoWidth: stringType().optional(),
    photoHeight: stringType().optional(),
    extractedInfo: stringType().optional(),
    isFavourite: stringType().optional(),
    className: stringType().optional(),
    metadata: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      attachmentName: "attachment_name",
      fileType: "file_type",
      createdByStaffUuid: "created_by_staff_uuid",
      attachmentSource: "attachment_source",
      photoWidth: "photo_width",
      photoHeight: "photo_height",
      extractedInfo: "extracted_info",
      isFavourite: "is_favourite",
      className: "class_name"
    });
  });
  ((AttachmentInput$) => {
    AttachmentInput$.inboundSchema = AttachmentInput$inboundSchema;
    AttachmentInput$.outboundSchema = AttachmentInput$outboundSchema;
  })(AttachmentInput$ ||= {});
});

// src/models/components/badge.ts
var BadgeActive, BadgeActive$inboundSchema, BadgeActive$outboundSchema, BadgeActive$, Badge$inboundSchema, Badge$outboundSchema, Badge$, BadgeInput$inboundSchema, BadgeInput$outboundSchema, BadgeInput$;
var init_badge = __esm(() => {
  init_lib();
  init_primitives();
  BadgeActive = {
    Zero: 0,
    One: 1
  };
  BadgeActive$inboundSchema = nativeEnumType(BadgeActive);
  BadgeActive$outboundSchema = BadgeActive$inboundSchema;
  ((BadgeActive$) => {
    BadgeActive$.inboundSchema = BadgeActive$inboundSchema;
    BadgeActive$.outboundSchema = BadgeActive$outboundSchema;
  })(BadgeActive$ ||= {});
  Badge$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: BadgeActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    automatically_allocated: stringType().optional(),
    file_name: stringType().optional(),
    regarding_form_uuid: stringType().optional(),
    regarding_asset_type_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      automatically_allocated: "automaticallyAllocated",
      file_name: "fileName",
      regarding_form_uuid: "regardingFormUuid",
      regarding_asset_type_uuid: "regardingAssetTypeUuid"
    });
  });
  Badge$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: BadgeActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    automaticallyAllocated: stringType().optional(),
    fileName: stringType().optional(),
    regardingFormUuid: stringType().optional(),
    regardingAssetTypeUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      automaticallyAllocated: "automatically_allocated",
      fileName: "file_name",
      regardingFormUuid: "regarding_form_uuid",
      regardingAssetTypeUuid: "regarding_asset_type_uuid"
    });
  });
  ((Badge$) => {
    Badge$.inboundSchema = Badge$inboundSchema;
    Badge$.outboundSchema = Badge$outboundSchema;
  })(Badge$ ||= {});
  BadgeInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: BadgeActive$inboundSchema.default(1),
    name: stringType(),
    automatically_allocated: stringType().optional(),
    file_name: stringType().optional(),
    regarding_form_uuid: stringType().optional(),
    regarding_asset_type_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      automatically_allocated: "automaticallyAllocated",
      file_name: "fileName",
      regarding_form_uuid: "regardingFormUuid",
      regarding_asset_type_uuid: "regardingAssetTypeUuid"
    });
  });
  BadgeInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: BadgeActive$outboundSchema.default(1),
    name: stringType(),
    automaticallyAllocated: stringType().optional(),
    fileName: stringType().optional(),
    regardingFormUuid: stringType().optional(),
    regardingAssetTypeUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      automaticallyAllocated: "automatically_allocated",
      fileName: "file_name",
      regardingFormUuid: "regarding_form_uuid",
      regardingAssetTypeUuid: "regarding_asset_type_uuid"
    });
  });
  ((BadgeInput$) => {
    BadgeInput$.inboundSchema = BadgeInput$inboundSchema;
    BadgeInput$.outboundSchema = BadgeInput$outboundSchema;
  })(BadgeInput$ ||= {});
});

// src/models/components/category.ts
var CategoryActive, CategoryActive$inboundSchema, CategoryActive$outboundSchema, CategoryActive$, Category$inboundSchema, Category$outboundSchema, Category$, CategoryInput$inboundSchema, CategoryInput$outboundSchema, CategoryInput$;
var init_category = __esm(() => {
  init_lib();
  init_primitives();
  CategoryActive = {
    Zero: 0,
    One: 1
  };
  CategoryActive$inboundSchema = nativeEnumType(CategoryActive);
  CategoryActive$outboundSchema = CategoryActive$inboundSchema;
  ((CategoryActive$) => {
    CategoryActive$.inboundSchema = CategoryActive$inboundSchema;
    CategoryActive$.outboundSchema = CategoryActive$outboundSchema;
  })(CategoryActive$ ||= {});
  Category$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CategoryActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    colour: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate"
    });
  });
  Category$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CategoryActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    colour: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date"
    });
  });
  ((Category$) => {
    Category$.inboundSchema = Category$inboundSchema;
    Category$.outboundSchema = Category$outboundSchema;
  })(Category$ ||= {});
  CategoryInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CategoryActive$inboundSchema.default(1),
    name: stringType(),
    colour: stringType().optional()
  });
  CategoryInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CategoryActive$outboundSchema.default(1),
    name: stringType(),
    colour: stringType().optional()
  });
  ((CategoryInput$) => {
    CategoryInput$.inboundSchema = CategoryInput$inboundSchema;
    CategoryInput$.outboundSchema = CategoryInput$outboundSchema;
  })(CategoryInput$ ||= {});
});

// src/models/components/company.ts
var CompanyActive, CompanyActive$inboundSchema, CompanyActive$outboundSchema, CompanyActive$, Company$inboundSchema, Company$outboundSchema, Company$, CompanyInput$inboundSchema, CompanyInput$outboundSchema, CompanyInput$;
var init_company = __esm(() => {
  init_lib();
  init_primitives();
  CompanyActive = {
    Zero: 0,
    One: 1
  };
  CompanyActive$inboundSchema = nativeEnumType(CompanyActive);
  CompanyActive$outboundSchema = CompanyActive$inboundSchema;
  ((CompanyActive$) => {
    CompanyActive$.inboundSchema = CompanyActive$inboundSchema;
    CompanyActive$.outboundSchema = CompanyActive$outboundSchema;
  })(CompanyActive$ ||= {});
  Company$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    website: stringType().optional(),
    abn_number: stringType().optional(),
    is_individual: stringType().optional(),
    address_street: stringType().optional(),
    address_city: stringType().optional(),
    address_state: stringType().optional(),
    address_postcode: stringType().optional(),
    address_country: stringType().optional(),
    fax_number: stringType().optional(),
    address: stringType().optional(),
    billing_address: stringType().optional(),
    badges: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    billing_attention: stringType().optional(),
    payment_terms: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      abn_number: "abnNumber",
      is_individual: "isIndividual",
      address_street: "addressStreet",
      address_city: "addressCity",
      address_state: "addressState",
      address_postcode: "addressPostcode",
      address_country: "addressCountry",
      fax_number: "faxNumber",
      billing_address: "billingAddress",
      tax_rate_uuid: "taxRateUuid",
      billing_attention: "billingAttention",
      payment_terms: "paymentTerms"
    });
  });
  Company$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    website: stringType().optional(),
    abnNumber: stringType().optional(),
    isIndividual: stringType().optional(),
    addressStreet: stringType().optional(),
    addressCity: stringType().optional(),
    addressState: stringType().optional(),
    addressPostcode: stringType().optional(),
    addressCountry: stringType().optional(),
    faxNumber: stringType().optional(),
    address: stringType().optional(),
    billingAddress: stringType().optional(),
    badges: stringType().optional(),
    taxRateUuid: stringType().optional(),
    billingAttention: stringType().optional(),
    paymentTerms: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      abnNumber: "abn_number",
      isIndividual: "is_individual",
      addressStreet: "address_street",
      addressCity: "address_city",
      addressState: "address_state",
      addressPostcode: "address_postcode",
      addressCountry: "address_country",
      faxNumber: "fax_number",
      billingAddress: "billing_address",
      taxRateUuid: "tax_rate_uuid",
      billingAttention: "billing_attention",
      paymentTerms: "payment_terms"
    });
  });
  ((Company$) => {
    Company$.inboundSchema = Company$inboundSchema;
    Company$.outboundSchema = Company$outboundSchema;
  })(Company$ ||= {});
  CompanyInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyActive$inboundSchema.default(1),
    name: stringType(),
    website: stringType().optional(),
    abn_number: stringType().optional(),
    is_individual: stringType().optional(),
    address_street: stringType().optional(),
    address_city: stringType().optional(),
    address_state: stringType().optional(),
    address_postcode: stringType().optional(),
    address_country: stringType().optional(),
    fax_number: stringType().optional(),
    address: stringType().optional(),
    billing_address: stringType().optional(),
    badges: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    billing_attention: stringType().optional(),
    payment_terms: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      abn_number: "abnNumber",
      is_individual: "isIndividual",
      address_street: "addressStreet",
      address_city: "addressCity",
      address_state: "addressState",
      address_postcode: "addressPostcode",
      address_country: "addressCountry",
      fax_number: "faxNumber",
      billing_address: "billingAddress",
      tax_rate_uuid: "taxRateUuid",
      billing_attention: "billingAttention",
      payment_terms: "paymentTerms"
    });
  });
  CompanyInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyActive$outboundSchema.default(1),
    name: stringType(),
    website: stringType().optional(),
    abnNumber: stringType().optional(),
    isIndividual: stringType().optional(),
    addressStreet: stringType().optional(),
    addressCity: stringType().optional(),
    addressState: stringType().optional(),
    addressPostcode: stringType().optional(),
    addressCountry: stringType().optional(),
    faxNumber: stringType().optional(),
    address: stringType().optional(),
    billingAddress: stringType().optional(),
    badges: stringType().optional(),
    taxRateUuid: stringType().optional(),
    billingAttention: stringType().optional(),
    paymentTerms: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      abnNumber: "abn_number",
      isIndividual: "is_individual",
      addressStreet: "address_street",
      addressCity: "address_city",
      addressState: "address_state",
      addressPostcode: "address_postcode",
      addressCountry: "address_country",
      faxNumber: "fax_number",
      billingAddress: "billing_address",
      taxRateUuid: "tax_rate_uuid",
      billingAttention: "billing_attention",
      paymentTerms: "payment_terms"
    });
  });
  ((CompanyInput$) => {
    CompanyInput$.inboundSchema = CompanyInput$inboundSchema;
    CompanyInput$.outboundSchema = CompanyInput$outboundSchema;
  })(CompanyInput$ ||= {});
});

// src/models/components/companycontact.ts
var CompanyContactActive, CompanyContactActive$inboundSchema, CompanyContactActive$outboundSchema, CompanyContactActive$, CompanyContact$inboundSchema, CompanyContact$outboundSchema, CompanyContact$, CompanyContactInput$inboundSchema, CompanyContactInput$outboundSchema, CompanyContactInput$;
var init_companycontact = __esm(() => {
  init_lib();
  init_primitives();
  CompanyContactActive = {
    Zero: 0,
    One: 1
  };
  CompanyContactActive$inboundSchema = nativeEnumType(CompanyContactActive);
  CompanyContactActive$outboundSchema = CompanyContactActive$inboundSchema;
  ((CompanyContactActive$) => {
    CompanyContactActive$.inboundSchema = CompanyContactActive$inboundSchema;
    CompanyContactActive$.outboundSchema = CompanyContactActive$outboundSchema;
  })(CompanyContactActive$ ||= {});
  CompanyContact$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyContactActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    company_uuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    is_primary_contact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      company_uuid: "companyUuid",
      is_primary_contact: "isPrimaryContact"
    });
  });
  CompanyContact$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyContactActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    companyUuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    isPrimaryContact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      companyUuid: "company_uuid",
      isPrimaryContact: "is_primary_contact"
    });
  });
  ((CompanyContact$) => {
    CompanyContact$.inboundSchema = CompanyContact$inboundSchema;
    CompanyContact$.outboundSchema = CompanyContact$outboundSchema;
  })(CompanyContact$ ||= {});
  CompanyContactInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyContactActive$inboundSchema.default(1),
    company_uuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    is_primary_contact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      company_uuid: "companyUuid",
      is_primary_contact: "isPrimaryContact"
    });
  });
  CompanyContactInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: CompanyContactActive$outboundSchema.default(1),
    companyUuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    isPrimaryContact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      companyUuid: "company_uuid",
      isPrimaryContact: "is_primary_contact"
    });
  });
  ((CompanyContactInput$) => {
    CompanyContactInput$.inboundSchema = CompanyContactInput$inboundSchema;
    CompanyContactInput$.outboundSchema = CompanyContactInput$outboundSchema;
  })(CompanyContactInput$ ||= {});
});

// src/models/components/emailtemplate.ts
var EmailTemplateActive, EmailTemplateActive$inboundSchema, EmailTemplateActive$outboundSchema, EmailTemplateActive$, EmailTemplate$inboundSchema, EmailTemplate$outboundSchema, EmailTemplate$, EmailTemplateInput$inboundSchema, EmailTemplateInput$outboundSchema, EmailTemplateInput$;
var init_emailtemplate = __esm(() => {
  init_lib();
  init_primitives();
  EmailTemplateActive = {
    Zero: 0,
    One: 1
  };
  EmailTemplateActive$inboundSchema = nativeEnumType(EmailTemplateActive);
  EmailTemplateActive$outboundSchema = EmailTemplateActive$inboundSchema;
  ((EmailTemplateActive$) => {
    EmailTemplateActive$.inboundSchema = EmailTemplateActive$inboundSchema;
    EmailTemplateActive$.outboundSchema = EmailTemplateActive$outboundSchema;
  })(EmailTemplateActive$ ||= {});
  EmailTemplate$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: EmailTemplateActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    subject: stringType().optional(),
    message: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate"
    });
  });
  EmailTemplate$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: EmailTemplateActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    subject: stringType().optional(),
    message: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date"
    });
  });
  ((EmailTemplate$) => {
    EmailTemplate$.inboundSchema = EmailTemplate$inboundSchema;
    EmailTemplate$.outboundSchema = EmailTemplate$outboundSchema;
  })(EmailTemplate$ ||= {});
  EmailTemplateInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: EmailTemplateActive$inboundSchema.default(1),
    name: stringType(),
    subject: stringType().optional(),
    message: stringType().optional()
  });
  EmailTemplateInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: EmailTemplateActive$outboundSchema.default(1),
    name: stringType(),
    subject: stringType().optional(),
    message: stringType().optional()
  });
  ((EmailTemplateInput$) => {
    EmailTemplateInput$.inboundSchema = EmailTemplateInput$inboundSchema;
    EmailTemplateInput$.outboundSchema = EmailTemplateInput$outboundSchema;
  })(EmailTemplateInput$ ||= {});
});

// src/models/components/error.ts
var ErrorT$inboundSchema, ErrorT$outboundSchema, ErrorT$;
var init_error = __esm(() => {
  init_lib();
  ErrorT$inboundSchema = objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  });
  ErrorT$outboundSchema = objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  });
  ((ErrorT$) => {
    ErrorT$.inboundSchema = ErrorT$inboundSchema;
    ErrorT$.outboundSchema = ErrorT$outboundSchema;
  })(ErrorT$ ||= {});
});

// src/models/components/feedback.ts
var FeedbackActive, FeedbackActive$inboundSchema, FeedbackActive$outboundSchema, FeedbackActive$, Feedback$inboundSchema, Feedback$outboundSchema, Feedback$, FeedbackInput$inboundSchema, FeedbackInput$outboundSchema, FeedbackInput$;
var init_feedback = __esm(() => {
  init_lib();
  init_primitives();
  FeedbackActive = {
    Zero: 0,
    One: 1
  };
  FeedbackActive$inboundSchema = nativeEnumType(FeedbackActive);
  FeedbackActive$outboundSchema = FeedbackActive$inboundSchema;
  ((FeedbackActive$) => {
    FeedbackActive$.inboundSchema = FeedbackActive$inboundSchema;
    FeedbackActive$.outboundSchema = FeedbackActive$outboundSchema;
  })(FeedbackActive$ ||= {});
  Feedback$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FeedbackActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    timestamp: stringType().optional(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    rating: stringType().optional(),
    comment: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid"
    });
  });
  Feedback$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FeedbackActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    timestamp: stringType().optional(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    rating: stringType().optional(),
    comment: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid"
    });
  });
  ((Feedback$) => {
    Feedback$.inboundSchema = Feedback$inboundSchema;
    Feedback$.outboundSchema = Feedback$outboundSchema;
  })(Feedback$ ||= {});
  FeedbackInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FeedbackActive$inboundSchema.default(1),
    timestamp: stringType().optional(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    rating: stringType().optional(),
    comment: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid"
    });
  });
  FeedbackInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FeedbackActive$outboundSchema.default(1),
    timestamp: stringType().optional(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    rating: stringType().optional(),
    comment: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid"
    });
  });
  ((FeedbackInput$) => {
    FeedbackInput$.inboundSchema = FeedbackInput$inboundSchema;
    FeedbackInput$.outboundSchema = FeedbackInput$outboundSchema;
  })(FeedbackInput$ ||= {});
});

// src/models/components/form.ts
var FormActive, FormFieldType, FormActive$inboundSchema, FormActive$outboundSchema, FormActive$, FormFieldType$inboundSchema, FormFieldType$outboundSchema, FormFieldType$, TemplateField$inboundSchema, TemplateField$outboundSchema, TemplateField$, Form$inboundSchema, Form$outboundSchema, Form$, FormInput$inboundSchema, FormInput$outboundSchema, FormInput$;
var init_form = __esm(() => {
  init_lib();
  init_primitives();
  FormActive = {
    Zero: 0,
    One: 1
  };
  FormFieldType = {
    Text: "Text"
  };
  FormActive$inboundSchema = nativeEnumType(FormActive);
  FormActive$outboundSchema = FormActive$inboundSchema;
  ((FormActive$) => {
    FormActive$.inboundSchema = FormActive$inboundSchema;
    FormActive$.outboundSchema = FormActive$outboundSchema;
  })(FormActive$ ||= {});
  FormFieldType$inboundSchema = nativeEnumType(FormFieldType);
  FormFieldType$outboundSchema = FormFieldType$inboundSchema;
  ((FormFieldType$) => {
    FormFieldType$.inboundSchema = FormFieldType$inboundSchema;
    FormFieldType$.outboundSchema = FormFieldType$outboundSchema;
  })(FormFieldType$ ||= {});
  TemplateField$inboundSchema = objectType({
    name: stringType(),
    fieldType: FormFieldType$inboundSchema,
    value: stringType(),
    sortOrder: numberType().int()
  });
  TemplateField$outboundSchema = objectType({
    name: stringType(),
    fieldType: FormFieldType$outboundSchema,
    value: stringType(),
    sortOrder: numberType().int()
  });
  ((TemplateField$) => {
    TemplateField$.inboundSchema = TemplateField$inboundSchema;
    TemplateField$.outboundSchema = TemplateField$outboundSchema;
  })(TemplateField$ ||= {});
  Form$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType().optional(),
    document_template_uuid: stringType().optional(),
    can_be_used_independently: stringType().optional(),
    badge_mandatory_state: stringType().optional(),
    template_fields: arrayType(lazyType(() => TemplateField$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      document_template_uuid: "documentTemplateUuid",
      can_be_used_independently: "canBeUsedIndependently",
      badge_mandatory_state: "badgeMandatoryState",
      template_fields: "templateFields"
    });
  });
  Form$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType().optional(),
    documentTemplateUuid: stringType().optional(),
    canBeUsedIndependently: stringType().optional(),
    badgeMandatoryState: stringType().optional(),
    templateFields: arrayType(lazyType(() => TemplateField$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      documentTemplateUuid: "document_template_uuid",
      canBeUsedIndependently: "can_be_used_independently",
      badgeMandatoryState: "badge_mandatory_state",
      templateFields: "template_fields"
    });
  });
  ((Form$) => {
    Form$.inboundSchema = Form$inboundSchema;
    Form$.outboundSchema = Form$outboundSchema;
  })(Form$ ||= {});
  FormInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormActive$inboundSchema.default(1),
    name: stringType().optional(),
    document_template_uuid: stringType().optional(),
    can_be_used_independently: stringType().optional(),
    badge_mandatory_state: stringType().optional(),
    template_fields: arrayType(lazyType(() => TemplateField$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      document_template_uuid: "documentTemplateUuid",
      can_be_used_independently: "canBeUsedIndependently",
      badge_mandatory_state: "badgeMandatoryState",
      template_fields: "templateFields"
    });
  });
  FormInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormActive$outboundSchema.default(1),
    name: stringType().optional(),
    documentTemplateUuid: stringType().optional(),
    canBeUsedIndependently: stringType().optional(),
    badgeMandatoryState: stringType().optional(),
    templateFields: arrayType(lazyType(() => TemplateField$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      documentTemplateUuid: "document_template_uuid",
      canBeUsedIndependently: "can_be_used_independently",
      badgeMandatoryState: "badge_mandatory_state",
      templateFields: "template_fields"
    });
  });
  ((FormInput$) => {
    FormInput$.inboundSchema = FormInput$inboundSchema;
    FormInput$.outboundSchema = FormInput$outboundSchema;
  })(FormInput$ ||= {});
});

// src/models/components/formfield.ts
var FormFieldActive, FormFieldActive$inboundSchema, FormFieldActive$outboundSchema, FormFieldActive$, FormField$inboundSchema, FormField$outboundSchema, FormField$, FormFieldInput$inboundSchema, FormFieldInput$outboundSchema, FormFieldInput$;
var init_formfield = __esm(() => {
  init_lib();
  init_primitives();
  FormFieldActive = {
    Zero: 0,
    One: 1
  };
  FormFieldActive$inboundSchema = nativeEnumType(FormFieldActive);
  FormFieldActive$outboundSchema = FormFieldActive$inboundSchema;
  ((FormFieldActive$) => {
    FormFieldActive$.inboundSchema = FormFieldActive$inboundSchema;
    FormFieldActive$.outboundSchema = FormFieldActive$outboundSchema;
  })(FormFieldActive$ ||= {});
  FormField$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormFieldActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    form_uuid: stringType().optional(),
    name: stringType().optional(),
    field_data_json: stringType().optional(),
    sort_order: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      form_uuid: "formUuid",
      field_data_json: "fieldDataJson",
      sort_order: "sortOrder"
    });
  });
  FormField$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormFieldActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    formUuid: stringType().optional(),
    name: stringType().optional(),
    fieldDataJson: stringType().optional(),
    sortOrder: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      formUuid: "form_uuid",
      fieldDataJson: "field_data_json",
      sortOrder: "sort_order"
    });
  });
  ((FormField$) => {
    FormField$.inboundSchema = FormField$inboundSchema;
    FormField$.outboundSchema = FormField$outboundSchema;
  })(FormField$ ||= {});
  FormFieldInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormFieldActive$inboundSchema.default(1),
    form_uuid: stringType().optional(),
    name: stringType().optional(),
    field_data_json: stringType().optional(),
    sort_order: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      form_uuid: "formUuid",
      field_data_json: "fieldDataJson",
      sort_order: "sortOrder"
    });
  });
  FormFieldInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormFieldActive$outboundSchema.default(1),
    formUuid: stringType().optional(),
    name: stringType().optional(),
    fieldDataJson: stringType().optional(),
    sortOrder: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      formUuid: "form_uuid",
      fieldDataJson: "field_data_json",
      sortOrder: "sort_order"
    });
  });
  ((FormFieldInput$) => {
    FormFieldInput$.inboundSchema = FormFieldInput$inboundSchema;
    FormFieldInput$.outboundSchema = FormFieldInput$outboundSchema;
  })(FormFieldInput$ ||= {});
});

// src/models/components/formresponse.ts
var FormResponseActive, FormResponseActive$inboundSchema, FormResponseActive$outboundSchema, FormResponseActive$, FormResponse$inboundSchema, FormResponse$outboundSchema, FormResponse$, FormResponseInput$inboundSchema, FormResponseInput$outboundSchema, FormResponseInput$;
var init_formresponse = __esm(() => {
  init_lib();
  init_primitives();
  FormResponseActive = {
    Zero: 0,
    One: 1
  };
  FormResponseActive$inboundSchema = nativeEnumType(FormResponseActive);
  FormResponseActive$outboundSchema = FormResponseActive$inboundSchema;
  ((FormResponseActive$) => {
    FormResponseActive$.inboundSchema = FormResponseActive$inboundSchema;
    FormResponseActive$.outboundSchema = FormResponseActive$outboundSchema;
  })(FormResponseActive$ ||= {});
  FormResponse$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormResponseActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    form_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    regarding_object: stringType().optional(),
    regarding_object_uuid: stringType().optional(),
    field_data: stringType().optional(),
    timestamp: stringType().optional(),
    form_by_staff_uuid: stringType().optional(),
    document_attachment_uuid: stringType().optional(),
    asset_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      form_uuid: "formUuid",
      staff_uuid: "staffUuid",
      regarding_object: "regardingObject",
      regarding_object_uuid: "regardingObjectUuid",
      field_data: "fieldData",
      form_by_staff_uuid: "formByStaffUuid",
      document_attachment_uuid: "documentAttachmentUuid",
      asset_uuid: "assetUuid"
    });
  });
  FormResponse$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormResponseActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    formUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    regardingObject: stringType().optional(),
    regardingObjectUuid: stringType().optional(),
    fieldData: stringType().optional(),
    timestamp: stringType().optional(),
    formByStaffUuid: stringType().optional(),
    documentAttachmentUuid: stringType().optional(),
    assetUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      formUuid: "form_uuid",
      staffUuid: "staff_uuid",
      regardingObject: "regarding_object",
      regardingObjectUuid: "regarding_object_uuid",
      fieldData: "field_data",
      formByStaffUuid: "form_by_staff_uuid",
      documentAttachmentUuid: "document_attachment_uuid",
      assetUuid: "asset_uuid"
    });
  });
  ((FormResponse$) => {
    FormResponse$.inboundSchema = FormResponse$inboundSchema;
    FormResponse$.outboundSchema = FormResponse$outboundSchema;
  })(FormResponse$ ||= {});
  FormResponseInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormResponseActive$inboundSchema.default(1),
    form_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    regarding_object: stringType().optional(),
    regarding_object_uuid: stringType().optional(),
    field_data: stringType().optional(),
    timestamp: stringType().optional(),
    form_by_staff_uuid: stringType().optional(),
    document_attachment_uuid: stringType().optional(),
    asset_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      form_uuid: "formUuid",
      staff_uuid: "staffUuid",
      regarding_object: "regardingObject",
      regarding_object_uuid: "regardingObjectUuid",
      field_data: "fieldData",
      form_by_staff_uuid: "formByStaffUuid",
      document_attachment_uuid: "documentAttachmentUuid",
      asset_uuid: "assetUuid"
    });
  });
  FormResponseInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: FormResponseActive$outboundSchema.default(1),
    formUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    regardingObject: stringType().optional(),
    regardingObjectUuid: stringType().optional(),
    fieldData: stringType().optional(),
    timestamp: stringType().optional(),
    formByStaffUuid: stringType().optional(),
    documentAttachmentUuid: stringType().optional(),
    assetUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      formUuid: "form_uuid",
      staffUuid: "staff_uuid",
      regardingObject: "regarding_object",
      regardingObjectUuid: "regarding_object_uuid",
      fieldData: "field_data",
      formByStaffUuid: "form_by_staff_uuid",
      documentAttachmentUuid: "document_attachment_uuid",
      assetUuid: "asset_uuid"
    });
  });
  ((FormResponseInput$) => {
    FormResponseInput$.inboundSchema = FormResponseInput$inboundSchema;
    FormResponseInput$.outboundSchema = FormResponseInput$outboundSchema;
  })(FormResponseInput$ ||= {});
});

// src/models/components/job.ts
var JobActive, QuoteSent, JobActive$inboundSchema, JobActive$outboundSchema, JobActive$, QuoteSent$inboundSchema, QuoteSent$outboundSchema, QuoteSent$, RelatedKnowledgeArticle$inboundSchema, RelatedKnowledgeArticle$outboundSchema, RelatedKnowledgeArticle$, Job$inboundSchema, Job$outboundSchema, Job$, JobInput$inboundSchema, JobInput$outboundSchema, JobInput$;
var init_job = __esm(() => {
  init_lib();
  init_primitives();
  JobActive = {
    Zero: 0,
    One: 1
  };
  QuoteSent = {
    Zero: 0,
    One: 1
  };
  JobActive$inboundSchema = nativeEnumType(JobActive);
  JobActive$outboundSchema = JobActive$inboundSchema;
  ((JobActive$) => {
    JobActive$.inboundSchema = JobActive$inboundSchema;
    JobActive$.outboundSchema = JobActive$outboundSchema;
  })(JobActive$ ||= {});
  QuoteSent$inboundSchema = nativeEnumType(QuoteSent);
  QuoteSent$outboundSchema = QuoteSent$inboundSchema;
  ((QuoteSent$) => {
    QuoteSent$.inboundSchema = QuoteSent$inboundSchema;
    QuoteSent$.outboundSchema = QuoteSent$outboundSchema;
  })(QuoteSent$ ||= {});
  RelatedKnowledgeArticle$inboundSchema = objectType({
    knowledge_article_uuid: stringType(),
    relevance: numberType()
  }).transform((v2) => {
    return remap(v2, {
      knowledge_article_uuid: "knowledgeArticleUuid"
    });
  });
  RelatedKnowledgeArticle$outboundSchema = objectType({
    knowledgeArticleUuid: stringType(),
    relevance: numberType()
  }).transform((v2) => {
    return remap(v2, {
      knowledgeArticleUuid: "knowledge_article_uuid"
    });
  });
  ((RelatedKnowledgeArticle$) => {
    RelatedKnowledgeArticle$.inboundSchema = RelatedKnowledgeArticle$inboundSchema;
    RelatedKnowledgeArticle$.outboundSchema = RelatedKnowledgeArticle$outboundSchema;
  })(RelatedKnowledgeArticle$ ||= {});
  Job$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    created_by_staff_uuid: stringType().optional(),
    date: stringType().optional(),
    company_uuid: stringType().optional(),
    job_address: stringType().optional(),
    billing_address: stringType().optional(),
    status: stringType(),
    job_description: stringType().optional(),
    work_done_description: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    generated_job_id: stringType().optional(),
    payment_date: stringType().optional(),
    payment_actioned_by_uuid: stringType().optional(),
    payment_method: stringType().optional(),
    payment_amount: stringType().optional(),
    total_invoice_amount: stringType().optional(),
    category_uuid: stringType().optional(),
    payment_note: stringType().optional(),
    geo_is_valid: stringType().optional(),
    purchase_order_number: stringType().optional(),
    invoice_sent: stringType().optional(),
    invoice_sent_stamp: stringType().optional(),
    ready_to_invoice: stringType().optional(),
    ready_to_invoice_stamp: stringType().optional(),
    payment_processed: stringType().optional(),
    payment_processed_stamp: stringType().optional(),
    geo_country: stringType().optional(),
    geo_postcode: stringType().optional(),
    geo_state: stringType().optional(),
    geo_city: stringType().optional(),
    geo_street: stringType().optional(),
    geo_number: stringType().optional(),
    queue_uuid: stringType().optional(),
    queue_expiry_date: stringType().optional(),
    queue_assigned_staff_uuid: stringType().optional(),
    payment_received: stringType().optional(),
    payment_received_stamp: stringType().optional(),
    badges: stringType().optional(),
    quote_date: stringType().optional(),
    quote_sent: QuoteSent$inboundSchema.optional(),
    quote_sent_stamp: stringType().optional(),
    work_order_date: stringType().optional(),
    completion_date: stringType().optional(),
    completion_actioned_by_uuid: stringType().optional(),
    unsuccessful_date: stringType().optional(),
    job_is_scheduled_until_stamp: stringType().optional(),
    active_network_request_uuid: stringType().optional(),
    related_knowledge_articles: arrayType(lazyType(() => RelatedKnowledgeArticle$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      created_by_staff_uuid: "createdByStaffUuid",
      company_uuid: "companyUuid",
      job_address: "jobAddress",
      billing_address: "billingAddress",
      job_description: "jobDescription",
      work_done_description: "workDoneDescription",
      generated_job_id: "generatedJobId",
      payment_date: "paymentDate",
      payment_actioned_by_uuid: "paymentActionedByUuid",
      payment_method: "paymentMethod",
      payment_amount: "paymentAmount",
      total_invoice_amount: "totalInvoiceAmount",
      category_uuid: "categoryUuid",
      payment_note: "paymentNote",
      geo_is_valid: "geoIsValid",
      purchase_order_number: "purchaseOrderNumber",
      invoice_sent: "invoiceSent",
      invoice_sent_stamp: "invoiceSentStamp",
      ready_to_invoice: "readyToInvoice",
      ready_to_invoice_stamp: "readyToInvoiceStamp",
      payment_processed: "paymentProcessed",
      payment_processed_stamp: "paymentProcessedStamp",
      geo_country: "geoCountry",
      geo_postcode: "geoPostcode",
      geo_state: "geoState",
      geo_city: "geoCity",
      geo_street: "geoStreet",
      geo_number: "geoNumber",
      queue_uuid: "queueUuid",
      queue_expiry_date: "queueExpiryDate",
      queue_assigned_staff_uuid: "queueAssignedStaffUuid",
      payment_received: "paymentReceived",
      payment_received_stamp: "paymentReceivedStamp",
      quote_date: "quoteDate",
      quote_sent: "quoteSent",
      quote_sent_stamp: "quoteSentStamp",
      work_order_date: "workOrderDate",
      completion_date: "completionDate",
      completion_actioned_by_uuid: "completionActionedByUuid",
      unsuccessful_date: "unsuccessfulDate",
      job_is_scheduled_until_stamp: "jobIsScheduledUntilStamp",
      active_network_request_uuid: "activeNetworkRequestUuid",
      related_knowledge_articles: "relatedKnowledgeArticles"
    });
  });
  Job$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    createdByStaffUuid: stringType().optional(),
    date: stringType().optional(),
    companyUuid: stringType().optional(),
    jobAddress: stringType().optional(),
    billingAddress: stringType().optional(),
    status: stringType(),
    jobDescription: stringType().optional(),
    workDoneDescription: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    generatedJobId: stringType().optional(),
    paymentDate: stringType().optional(),
    paymentActionedByUuid: stringType().optional(),
    paymentMethod: stringType().optional(),
    paymentAmount: stringType().optional(),
    totalInvoiceAmount: stringType().optional(),
    categoryUuid: stringType().optional(),
    paymentNote: stringType().optional(),
    geoIsValid: stringType().optional(),
    purchaseOrderNumber: stringType().optional(),
    invoiceSent: stringType().optional(),
    invoiceSentStamp: stringType().optional(),
    readyToInvoice: stringType().optional(),
    readyToInvoiceStamp: stringType().optional(),
    paymentProcessed: stringType().optional(),
    paymentProcessedStamp: stringType().optional(),
    geoCountry: stringType().optional(),
    geoPostcode: stringType().optional(),
    geoState: stringType().optional(),
    geoCity: stringType().optional(),
    geoStreet: stringType().optional(),
    geoNumber: stringType().optional(),
    queueUuid: stringType().optional(),
    queueExpiryDate: stringType().optional(),
    queueAssignedStaffUuid: stringType().optional(),
    paymentReceived: stringType().optional(),
    paymentReceivedStamp: stringType().optional(),
    badges: stringType().optional(),
    quoteDate: stringType().optional(),
    quoteSent: QuoteSent$outboundSchema.optional(),
    quoteSentStamp: stringType().optional(),
    workOrderDate: stringType().optional(),
    completionDate: stringType().optional(),
    completionActionedByUuid: stringType().optional(),
    unsuccessfulDate: stringType().optional(),
    jobIsScheduledUntilStamp: stringType().optional(),
    activeNetworkRequestUuid: stringType().optional(),
    relatedKnowledgeArticles: arrayType(lazyType(() => RelatedKnowledgeArticle$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      createdByStaffUuid: "created_by_staff_uuid",
      companyUuid: "company_uuid",
      jobAddress: "job_address",
      billingAddress: "billing_address",
      jobDescription: "job_description",
      workDoneDescription: "work_done_description",
      generatedJobId: "generated_job_id",
      paymentDate: "payment_date",
      paymentActionedByUuid: "payment_actioned_by_uuid",
      paymentMethod: "payment_method",
      paymentAmount: "payment_amount",
      totalInvoiceAmount: "total_invoice_amount",
      categoryUuid: "category_uuid",
      paymentNote: "payment_note",
      geoIsValid: "geo_is_valid",
      purchaseOrderNumber: "purchase_order_number",
      invoiceSent: "invoice_sent",
      invoiceSentStamp: "invoice_sent_stamp",
      readyToInvoice: "ready_to_invoice",
      readyToInvoiceStamp: "ready_to_invoice_stamp",
      paymentProcessed: "payment_processed",
      paymentProcessedStamp: "payment_processed_stamp",
      geoCountry: "geo_country",
      geoPostcode: "geo_postcode",
      geoState: "geo_state",
      geoCity: "geo_city",
      geoStreet: "geo_street",
      geoNumber: "geo_number",
      queueUuid: "queue_uuid",
      queueExpiryDate: "queue_expiry_date",
      queueAssignedStaffUuid: "queue_assigned_staff_uuid",
      paymentReceived: "payment_received",
      paymentReceivedStamp: "payment_received_stamp",
      quoteDate: "quote_date",
      quoteSent: "quote_sent",
      quoteSentStamp: "quote_sent_stamp",
      workOrderDate: "work_order_date",
      completionDate: "completion_date",
      completionActionedByUuid: "completion_actioned_by_uuid",
      unsuccessfulDate: "unsuccessful_date",
      jobIsScheduledUntilStamp: "job_is_scheduled_until_stamp",
      activeNetworkRequestUuid: "active_network_request_uuid",
      relatedKnowledgeArticles: "related_knowledge_articles"
    });
  });
  ((Job$) => {
    Job$.inboundSchema = Job$inboundSchema;
    Job$.outboundSchema = Job$outboundSchema;
  })(Job$ ||= {});
  JobInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActive$inboundSchema.default(1),
    created_by_staff_uuid: stringType().optional(),
    date: stringType().optional(),
    company_uuid: stringType().optional(),
    job_address: stringType().optional(),
    billing_address: stringType().optional(),
    status: stringType(),
    job_description: stringType().optional(),
    work_done_description: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    generated_job_id: stringType().optional(),
    payment_date: stringType().optional(),
    payment_actioned_by_uuid: stringType().optional(),
    payment_method: stringType().optional(),
    payment_amount: stringType().optional(),
    total_invoice_amount: stringType().optional(),
    category_uuid: stringType().optional(),
    payment_note: stringType().optional(),
    geo_is_valid: stringType().optional(),
    purchase_order_number: stringType().optional(),
    invoice_sent: stringType().optional(),
    invoice_sent_stamp: stringType().optional(),
    ready_to_invoice: stringType().optional(),
    ready_to_invoice_stamp: stringType().optional(),
    payment_processed: stringType().optional(),
    payment_processed_stamp: stringType().optional(),
    geo_country: stringType().optional(),
    geo_postcode: stringType().optional(),
    geo_state: stringType().optional(),
    geo_city: stringType().optional(),
    geo_street: stringType().optional(),
    geo_number: stringType().optional(),
    queue_uuid: stringType().optional(),
    queue_expiry_date: stringType().optional(),
    queue_assigned_staff_uuid: stringType().optional(),
    payment_received: stringType().optional(),
    payment_received_stamp: stringType().optional(),
    badges: stringType().optional(),
    quote_date: stringType().optional(),
    quote_sent: QuoteSent$inboundSchema.optional(),
    quote_sent_stamp: stringType().optional(),
    work_order_date: stringType().optional(),
    completion_date: stringType().optional(),
    completion_actioned_by_uuid: stringType().optional(),
    unsuccessful_date: stringType().optional(),
    job_is_scheduled_until_stamp: stringType().optional(),
    active_network_request_uuid: stringType().optional(),
    related_knowledge_articles: arrayType(lazyType(() => RelatedKnowledgeArticle$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      created_by_staff_uuid: "createdByStaffUuid",
      company_uuid: "companyUuid",
      job_address: "jobAddress",
      billing_address: "billingAddress",
      job_description: "jobDescription",
      work_done_description: "workDoneDescription",
      generated_job_id: "generatedJobId",
      payment_date: "paymentDate",
      payment_actioned_by_uuid: "paymentActionedByUuid",
      payment_method: "paymentMethod",
      payment_amount: "paymentAmount",
      total_invoice_amount: "totalInvoiceAmount",
      category_uuid: "categoryUuid",
      payment_note: "paymentNote",
      geo_is_valid: "geoIsValid",
      purchase_order_number: "purchaseOrderNumber",
      invoice_sent: "invoiceSent",
      invoice_sent_stamp: "invoiceSentStamp",
      ready_to_invoice: "readyToInvoice",
      ready_to_invoice_stamp: "readyToInvoiceStamp",
      payment_processed: "paymentProcessed",
      payment_processed_stamp: "paymentProcessedStamp",
      geo_country: "geoCountry",
      geo_postcode: "geoPostcode",
      geo_state: "geoState",
      geo_city: "geoCity",
      geo_street: "geoStreet",
      geo_number: "geoNumber",
      queue_uuid: "queueUuid",
      queue_expiry_date: "queueExpiryDate",
      queue_assigned_staff_uuid: "queueAssignedStaffUuid",
      payment_received: "paymentReceived",
      payment_received_stamp: "paymentReceivedStamp",
      quote_date: "quoteDate",
      quote_sent: "quoteSent",
      quote_sent_stamp: "quoteSentStamp",
      work_order_date: "workOrderDate",
      completion_date: "completionDate",
      completion_actioned_by_uuid: "completionActionedByUuid",
      unsuccessful_date: "unsuccessfulDate",
      job_is_scheduled_until_stamp: "jobIsScheduledUntilStamp",
      active_network_request_uuid: "activeNetworkRequestUuid",
      related_knowledge_articles: "relatedKnowledgeArticles"
    });
  });
  JobInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActive$outboundSchema.default(1),
    createdByStaffUuid: stringType().optional(),
    date: stringType().optional(),
    companyUuid: stringType().optional(),
    jobAddress: stringType().optional(),
    billingAddress: stringType().optional(),
    status: stringType(),
    jobDescription: stringType().optional(),
    workDoneDescription: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    generatedJobId: stringType().optional(),
    paymentDate: stringType().optional(),
    paymentActionedByUuid: stringType().optional(),
    paymentMethod: stringType().optional(),
    paymentAmount: stringType().optional(),
    totalInvoiceAmount: stringType().optional(),
    categoryUuid: stringType().optional(),
    paymentNote: stringType().optional(),
    geoIsValid: stringType().optional(),
    purchaseOrderNumber: stringType().optional(),
    invoiceSent: stringType().optional(),
    invoiceSentStamp: stringType().optional(),
    readyToInvoice: stringType().optional(),
    readyToInvoiceStamp: stringType().optional(),
    paymentProcessed: stringType().optional(),
    paymentProcessedStamp: stringType().optional(),
    geoCountry: stringType().optional(),
    geoPostcode: stringType().optional(),
    geoState: stringType().optional(),
    geoCity: stringType().optional(),
    geoStreet: stringType().optional(),
    geoNumber: stringType().optional(),
    queueUuid: stringType().optional(),
    queueExpiryDate: stringType().optional(),
    queueAssignedStaffUuid: stringType().optional(),
    paymentReceived: stringType().optional(),
    paymentReceivedStamp: stringType().optional(),
    badges: stringType().optional(),
    quoteDate: stringType().optional(),
    quoteSent: QuoteSent$outboundSchema.optional(),
    quoteSentStamp: stringType().optional(),
    workOrderDate: stringType().optional(),
    completionDate: stringType().optional(),
    completionActionedByUuid: stringType().optional(),
    unsuccessfulDate: stringType().optional(),
    jobIsScheduledUntilStamp: stringType().optional(),
    activeNetworkRequestUuid: stringType().optional(),
    relatedKnowledgeArticles: arrayType(lazyType(() => RelatedKnowledgeArticle$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      createdByStaffUuid: "created_by_staff_uuid",
      companyUuid: "company_uuid",
      jobAddress: "job_address",
      billingAddress: "billing_address",
      jobDescription: "job_description",
      workDoneDescription: "work_done_description",
      generatedJobId: "generated_job_id",
      paymentDate: "payment_date",
      paymentActionedByUuid: "payment_actioned_by_uuid",
      paymentMethod: "payment_method",
      paymentAmount: "payment_amount",
      totalInvoiceAmount: "total_invoice_amount",
      categoryUuid: "category_uuid",
      paymentNote: "payment_note",
      geoIsValid: "geo_is_valid",
      purchaseOrderNumber: "purchase_order_number",
      invoiceSent: "invoice_sent",
      invoiceSentStamp: "invoice_sent_stamp",
      readyToInvoice: "ready_to_invoice",
      readyToInvoiceStamp: "ready_to_invoice_stamp",
      paymentProcessed: "payment_processed",
      paymentProcessedStamp: "payment_processed_stamp",
      geoCountry: "geo_country",
      geoPostcode: "geo_postcode",
      geoState: "geo_state",
      geoCity: "geo_city",
      geoStreet: "geo_street",
      geoNumber: "geo_number",
      queueUuid: "queue_uuid",
      queueExpiryDate: "queue_expiry_date",
      queueAssignedStaffUuid: "queue_assigned_staff_uuid",
      paymentReceived: "payment_received",
      paymentReceivedStamp: "payment_received_stamp",
      quoteDate: "quote_date",
      quoteSent: "quote_sent",
      quoteSentStamp: "quote_sent_stamp",
      workOrderDate: "work_order_date",
      completionDate: "completion_date",
      completionActionedByUuid: "completion_actioned_by_uuid",
      unsuccessfulDate: "unsuccessful_date",
      jobIsScheduledUntilStamp: "job_is_scheduled_until_stamp",
      activeNetworkRequestUuid: "active_network_request_uuid",
      relatedKnowledgeArticles: "related_knowledge_articles"
    });
  });
  ((JobInput$) => {
    JobInput$.inboundSchema = JobInput$inboundSchema;
    JobInput$.outboundSchema = JobInput$outboundSchema;
  })(JobInput$ ||= {});
});

// src/models/components/jobactivity.ts
var JobActivityActive, JobActivityActive$inboundSchema, JobActivityActive$outboundSchema, JobActivityActive$, JobActivity$inboundSchema, JobActivity$outboundSchema, JobActivity$, JobActivityInput$inboundSchema, JobActivityInput$outboundSchema, JobActivityInput$;
var init_jobactivity = __esm(() => {
  init_lib();
  init_primitives();
  JobActivityActive = {
    Zero: 0,
    One: 1
  };
  JobActivityActive$inboundSchema = nativeEnumType(JobActivityActive);
  JobActivityActive$outboundSchema = JobActivityActive$inboundSchema;
  ((JobActivityActive$) => {
    JobActivityActive$.inboundSchema = JobActivityActive$inboundSchema;
    JobActivityActive$.outboundSchema = JobActivityActive$outboundSchema;
  })(JobActivityActive$ ||= {});
  JobActivity$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActivityActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    start_date: stringType().optional(),
    end_date: stringType().optional(),
    activity_was_scheduled: stringType().optional(),
    activity_was_recorded: stringType().optional(),
    activity_was_automated: stringType().optional(),
    has_been_opened: stringType().optional(),
    has_been_opened_timestamp: stringType().optional(),
    travel_time_in_seconds: stringType().optional(),
    travel_distance_in_meters: stringType().optional(),
    allocated_by_staff_uuid: stringType().optional(),
    allocated_timestamp: stringType().optional(),
    material_uuid: stringType().optional(),
    edit_by_staff_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      staff_uuid: "staffUuid",
      start_date: "startDate",
      end_date: "endDate",
      activity_was_scheduled: "activityWasScheduled",
      activity_was_recorded: "activityWasRecorded",
      activity_was_automated: "activityWasAutomated",
      has_been_opened: "hasBeenOpened",
      has_been_opened_timestamp: "hasBeenOpenedTimestamp",
      travel_time_in_seconds: "travelTimeInSeconds",
      travel_distance_in_meters: "travelDistanceInMeters",
      allocated_by_staff_uuid: "allocatedByStaffUuid",
      allocated_timestamp: "allocatedTimestamp",
      material_uuid: "materialUuid",
      edit_by_staff_uuid: "editByStaffUuid"
    });
  });
  JobActivity$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActivityActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    startDate: stringType().optional(),
    endDate: stringType().optional(),
    activityWasScheduled: stringType().optional(),
    activityWasRecorded: stringType().optional(),
    activityWasAutomated: stringType().optional(),
    hasBeenOpened: stringType().optional(),
    hasBeenOpenedTimestamp: stringType().optional(),
    travelTimeInSeconds: stringType().optional(),
    travelDistanceInMeters: stringType().optional(),
    allocatedByStaffUuid: stringType().optional(),
    allocatedTimestamp: stringType().optional(),
    materialUuid: stringType().optional(),
    editByStaffUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      staffUuid: "staff_uuid",
      startDate: "start_date",
      endDate: "end_date",
      activityWasScheduled: "activity_was_scheduled",
      activityWasRecorded: "activity_was_recorded",
      activityWasAutomated: "activity_was_automated",
      hasBeenOpened: "has_been_opened",
      hasBeenOpenedTimestamp: "has_been_opened_timestamp",
      travelTimeInSeconds: "travel_time_in_seconds",
      travelDistanceInMeters: "travel_distance_in_meters",
      allocatedByStaffUuid: "allocated_by_staff_uuid",
      allocatedTimestamp: "allocated_timestamp",
      materialUuid: "material_uuid",
      editByStaffUuid: "edit_by_staff_uuid"
    });
  });
  ((JobActivity$) => {
    JobActivity$.inboundSchema = JobActivity$inboundSchema;
    JobActivity$.outboundSchema = JobActivity$outboundSchema;
  })(JobActivity$ ||= {});
  JobActivityInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActivityActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    start_date: stringType().optional(),
    end_date: stringType().optional(),
    activity_was_scheduled: stringType().optional(),
    activity_was_recorded: stringType().optional(),
    activity_was_automated: stringType().optional(),
    has_been_opened: stringType().optional(),
    has_been_opened_timestamp: stringType().optional(),
    travel_time_in_seconds: stringType().optional(),
    travel_distance_in_meters: stringType().optional(),
    allocated_by_staff_uuid: stringType().optional(),
    allocated_timestamp: stringType().optional(),
    material_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      staff_uuid: "staffUuid",
      start_date: "startDate",
      end_date: "endDate",
      activity_was_scheduled: "activityWasScheduled",
      activity_was_recorded: "activityWasRecorded",
      activity_was_automated: "activityWasAutomated",
      has_been_opened: "hasBeenOpened",
      has_been_opened_timestamp: "hasBeenOpenedTimestamp",
      travel_time_in_seconds: "travelTimeInSeconds",
      travel_distance_in_meters: "travelDistanceInMeters",
      allocated_by_staff_uuid: "allocatedByStaffUuid",
      allocated_timestamp: "allocatedTimestamp",
      material_uuid: "materialUuid"
    });
  });
  JobActivityInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobActivityActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    startDate: stringType().optional(),
    endDate: stringType().optional(),
    activityWasScheduled: stringType().optional(),
    activityWasRecorded: stringType().optional(),
    activityWasAutomated: stringType().optional(),
    hasBeenOpened: stringType().optional(),
    hasBeenOpenedTimestamp: stringType().optional(),
    travelTimeInSeconds: stringType().optional(),
    travelDistanceInMeters: stringType().optional(),
    allocatedByStaffUuid: stringType().optional(),
    allocatedTimestamp: stringType().optional(),
    materialUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      staffUuid: "staff_uuid",
      startDate: "start_date",
      endDate: "end_date",
      activityWasScheduled: "activity_was_scheduled",
      activityWasRecorded: "activity_was_recorded",
      activityWasAutomated: "activity_was_automated",
      hasBeenOpened: "has_been_opened",
      hasBeenOpenedTimestamp: "has_been_opened_timestamp",
      travelTimeInSeconds: "travel_time_in_seconds",
      travelDistanceInMeters: "travel_distance_in_meters",
      allocatedByStaffUuid: "allocated_by_staff_uuid",
      allocatedTimestamp: "allocated_timestamp",
      materialUuid: "material_uuid"
    });
  });
  ((JobActivityInput$) => {
    JobActivityInput$.inboundSchema = JobActivityInput$inboundSchema;
    JobActivityInput$.outboundSchema = JobActivityInput$outboundSchema;
  })(JobActivityInput$ ||= {});
});

// src/models/components/joballocation.ts
var JobAllocationActive, JobAllocationActive$inboundSchema, JobAllocationActive$outboundSchema, JobAllocationActive$, JobAllocation$inboundSchema, JobAllocation$outboundSchema, JobAllocation$, JobAllocationInput$inboundSchema, JobAllocationInput$outboundSchema, JobAllocationInput$;
var init_joballocation = __esm(() => {
  init_lib();
  init_primitives();
  JobAllocationActive = {
    Zero: 0,
    One: 1
  };
  JobAllocationActive$inboundSchema = nativeEnumType(JobAllocationActive);
  JobAllocationActive$outboundSchema = JobAllocationActive$inboundSchema;
  ((JobAllocationActive$) => {
    JobAllocationActive$.inboundSchema = JobAllocationActive$inboundSchema;
    JobAllocationActive$.outboundSchema = JobAllocationActive$outboundSchema;
  })(JobAllocationActive$ ||= {});
  JobAllocation$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobAllocationActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    queue_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    allocation_date: stringType().optional(),
    allocation_window_uuid: stringType().optional(),
    allocated_by_staff_uuid: stringType().optional(),
    allocated_timestamp: stringType().optional(),
    expiry_timestamp: stringType().optional(),
    read_timestamp: stringType().optional(),
    completion_timestamp: stringType().optional(),
    estimated_duration: stringType().optional(),
    revised_duration: stringType().optional(),
    sort_priority: stringType().optional(),
    requires_acceptance: stringType().optional(),
    acceptance_status: stringType().optional(),
    acceptance_timestamp: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      queue_uuid: "queueUuid",
      staff_uuid: "staffUuid",
      allocation_date: "allocationDate",
      allocation_window_uuid: "allocationWindowUuid",
      allocated_by_staff_uuid: "allocatedByStaffUuid",
      allocated_timestamp: "allocatedTimestamp",
      expiry_timestamp: "expiryTimestamp",
      read_timestamp: "readTimestamp",
      completion_timestamp: "completionTimestamp",
      estimated_duration: "estimatedDuration",
      revised_duration: "revisedDuration",
      sort_priority: "sortPriority",
      requires_acceptance: "requiresAcceptance",
      acceptance_status: "acceptanceStatus",
      acceptance_timestamp: "acceptanceTimestamp"
    });
  });
  JobAllocation$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobAllocationActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    queueUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    allocationDate: stringType().optional(),
    allocationWindowUuid: stringType().optional(),
    allocatedByStaffUuid: stringType().optional(),
    allocatedTimestamp: stringType().optional(),
    expiryTimestamp: stringType().optional(),
    readTimestamp: stringType().optional(),
    completionTimestamp: stringType().optional(),
    estimatedDuration: stringType().optional(),
    revisedDuration: stringType().optional(),
    sortPriority: stringType().optional(),
    requiresAcceptance: stringType().optional(),
    acceptanceStatus: stringType().optional(),
    acceptanceTimestamp: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      queueUuid: "queue_uuid",
      staffUuid: "staff_uuid",
      allocationDate: "allocation_date",
      allocationWindowUuid: "allocation_window_uuid",
      allocatedByStaffUuid: "allocated_by_staff_uuid",
      allocatedTimestamp: "allocated_timestamp",
      expiryTimestamp: "expiry_timestamp",
      readTimestamp: "read_timestamp",
      completionTimestamp: "completion_timestamp",
      estimatedDuration: "estimated_duration",
      revisedDuration: "revised_duration",
      sortPriority: "sort_priority",
      requiresAcceptance: "requires_acceptance",
      acceptanceStatus: "acceptance_status",
      acceptanceTimestamp: "acceptance_timestamp"
    });
  });
  ((JobAllocation$) => {
    JobAllocation$.inboundSchema = JobAllocation$inboundSchema;
    JobAllocation$.outboundSchema = JobAllocation$outboundSchema;
  })(JobAllocation$ ||= {});
  JobAllocationInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobAllocationActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    queue_uuid: stringType().optional(),
    staff_uuid: stringType().optional(),
    allocation_date: stringType().optional(),
    allocation_window_uuid: stringType().optional(),
    allocated_by_staff_uuid: stringType().optional(),
    allocated_timestamp: stringType().optional(),
    expiry_timestamp: stringType().optional(),
    read_timestamp: stringType().optional(),
    completion_timestamp: stringType().optional(),
    estimated_duration: stringType().optional(),
    revised_duration: stringType().optional(),
    sort_priority: stringType().optional(),
    requires_acceptance: stringType().optional(),
    acceptance_status: stringType().optional(),
    acceptance_timestamp: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      queue_uuid: "queueUuid",
      staff_uuid: "staffUuid",
      allocation_date: "allocationDate",
      allocation_window_uuid: "allocationWindowUuid",
      allocated_by_staff_uuid: "allocatedByStaffUuid",
      allocated_timestamp: "allocatedTimestamp",
      expiry_timestamp: "expiryTimestamp",
      read_timestamp: "readTimestamp",
      completion_timestamp: "completionTimestamp",
      estimated_duration: "estimatedDuration",
      revised_duration: "revisedDuration",
      sort_priority: "sortPriority",
      requires_acceptance: "requiresAcceptance",
      acceptance_status: "acceptanceStatus",
      acceptance_timestamp: "acceptanceTimestamp"
    });
  });
  JobAllocationInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobAllocationActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    queueUuid: stringType().optional(),
    staffUuid: stringType().optional(),
    allocationDate: stringType().optional(),
    allocationWindowUuid: stringType().optional(),
    allocatedByStaffUuid: stringType().optional(),
    allocatedTimestamp: stringType().optional(),
    expiryTimestamp: stringType().optional(),
    readTimestamp: stringType().optional(),
    completionTimestamp: stringType().optional(),
    estimatedDuration: stringType().optional(),
    revisedDuration: stringType().optional(),
    sortPriority: stringType().optional(),
    requiresAcceptance: stringType().optional(),
    acceptanceStatus: stringType().optional(),
    acceptanceTimestamp: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      queueUuid: "queue_uuid",
      staffUuid: "staff_uuid",
      allocationDate: "allocation_date",
      allocationWindowUuid: "allocation_window_uuid",
      allocatedByStaffUuid: "allocated_by_staff_uuid",
      allocatedTimestamp: "allocated_timestamp",
      expiryTimestamp: "expiry_timestamp",
      readTimestamp: "read_timestamp",
      completionTimestamp: "completion_timestamp",
      estimatedDuration: "estimated_duration",
      revisedDuration: "revised_duration",
      sortPriority: "sort_priority",
      requiresAcceptance: "requires_acceptance",
      acceptanceStatus: "acceptance_status",
      acceptanceTimestamp: "acceptance_timestamp"
    });
  });
  ((JobAllocationInput$) => {
    JobAllocationInput$.inboundSchema = JobAllocationInput$inboundSchema;
    JobAllocationInput$.outboundSchema = JobAllocationInput$outboundSchema;
  })(JobAllocationInput$ ||= {});
});

// src/models/components/jobchecklist.ts
var JobChecklistActive, IsLocked, JobChecklistActive$inboundSchema, JobChecklistActive$outboundSchema, JobChecklistActive$, ReminderData2$inboundSchema, ReminderData2$outboundSchema, ReminderData2$, ReminderDataUnion2$inboundSchema, ReminderDataUnion2$outboundSchema, ReminderDataUnion2$, ReminderData1$inboundSchema, ReminderData1$outboundSchema, ReminderData1$, ReminderDataUnion1$inboundSchema, ReminderDataUnion1$outboundSchema, ReminderDataUnion1$, ReminderDataUnion3$inboundSchema, ReminderDataUnion3$outboundSchema, ReminderDataUnion3$, IsLocked$inboundSchema, IsLocked$outboundSchema, IsLocked$, JobChecklist$inboundSchema, JobChecklist$outboundSchema, JobChecklist$, JobChecklistInput$inboundSchema, JobChecklistInput$outboundSchema, JobChecklistInput$;
var init_jobchecklist = __esm(() => {
  init_lib();
  init_primitives();
  JobChecklistActive = {
    Zero: 0,
    One: 1
  };
  IsLocked = {
    Zero: 0,
    One: 1
  };
  JobChecklistActive$inboundSchema = nativeEnumType(JobChecklistActive);
  JobChecklistActive$outboundSchema = JobChecklistActive$inboundSchema;
  ((JobChecklistActive$) => {
    JobChecklistActive$.inboundSchema = JobChecklistActive$inboundSchema;
    JobChecklistActive$.outboundSchema = JobChecklistActive$outboundSchema;
  })(JobChecklistActive$ ||= {});
  ReminderData2$inboundSchema = objectType({});
  ReminderData2$outboundSchema = objectType({});
  ((ReminderData2$) => {
    ReminderData2$.inboundSchema = ReminderData2$inboundSchema;
    ReminderData2$.outboundSchema = ReminderData2$outboundSchema;
  })(ReminderData2$ ||= {});
  ReminderDataUnion2$inboundSchema = unionType([lazyType(() => ReminderData2$inboundSchema), stringType()]);
  ReminderDataUnion2$outboundSchema = unionType([lazyType(() => ReminderData2$outboundSchema), stringType()]);
  ((ReminderDataUnion2$) => {
    ReminderDataUnion2$.inboundSchema = ReminderDataUnion2$inboundSchema;
    ReminderDataUnion2$.outboundSchema = ReminderDataUnion2$outboundSchema;
  })(ReminderDataUnion2$ ||= {});
  ReminderData1$inboundSchema = objectType({});
  ReminderData1$outboundSchema = objectType({});
  ((ReminderData1$) => {
    ReminderData1$.inboundSchema = ReminderData1$inboundSchema;
    ReminderData1$.outboundSchema = ReminderData1$outboundSchema;
  })(ReminderData1$ ||= {});
  ReminderDataUnion1$inboundSchema = unionType([lazyType(() => ReminderData1$inboundSchema), stringType()]);
  ReminderDataUnion1$outboundSchema = unionType([lazyType(() => ReminderData1$outboundSchema), stringType()]);
  ((ReminderDataUnion1$) => {
    ReminderDataUnion1$.inboundSchema = ReminderDataUnion1$inboundSchema;
    ReminderDataUnion1$.outboundSchema = ReminderDataUnion1$outboundSchema;
  })(ReminderDataUnion1$ ||= {});
  ReminderDataUnion3$inboundSchema = unionType([
    unionType([lazyType(() => ReminderData1$inboundSchema), stringType()]),
    unionType([lazyType(() => ReminderData2$inboundSchema), stringType()])
  ]);
  ReminderDataUnion3$outboundSchema = unionType([
    unionType([lazyType(() => ReminderData1$outboundSchema), stringType()]),
    unionType([lazyType(() => ReminderData2$outboundSchema), stringType()])
  ]);
  ((ReminderDataUnion3$) => {
    ReminderDataUnion3$.inboundSchema = ReminderDataUnion3$inboundSchema;
    ReminderDataUnion3$.outboundSchema = ReminderDataUnion3$outboundSchema;
  })(ReminderDataUnion3$ ||= {});
  IsLocked$inboundSchema = nativeEnumType(IsLocked);
  IsLocked$outboundSchema = IsLocked$inboundSchema;
  ((IsLocked$) => {
    IsLocked$.inboundSchema = IsLocked$inboundSchema;
    IsLocked$.outboundSchema = IsLocked$outboundSchema;
  })(IsLocked$ ||= {});
  JobChecklist$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobChecklistActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    name: stringType().optional(),
    section_name: stringType().optional(),
    item_type: stringType().optional(),
    sort_order: numberType().int().optional(),
    completed_timestamp: stringType().optional(),
    completed_by_staff_uuid: stringType().optional(),
    completed_during_checkin_uuid: stringType().optional(),
    reminder_type: stringType().optional(),
    reminder_data: unionType([
      unionType([lazyType(() => ReminderData1$inboundSchema), stringType()]),
      unionType([lazyType(() => ReminderData2$inboundSchema), stringType()])
    ]).optional(),
    regarding_object: stringType().optional(),
    regarding_object_uuid: stringType().optional(),
    fulfilled_by_object_name: stringType().optional(),
    fulfilled_by_object_uuid: stringType().optional(),
    assigned_to_staff_uuids: arrayType(stringType()).optional(),
    is_locked: IsLocked$inboundSchema.optional(),
    assigned_timestamp: stringType().optional(),
    assigned_by_staff_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      section_name: "sectionName",
      item_type: "itemType",
      sort_order: "sortOrder",
      completed_timestamp: "completedTimestamp",
      completed_by_staff_uuid: "completedByStaffUuid",
      completed_during_checkin_uuid: "completedDuringCheckinUuid",
      reminder_type: "reminderType",
      reminder_data: "reminderData",
      regarding_object: "regardingObject",
      regarding_object_uuid: "regardingObjectUuid",
      fulfilled_by_object_name: "fulfilledByObjectName",
      fulfilled_by_object_uuid: "fulfilledByObjectUuid",
      assigned_to_staff_uuids: "assignedToStaffUuids",
      is_locked: "isLocked",
      assigned_timestamp: "assignedTimestamp",
      assigned_by_staff_uuid: "assignedByStaffUuid"
    });
  });
  JobChecklist$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobChecklistActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    name: stringType().optional(),
    sectionName: stringType().optional(),
    itemType: stringType().optional(),
    sortOrder: numberType().int().optional(),
    completedTimestamp: stringType().optional(),
    completedByStaffUuid: stringType().optional(),
    completedDuringCheckinUuid: stringType().optional(),
    reminderType: stringType().optional(),
    reminderData: unionType([
      unionType([lazyType(() => ReminderData1$outboundSchema), stringType()]),
      unionType([lazyType(() => ReminderData2$outboundSchema), stringType()])
    ]).optional(),
    regardingObject: stringType().optional(),
    regardingObjectUuid: stringType().optional(),
    fulfilledByObjectName: stringType().optional(),
    fulfilledByObjectUuid: stringType().optional(),
    assignedToStaffUuids: arrayType(stringType()).optional(),
    isLocked: IsLocked$outboundSchema.optional(),
    assignedTimestamp: stringType().optional(),
    assignedByStaffUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      sectionName: "section_name",
      itemType: "item_type",
      sortOrder: "sort_order",
      completedTimestamp: "completed_timestamp",
      completedByStaffUuid: "completed_by_staff_uuid",
      completedDuringCheckinUuid: "completed_during_checkin_uuid",
      reminderType: "reminder_type",
      reminderData: "reminder_data",
      regardingObject: "regarding_object",
      regardingObjectUuid: "regarding_object_uuid",
      fulfilledByObjectName: "fulfilled_by_object_name",
      fulfilledByObjectUuid: "fulfilled_by_object_uuid",
      assignedToStaffUuids: "assigned_to_staff_uuids",
      isLocked: "is_locked",
      assignedTimestamp: "assigned_timestamp",
      assignedByStaffUuid: "assigned_by_staff_uuid"
    });
  });
  ((JobChecklist$) => {
    JobChecklist$.inboundSchema = JobChecklist$inboundSchema;
    JobChecklist$.outboundSchema = JobChecklist$outboundSchema;
  })(JobChecklist$ ||= {});
  JobChecklistInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobChecklistActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    name: stringType().optional(),
    section_name: stringType().optional(),
    item_type: stringType().optional(),
    sort_order: numberType().int().optional(),
    completed_timestamp: stringType().optional(),
    completed_by_staff_uuid: stringType().optional(),
    completed_during_checkin_uuid: stringType().optional(),
    reminder_type: stringType().optional(),
    reminder_data: unionType([
      unionType([lazyType(() => ReminderData1$inboundSchema), stringType()]),
      unionType([lazyType(() => ReminderData2$inboundSchema), stringType()])
    ]).optional(),
    regarding_object: stringType().optional(),
    regarding_object_uuid: stringType().optional(),
    fulfilled_by_object_name: stringType().optional(),
    fulfilled_by_object_uuid: stringType().optional(),
    assigned_to_staff_uuids: arrayType(stringType()).optional(),
    is_locked: IsLocked$inboundSchema.optional(),
    assigned_timestamp: stringType().optional(),
    assigned_by_staff_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      section_name: "sectionName",
      item_type: "itemType",
      sort_order: "sortOrder",
      completed_timestamp: "completedTimestamp",
      completed_by_staff_uuid: "completedByStaffUuid",
      completed_during_checkin_uuid: "completedDuringCheckinUuid",
      reminder_type: "reminderType",
      reminder_data: "reminderData",
      regarding_object: "regardingObject",
      regarding_object_uuid: "regardingObjectUuid",
      fulfilled_by_object_name: "fulfilledByObjectName",
      fulfilled_by_object_uuid: "fulfilledByObjectUuid",
      assigned_to_staff_uuids: "assignedToStaffUuids",
      is_locked: "isLocked",
      assigned_timestamp: "assignedTimestamp",
      assigned_by_staff_uuid: "assignedByStaffUuid"
    });
  });
  JobChecklistInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobChecklistActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    name: stringType().optional(),
    sectionName: stringType().optional(),
    itemType: stringType().optional(),
    sortOrder: numberType().int().optional(),
    completedTimestamp: stringType().optional(),
    completedByStaffUuid: stringType().optional(),
    completedDuringCheckinUuid: stringType().optional(),
    reminderType: stringType().optional(),
    reminderData: unionType([
      unionType([lazyType(() => ReminderData1$outboundSchema), stringType()]),
      unionType([lazyType(() => ReminderData2$outboundSchema), stringType()])
    ]).optional(),
    regardingObject: stringType().optional(),
    regardingObjectUuid: stringType().optional(),
    fulfilledByObjectName: stringType().optional(),
    fulfilledByObjectUuid: stringType().optional(),
    assignedToStaffUuids: arrayType(stringType()).optional(),
    isLocked: IsLocked$outboundSchema.optional(),
    assignedTimestamp: stringType().optional(),
    assignedByStaffUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      sectionName: "section_name",
      itemType: "item_type",
      sortOrder: "sort_order",
      completedTimestamp: "completed_timestamp",
      completedByStaffUuid: "completed_by_staff_uuid",
      completedDuringCheckinUuid: "completed_during_checkin_uuid",
      reminderType: "reminder_type",
      reminderData: "reminder_data",
      regardingObject: "regarding_object",
      regardingObjectUuid: "regarding_object_uuid",
      fulfilledByObjectName: "fulfilled_by_object_name",
      fulfilledByObjectUuid: "fulfilled_by_object_uuid",
      assignedToStaffUuids: "assigned_to_staff_uuids",
      isLocked: "is_locked",
      assignedTimestamp: "assigned_timestamp",
      assignedByStaffUuid: "assigned_by_staff_uuid"
    });
  });
  ((JobChecklistInput$) => {
    JobChecklistInput$.inboundSchema = JobChecklistInput$inboundSchema;
    JobChecklistInput$.outboundSchema = JobChecklistInput$outboundSchema;
  })(JobChecklistInput$ ||= {});
});

// src/models/components/jobcontact.ts
var JobContactActive, JobContactActive$inboundSchema, JobContactActive$outboundSchema, JobContactActive$, JobContact$inboundSchema, JobContact$outboundSchema, JobContact$, JobContactInput$inboundSchema, JobContactInput$outboundSchema, JobContactInput$;
var init_jobcontact = __esm(() => {
  init_lib();
  init_primitives();
  JobContactActive = {
    Zero: 0,
    One: 1
  };
  JobContactActive$inboundSchema = nativeEnumType(JobContactActive);
  JobContactActive$outboundSchema = JobContactActive$inboundSchema;
  ((JobContactActive$) => {
    JobContactActive$.inboundSchema = JobContactActive$inboundSchema;
    JobContactActive$.outboundSchema = JobContactActive$outboundSchema;
  })(JobContactActive$ ||= {});
  JobContact$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobContactActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    is_primary_contact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      is_primary_contact: "isPrimaryContact"
    });
  });
  JobContact$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobContactActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    isPrimaryContact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      isPrimaryContact: "is_primary_contact"
    });
  });
  ((JobContact$) => {
    JobContact$.inboundSchema = JobContact$inboundSchema;
    JobContact$.outboundSchema = JobContact$outboundSchema;
  })(JobContact$ ||= {});
  JobContactInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobContactActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    is_primary_contact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      is_primary_contact: "isPrimaryContact"
    });
  });
  JobContactInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobContactActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    first: stringType().optional(),
    last: stringType().optional(),
    phone: stringType().optional(),
    mobile: stringType().optional(),
    email: stringType().optional(),
    type: stringType().optional(),
    isPrimaryContact: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      isPrimaryContact: "is_primary_contact"
    });
  });
  ((JobContactInput$) => {
    JobContactInput$.inboundSchema = JobContactInput$inboundSchema;
    JobContactInput$.outboundSchema = JobContactInput$outboundSchema;
  })(JobContactInput$ ||= {});
});

// src/models/components/jobmaterial.ts
var JobMaterialActive, JobMaterialActive$inboundSchema, JobMaterialActive$outboundSchema, JobMaterialActive$, JobMaterial$inboundSchema, JobMaterial$outboundSchema, JobMaterial$, JobMaterialInput$inboundSchema, JobMaterialInput$outboundSchema, JobMaterialInput$;
var init_jobmaterial = __esm(() => {
  init_lib();
  init_primitives();
  JobMaterialActive = {
    Zero: 0,
    One: 1
  };
  JobMaterialActive$inboundSchema = nativeEnumType(JobMaterialActive);
  JobMaterialActive$outboundSchema = JobMaterialActive$inboundSchema;
  ((JobMaterialActive$) => {
    JobMaterialActive$.inboundSchema = JobMaterialActive$inboundSchema;
    JobMaterialActive$.outboundSchema = JobMaterialActive$outboundSchema;
  })(JobMaterialActive$ ||= {});
  JobMaterial$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    material_uuid: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType(),
    price: stringType().optional(),
    displayed_amount: stringType().optional(),
    displayed_amount_is_tax_inclusive: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    sort_order: stringType().optional(),
    cost: stringType().optional(),
    displayed_cost: stringType().optional(),
    job_material_bundle_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      material_uuid: "materialUuid",
      displayed_amount: "displayedAmount",
      displayed_amount_is_tax_inclusive: "displayedAmountIsTaxInclusive",
      tax_rate_uuid: "taxRateUuid",
      sort_order: "sortOrder",
      displayed_cost: "displayedCost",
      job_material_bundle_uuid: "jobMaterialBundleUuid"
    });
  });
  JobMaterial$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    materialUuid: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType(),
    price: stringType().optional(),
    displayedAmount: stringType().optional(),
    displayedAmountIsTaxInclusive: stringType().optional(),
    taxRateUuid: stringType().optional(),
    sortOrder: stringType().optional(),
    cost: stringType().optional(),
    displayedCost: stringType().optional(),
    jobMaterialBundleUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      materialUuid: "material_uuid",
      displayedAmount: "displayed_amount",
      displayedAmountIsTaxInclusive: "displayed_amount_is_tax_inclusive",
      taxRateUuid: "tax_rate_uuid",
      sortOrder: "sort_order",
      displayedCost: "displayed_cost",
      jobMaterialBundleUuid: "job_material_bundle_uuid"
    });
  });
  ((JobMaterial$) => {
    JobMaterial$.inboundSchema = JobMaterial$inboundSchema;
    JobMaterial$.outboundSchema = JobMaterial$outboundSchema;
  })(JobMaterial$ ||= {});
  JobMaterialInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    material_uuid: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType(),
    price: stringType().optional(),
    displayed_amount: stringType().optional(),
    displayed_amount_is_tax_inclusive: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    sort_order: stringType().optional(),
    cost: stringType().optional(),
    displayed_cost: stringType().optional(),
    job_material_bundle_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      material_uuid: "materialUuid",
      displayed_amount: "displayedAmount",
      displayed_amount_is_tax_inclusive: "displayedAmountIsTaxInclusive",
      tax_rate_uuid: "taxRateUuid",
      sort_order: "sortOrder",
      displayed_cost: "displayedCost",
      job_material_bundle_uuid: "jobMaterialBundleUuid"
    });
  });
  JobMaterialInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    materialUuid: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType(),
    price: stringType().optional(),
    displayedAmount: stringType().optional(),
    displayedAmountIsTaxInclusive: stringType().optional(),
    taxRateUuid: stringType().optional(),
    sortOrder: stringType().optional(),
    cost: stringType().optional(),
    displayedCost: stringType().optional(),
    jobMaterialBundleUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      materialUuid: "material_uuid",
      displayedAmount: "displayed_amount",
      displayedAmountIsTaxInclusive: "displayed_amount_is_tax_inclusive",
      taxRateUuid: "tax_rate_uuid",
      sortOrder: "sort_order",
      displayedCost: "displayed_cost",
      jobMaterialBundleUuid: "job_material_bundle_uuid"
    });
  });
  ((JobMaterialInput$) => {
    JobMaterialInput$.inboundSchema = JobMaterialInput$inboundSchema;
    JobMaterialInput$.outboundSchema = JobMaterialInput$outboundSchema;
  })(JobMaterialInput$ ||= {});
});

// src/models/components/jobmaterialbundle.ts
var JobMaterialBundleActive, JobMaterialBundleActive$inboundSchema, JobMaterialBundleActive$outboundSchema, JobMaterialBundleActive$, JobMaterialBundle$inboundSchema, JobMaterialBundle$outboundSchema, JobMaterialBundle$, JobMaterialBundleInput$inboundSchema, JobMaterialBundleInput$outboundSchema, JobMaterialBundleInput$;
var init_jobmaterialbundle = __esm(() => {
  init_lib();
  init_primitives();
  JobMaterialBundleActive = {
    Zero: 0,
    One: 1
  };
  JobMaterialBundleActive$inboundSchema = nativeEnumType(JobMaterialBundleActive);
  JobMaterialBundleActive$outboundSchema = JobMaterialBundleActive$inboundSchema;
  ((JobMaterialBundleActive$) => {
    JobMaterialBundleActive$.inboundSchema = JobMaterialBundleActive$inboundSchema;
    JobMaterialBundleActive$.outboundSchema = JobMaterialBundleActive$outboundSchema;
  })(JobMaterialBundleActive$ ||= {});
  JobMaterialBundle$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialBundleActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    item_number: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType().optional(),
    sort_order: numberType().int().optional(),
    material_bundle_uuid: stringType().optional(),
    job_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      item_number: "itemNumber",
      sort_order: "sortOrder",
      material_bundle_uuid: "materialBundleUuid",
      job_uuid: "jobUuid"
    });
  });
  JobMaterialBundle$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialBundleActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    itemNumber: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType().optional(),
    sortOrder: numberType().int().optional(),
    materialBundleUuid: stringType().optional(),
    jobUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      itemNumber: "item_number",
      sortOrder: "sort_order",
      materialBundleUuid: "material_bundle_uuid",
      jobUuid: "job_uuid"
    });
  });
  ((JobMaterialBundle$) => {
    JobMaterialBundle$.inboundSchema = JobMaterialBundle$inboundSchema;
    JobMaterialBundle$.outboundSchema = JobMaterialBundle$outboundSchema;
  })(JobMaterialBundle$ ||= {});
  JobMaterialBundleInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialBundleActive$inboundSchema.default(1),
    item_number: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType().optional(),
    sort_order: numberType().int().optional(),
    material_bundle_uuid: stringType().optional(),
    job_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      item_number: "itemNumber",
      sort_order: "sortOrder",
      material_bundle_uuid: "materialBundleUuid",
      job_uuid: "jobUuid"
    });
  });
  JobMaterialBundleInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobMaterialBundleActive$outboundSchema.default(1),
    itemNumber: stringType().optional(),
    name: stringType().optional(),
    quantity: stringType().optional(),
    sortOrder: numberType().int().optional(),
    materialBundleUuid: stringType().optional(),
    jobUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      itemNumber: "item_number",
      sortOrder: "sort_order",
      materialBundleUuid: "material_bundle_uuid",
      jobUuid: "job_uuid"
    });
  });
  ((JobMaterialBundleInput$) => {
    JobMaterialBundleInput$.inboundSchema = JobMaterialBundleInput$inboundSchema;
    JobMaterialBundleInput$.outboundSchema = JobMaterialBundleInput$outboundSchema;
  })(JobMaterialBundleInput$ ||= {});
});

// src/models/components/jobpayment.ts
var JobPaymentActive, IsDeposit, JobPaymentActive$inboundSchema, JobPaymentActive$outboundSchema, JobPaymentActive$, IsDeposit$inboundSchema, IsDeposit$outboundSchema, IsDeposit$, JobPayment$inboundSchema, JobPayment$outboundSchema, JobPayment$, JobPaymentInput$inboundSchema, JobPaymentInput$outboundSchema, JobPaymentInput$;
var init_jobpayment = __esm(() => {
  init_lib();
  init_primitives();
  JobPaymentActive = {
    Zero: 0,
    One: 1
  };
  IsDeposit = {
    Zero: 0,
    One: 1
  };
  JobPaymentActive$inboundSchema = nativeEnumType(JobPaymentActive);
  JobPaymentActive$outboundSchema = JobPaymentActive$inboundSchema;
  ((JobPaymentActive$) => {
    JobPaymentActive$.inboundSchema = JobPaymentActive$inboundSchema;
    JobPaymentActive$.outboundSchema = JobPaymentActive$outboundSchema;
  })(JobPaymentActive$ ||= {});
  IsDeposit$inboundSchema = nativeEnumType(IsDeposit);
  IsDeposit$outboundSchema = IsDeposit$inboundSchema;
  ((IsDeposit$) => {
    IsDeposit$.inboundSchema = IsDeposit$inboundSchema;
    IsDeposit$.outboundSchema = IsDeposit$outboundSchema;
  })(IsDeposit$ ||= {});
  JobPayment$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobPaymentActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    job_uuid: stringType().optional(),
    actioned_by_uuid: stringType().optional(),
    timestamp: stringType().optional(),
    amount: stringType().optional(),
    method: stringType().optional(),
    note: stringType().optional(),
    attachment_uuid: stringType().optional(),
    is_deposit: IsDeposit$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      job_uuid: "jobUuid",
      actioned_by_uuid: "actionedByUuid",
      attachment_uuid: "attachmentUuid",
      is_deposit: "isDeposit"
    });
  });
  JobPayment$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobPaymentActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    jobUuid: stringType().optional(),
    actionedByUuid: stringType().optional(),
    timestamp: stringType().optional(),
    amount: stringType().optional(),
    method: stringType().optional(),
    note: stringType().optional(),
    attachmentUuid: stringType().optional(),
    isDeposit: IsDeposit$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      jobUuid: "job_uuid",
      actionedByUuid: "actioned_by_uuid",
      attachmentUuid: "attachment_uuid",
      isDeposit: "is_deposit"
    });
  });
  ((JobPayment$) => {
    JobPayment$.inboundSchema = JobPayment$inboundSchema;
    JobPayment$.outboundSchema = JobPayment$outboundSchema;
  })(JobPayment$ ||= {});
  JobPaymentInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobPaymentActive$inboundSchema.default(1),
    job_uuid: stringType().optional(),
    actioned_by_uuid: stringType().optional(),
    timestamp: stringType().optional(),
    amount: stringType().optional(),
    method: stringType().optional(),
    note: stringType().optional(),
    attachment_uuid: stringType().optional(),
    is_deposit: IsDeposit$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      job_uuid: "jobUuid",
      actioned_by_uuid: "actionedByUuid",
      attachment_uuid: "attachmentUuid",
      is_deposit: "isDeposit"
    });
  });
  JobPaymentInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: JobPaymentActive$outboundSchema.default(1),
    jobUuid: stringType().optional(),
    actionedByUuid: stringType().optional(),
    timestamp: stringType().optional(),
    amount: stringType().optional(),
    method: stringType().optional(),
    note: stringType().optional(),
    attachmentUuid: stringType().optional(),
    isDeposit: IsDeposit$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      jobUuid: "job_uuid",
      actionedByUuid: "actioned_by_uuid",
      attachmentUuid: "attachment_uuid",
      isDeposit: "is_deposit"
    });
  });
  ((JobPaymentInput$) => {
    JobPaymentInput$.inboundSchema = JobPaymentInput$inboundSchema;
    JobPaymentInput$.outboundSchema = JobPaymentInput$outboundSchema;
  })(JobPaymentInput$ ||= {});
});

// src/models/components/knowledgearticle.ts
var KnowledgeArticleActive, ObjectName, KnowledgeArticleActive$inboundSchema, KnowledgeArticleActive$outboundSchema, KnowledgeArticleActive$, ObjectName$inboundSchema, ObjectName$outboundSchema, ObjectName$, Relationship$inboundSchema, Relationship$outboundSchema, Relationship$, KnowledgeArticle$inboundSchema, KnowledgeArticle$outboundSchema, KnowledgeArticle$, KnowledgeArticleInput$inboundSchema, KnowledgeArticleInput$outboundSchema, KnowledgeArticleInput$;
var init_knowledgearticle = __esm(() => {
  init_lib();
  init_primitives();
  KnowledgeArticleActive = {
    Zero: 0,
    One: 1
  };
  ObjectName = {
    JobMixed: "Job",
    JobLower: "job"
  };
  KnowledgeArticleActive$inboundSchema = nativeEnumType(KnowledgeArticleActive);
  KnowledgeArticleActive$outboundSchema = KnowledgeArticleActive$inboundSchema;
  ((KnowledgeArticleActive$) => {
    KnowledgeArticleActive$.inboundSchema = KnowledgeArticleActive$inboundSchema;
    KnowledgeArticleActive$.outboundSchema = KnowledgeArticleActive$outboundSchema;
  })(KnowledgeArticleActive$ ||= {});
  ObjectName$inboundSchema = nativeEnumType(ObjectName);
  ObjectName$outboundSchema = ObjectName$inboundSchema;
  ((ObjectName$) => {
    ObjectName$.inboundSchema = ObjectName$inboundSchema;
    ObjectName$.outboundSchema = ObjectName$outboundSchema;
  })(ObjectName$ ||= {});
  Relationship$inboundSchema = objectType({
    object_name: ObjectName$inboundSchema,
    object_uuid: stringType(),
    object_description: stringType().optional(),
    create_date: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      object_name: "objectName",
      object_uuid: "objectUuid",
      object_description: "objectDescription",
      create_date: "createDate"
    });
  });
  Relationship$outboundSchema = objectType({
    objectName: ObjectName$outboundSchema,
    objectUuid: stringType(),
    objectDescription: stringType().optional(),
    createDate: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      objectName: "object_name",
      objectUuid: "object_uuid",
      objectDescription: "object_description",
      createDate: "create_date"
    });
  });
  ((Relationship$) => {
    Relationship$.inboundSchema = Relationship$inboundSchema;
    Relationship$.outboundSchema = Relationship$outboundSchema;
  })(Relationship$ ||= {});
  KnowledgeArticle$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: KnowledgeArticleActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    content: stringType().optional(),
    article_type: stringType().optional(),
    tags: stringType().optional(),
    relationships: arrayType(lazyType(() => Relationship$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      article_type: "articleType"
    });
  });
  KnowledgeArticle$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: KnowledgeArticleActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    content: stringType().optional(),
    articleType: stringType().optional(),
    tags: stringType().optional(),
    relationships: arrayType(lazyType(() => Relationship$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      articleType: "article_type"
    });
  });
  ((KnowledgeArticle$) => {
    KnowledgeArticle$.inboundSchema = KnowledgeArticle$inboundSchema;
    KnowledgeArticle$.outboundSchema = KnowledgeArticle$outboundSchema;
  })(KnowledgeArticle$ ||= {});
  KnowledgeArticleInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: KnowledgeArticleActive$inboundSchema.default(1),
    name: stringType(),
    content: stringType().optional(),
    article_type: stringType().optional(),
    tags: stringType().optional(),
    relationships: arrayType(lazyType(() => Relationship$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      article_type: "articleType"
    });
  });
  KnowledgeArticleInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: KnowledgeArticleActive$outboundSchema.default(1),
    name: stringType(),
    content: stringType().optional(),
    articleType: stringType().optional(),
    tags: stringType().optional(),
    relationships: arrayType(lazyType(() => Relationship$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      articleType: "article_type"
    });
  });
  ((KnowledgeArticleInput$) => {
    KnowledgeArticleInput$.inboundSchema = KnowledgeArticleInput$inboundSchema;
    KnowledgeArticleInput$.outboundSchema = KnowledgeArticleInput$outboundSchema;
  })(KnowledgeArticleInput$ ||= {});
});

// src/models/components/location.ts
var LocationActive, LocationActive$inboundSchema, LocationActive$outboundSchema, LocationActive$, Location$inboundSchema, Location$outboundSchema, Location$, LocationInput$inboundSchema, LocationInput$outboundSchema, LocationInput$;
var init_location = __esm(() => {
  init_lib();
  init_primitives();
  LocationActive = {
    Zero: 0,
    One: 1
  };
  LocationActive$inboundSchema = nativeEnumType(LocationActive);
  LocationActive$outboundSchema = LocationActive$inboundSchema;
  ((LocationActive$) => {
    LocationActive$.inboundSchema = LocationActive$inboundSchema;
    LocationActive$.outboundSchema = LocationActive$outboundSchema;
  })(LocationActive$ ||= {});
  Location$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: LocationActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    line1: stringType().optional(),
    line2: stringType().optional(),
    line3: stringType().optional(),
    city: stringType().optional(),
    country: stringType().optional(),
    post_code: stringType().optional(),
    phone_1: stringType().optional(),
    state: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      post_code: "postCode",
      phone_1: "phone1"
    });
  });
  Location$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: LocationActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    line1: stringType().optional(),
    line2: stringType().optional(),
    line3: stringType().optional(),
    city: stringType().optional(),
    country: stringType().optional(),
    postCode: stringType().optional(),
    phone1: stringType().optional(),
    state: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      postCode: "post_code",
      phone1: "phone_1"
    });
  });
  ((Location$) => {
    Location$.inboundSchema = Location$inboundSchema;
    Location$.outboundSchema = Location$outboundSchema;
  })(Location$ ||= {});
  LocationInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: LocationActive$inboundSchema.default(1),
    name: stringType(),
    line1: stringType().optional(),
    line2: stringType().optional(),
    line3: stringType().optional(),
    city: stringType().optional(),
    country: stringType().optional(),
    post_code: stringType().optional(),
    phone_1: stringType().optional(),
    state: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional()
  }).transform((v2) => {
    return remap(v2, {
      post_code: "postCode",
      phone_1: "phone1"
    });
  });
  LocationInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: LocationActive$outboundSchema.default(1),
    name: stringType(),
    line1: stringType().optional(),
    line2: stringType().optional(),
    line3: stringType().optional(),
    city: stringType().optional(),
    country: stringType().optional(),
    postCode: stringType().optional(),
    phone1: stringType().optional(),
    state: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional()
  }).transform((v2) => {
    return remap(v2, {
      postCode: "post_code",
      phone1: "phone_1"
    });
  });
  ((LocationInput$) => {
    LocationInput$.inboundSchema = LocationInput$inboundSchema;
    LocationInput$.outboundSchema = LocationInput$outboundSchema;
  })(LocationInput$ ||= {});
});

// src/models/components/material.ts
var MaterialActive, PriceIncludesTaxes, ItemIsInventoried, MaterialActive$inboundSchema, MaterialActive$outboundSchema, MaterialActive$, PriceIncludesTaxes$inboundSchema, PriceIncludesTaxes$outboundSchema, PriceIncludesTaxes$, ItemIsInventoried$inboundSchema, ItemIsInventoried$outboundSchema, ItemIsInventoried$, Material$inboundSchema, Material$outboundSchema, Material$, MaterialInput$inboundSchema, MaterialInput$outboundSchema, MaterialInput$;
var init_material = __esm(() => {
  init_lib();
  init_primitives();
  MaterialActive = {
    Zero: 0,
    One: 1
  };
  PriceIncludesTaxes = {
    Zero: 0,
    One: 1
  };
  ItemIsInventoried = {
    Zero: 0,
    One: 1
  };
  MaterialActive$inboundSchema = nativeEnumType(MaterialActive);
  MaterialActive$outboundSchema = MaterialActive$inboundSchema;
  ((MaterialActive$) => {
    MaterialActive$.inboundSchema = MaterialActive$inboundSchema;
    MaterialActive$.outboundSchema = MaterialActive$outboundSchema;
  })(MaterialActive$ ||= {});
  PriceIncludesTaxes$inboundSchema = nativeEnumType(PriceIncludesTaxes);
  PriceIncludesTaxes$outboundSchema = PriceIncludesTaxes$inboundSchema;
  ((PriceIncludesTaxes$) => {
    PriceIncludesTaxes$.inboundSchema = PriceIncludesTaxes$inboundSchema;
    PriceIncludesTaxes$.outboundSchema = PriceIncludesTaxes$outboundSchema;
  })(PriceIncludesTaxes$ ||= {});
  ItemIsInventoried$inboundSchema = nativeEnumType(ItemIsInventoried);
  ItemIsInventoried$outboundSchema = ItemIsInventoried$inboundSchema;
  ((ItemIsInventoried$) => {
    ItemIsInventoried$.inboundSchema = ItemIsInventoried$inboundSchema;
    ItemIsInventoried$.outboundSchema = ItemIsInventoried$outboundSchema;
  })(ItemIsInventoried$ ||= {});
  Material$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    item_number: stringType().optional(),
    price: stringType().optional(),
    cost: stringType().optional(),
    item_description: stringType().optional(),
    quantity_in_stock: numberType().optional(),
    price_includes_taxes: PriceIncludesTaxes$inboundSchema.optional(),
    use_description_for_invoicing: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    barcode: stringType().optional(),
    item_is_inventoried: ItemIsInventoried$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      item_number: "itemNumber",
      item_description: "itemDescription",
      quantity_in_stock: "quantityInStock",
      price_includes_taxes: "priceIncludesTaxes",
      use_description_for_invoicing: "useDescriptionForInvoicing",
      tax_rate_uuid: "taxRateUuid",
      item_is_inventoried: "itemIsInventoried"
    });
  });
  Material$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    itemNumber: stringType().optional(),
    price: stringType().optional(),
    cost: stringType().optional(),
    itemDescription: stringType().optional(),
    quantityInStock: numberType().optional(),
    priceIncludesTaxes: PriceIncludesTaxes$outboundSchema.optional(),
    useDescriptionForInvoicing: stringType().optional(),
    taxRateUuid: stringType().optional(),
    barcode: stringType().optional(),
    itemIsInventoried: ItemIsInventoried$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      itemNumber: "item_number",
      itemDescription: "item_description",
      quantityInStock: "quantity_in_stock",
      priceIncludesTaxes: "price_includes_taxes",
      useDescriptionForInvoicing: "use_description_for_invoicing",
      taxRateUuid: "tax_rate_uuid",
      itemIsInventoried: "item_is_inventoried"
    });
  });
  ((Material$) => {
    Material$.inboundSchema = Material$inboundSchema;
    Material$.outboundSchema = Material$outboundSchema;
  })(Material$ ||= {});
  MaterialInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialActive$inboundSchema.default(1),
    name: stringType(),
    item_number: stringType().optional(),
    price: stringType().optional(),
    cost: stringType().optional(),
    item_description: stringType().optional(),
    quantity_in_stock: numberType().optional(),
    price_includes_taxes: PriceIncludesTaxes$inboundSchema.optional(),
    use_description_for_invoicing: stringType().optional(),
    tax_rate_uuid: stringType().optional(),
    barcode: stringType().optional(),
    item_is_inventoried: ItemIsInventoried$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      item_number: "itemNumber",
      item_description: "itemDescription",
      quantity_in_stock: "quantityInStock",
      price_includes_taxes: "priceIncludesTaxes",
      use_description_for_invoicing: "useDescriptionForInvoicing",
      tax_rate_uuid: "taxRateUuid",
      item_is_inventoried: "itemIsInventoried"
    });
  });
  MaterialInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialActive$outboundSchema.default(1),
    name: stringType(),
    itemNumber: stringType().optional(),
    price: stringType().optional(),
    cost: stringType().optional(),
    itemDescription: stringType().optional(),
    quantityInStock: numberType().optional(),
    priceIncludesTaxes: PriceIncludesTaxes$outboundSchema.optional(),
    useDescriptionForInvoicing: stringType().optional(),
    taxRateUuid: stringType().optional(),
    barcode: stringType().optional(),
    itemIsInventoried: ItemIsInventoried$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      itemNumber: "item_number",
      itemDescription: "item_description",
      quantityInStock: "quantity_in_stock",
      priceIncludesTaxes: "price_includes_taxes",
      useDescriptionForInvoicing: "use_description_for_invoicing",
      taxRateUuid: "tax_rate_uuid",
      itemIsInventoried: "item_is_inventoried"
    });
  });
  ((MaterialInput$) => {
    MaterialInput$.inboundSchema = MaterialInput$inboundSchema;
    MaterialInput$.outboundSchema = MaterialInput$outboundSchema;
  })(MaterialInput$ ||= {});
});

// src/models/components/materialbundle.ts
var MaterialBundleActive, MaterialBundleActive$inboundSchema, MaterialBundleActive$outboundSchema, MaterialBundleActive$, MaterialList$inboundSchema, MaterialList$outboundSchema, MaterialList$, MaterialBundle$inboundSchema, MaterialBundle$outboundSchema, MaterialBundle$, MaterialBundleInput$inboundSchema, MaterialBundleInput$outboundSchema, MaterialBundleInput$;
var init_materialbundle = __esm(() => {
  init_lib();
  init_primitives();
  MaterialBundleActive = {
    Zero: 0,
    One: 1
  };
  MaterialBundleActive$inboundSchema = nativeEnumType(MaterialBundleActive);
  MaterialBundleActive$outboundSchema = MaterialBundleActive$inboundSchema;
  ((MaterialBundleActive$) => {
    MaterialBundleActive$.inboundSchema = MaterialBundleActive$inboundSchema;
    MaterialBundleActive$.outboundSchema = MaterialBundleActive$outboundSchema;
  })(MaterialBundleActive$ ||= {});
  MaterialList$inboundSchema = objectType({
    uuid: stringType(),
    quantity: numberType()
  });
  MaterialList$outboundSchema = objectType({
    uuid: stringType(),
    quantity: numberType()
  });
  ((MaterialList$) => {
    MaterialList$.inboundSchema = MaterialList$inboundSchema;
    MaterialList$.outboundSchema = MaterialList$outboundSchema;
  })(MaterialList$ ||= {});
  MaterialBundle$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialBundleActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    item_number: stringType(),
    name: stringType().optional(),
    material_list: arrayType(lazyType(() => MaterialList$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      item_number: "itemNumber",
      material_list: "materialList"
    });
  });
  MaterialBundle$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialBundleActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    itemNumber: stringType(),
    name: stringType().optional(),
    materialList: arrayType(lazyType(() => MaterialList$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      itemNumber: "item_number",
      materialList: "material_list"
    });
  });
  ((MaterialBundle$) => {
    MaterialBundle$.inboundSchema = MaterialBundle$inboundSchema;
    MaterialBundle$.outboundSchema = MaterialBundle$outboundSchema;
  })(MaterialBundle$ ||= {});
  MaterialBundleInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialBundleActive$inboundSchema.default(1),
    item_number: stringType(),
    name: stringType().optional(),
    material_list: arrayType(lazyType(() => MaterialList$inboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      item_number: "itemNumber",
      material_list: "materialList"
    });
  });
  MaterialBundleInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: MaterialBundleActive$outboundSchema.default(1),
    itemNumber: stringType(),
    name: stringType().optional(),
    materialList: arrayType(lazyType(() => MaterialList$outboundSchema)).optional()
  }).transform((v2) => {
    return remap(v2, {
      itemNumber: "item_number",
      materialList: "material_list"
    });
  });
  ((MaterialBundleInput$) => {
    MaterialBundleInput$.inboundSchema = MaterialBundleInput$inboundSchema;
    MaterialBundleInput$.outboundSchema = MaterialBundleInput$outboundSchema;
  })(MaterialBundleInput$ ||= {});
});

// src/models/components/note.ts
var NoteActive, NoteActive$inboundSchema, NoteActive$outboundSchema, NoteActive$, Note$inboundSchema, Note$outboundSchema, Note$, NoteInput$inboundSchema, NoteInput$outboundSchema, NoteInput$;
var init_note = __esm(() => {
  init_lib();
  init_primitives();
  NoteActive = {
    Zero: 0,
    One: 1
  };
  NoteActive$inboundSchema = nativeEnumType(NoteActive);
  NoteActive$outboundSchema = NoteActive$inboundSchema;
  ((NoteActive$) => {
    NoteActive$.inboundSchema = NoteActive$inboundSchema;
    NoteActive$.outboundSchema = NoteActive$outboundSchema;
  })(NoteActive$ ||= {});
  Note$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: NoteActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    note: stringType().optional(),
    action_required: stringType().optional(),
    action_completed_by_staff_uuid: stringType().optional(),
    edit_by_staff_uuid: stringType().optional(),
    create_date: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      action_required: "actionRequired",
      action_completed_by_staff_uuid: "actionCompletedByStaffUuid",
      edit_by_staff_uuid: "editByStaffUuid",
      create_date: "createDate"
    });
  });
  Note$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: NoteActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    note: stringType().optional(),
    actionRequired: stringType().optional(),
    actionCompletedByStaffUuid: stringType().optional(),
    editByStaffUuid: stringType().optional(),
    createDate: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      actionRequired: "action_required",
      actionCompletedByStaffUuid: "action_completed_by_staff_uuid",
      editByStaffUuid: "edit_by_staff_uuid",
      createDate: "create_date"
    });
  });
  ((Note$) => {
    Note$.inboundSchema = Note$inboundSchema;
    Note$.outboundSchema = Note$outboundSchema;
  })(Note$ ||= {});
  NoteInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: NoteActive$inboundSchema.default(1),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    note: stringType().optional(),
    action_required: stringType().optional(),
    action_completed_by_staff_uuid: stringType().optional(),
    create_date: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      action_required: "actionRequired",
      action_completed_by_staff_uuid: "actionCompletedByStaffUuid",
      create_date: "createDate"
    });
  });
  NoteInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: NoteActive$outboundSchema.default(1),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    note: stringType().optional(),
    actionRequired: stringType().optional(),
    actionCompletedByStaffUuid: stringType().optional(),
    createDate: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      actionRequired: "action_required",
      actionCompletedByStaffUuid: "action_completed_by_staff_uuid",
      createDate: "create_date"
    });
  });
  ((NoteInput$) => {
    NoteInput$.inboundSchema = NoteInput$inboundSchema;
    NoteInput$.outboundSchema = NoteInput$outboundSchema;
  })(NoteInput$ ||= {});
});

// src/models/components/queue.ts
var QueueActive, RequiresAssignment, QueueActive$inboundSchema, QueueActive$outboundSchema, QueueActive$, RequiresAssignment$inboundSchema, RequiresAssignment$outboundSchema, RequiresAssignment$, Queue$inboundSchema, Queue$outboundSchema, Queue$, QueueInput$inboundSchema, QueueInput$outboundSchema, QueueInput$;
var init_queue = __esm(() => {
  init_lib();
  init_primitives();
  QueueActive = {
    Zero: 0,
    One: 1
  };
  RequiresAssignment = {
    Zero: 0,
    One: 1
  };
  QueueActive$inboundSchema = nativeEnumType(QueueActive);
  QueueActive$outboundSchema = QueueActive$inboundSchema;
  ((QueueActive$) => {
    QueueActive$.inboundSchema = QueueActive$inboundSchema;
    QueueActive$.outboundSchema = QueueActive$outboundSchema;
  })(QueueActive$ ||= {});
  RequiresAssignment$inboundSchema = nativeEnumType(RequiresAssignment);
  RequiresAssignment$outboundSchema = RequiresAssignment$inboundSchema;
  ((RequiresAssignment$) => {
    RequiresAssignment$.inboundSchema = RequiresAssignment$inboundSchema;
    RequiresAssignment$.outboundSchema = RequiresAssignment$outboundSchema;
  })(RequiresAssignment$ ||= {});
  Queue$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: QueueActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType().optional(),
    default_timeframe: numberType().int().optional(),
    subscribed_staff: stringType().optional(),
    requires_assignment: RequiresAssignment$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      default_timeframe: "defaultTimeframe",
      subscribed_staff: "subscribedStaff",
      requires_assignment: "requiresAssignment"
    });
  });
  Queue$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: QueueActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType().optional(),
    defaultTimeframe: numberType().int().optional(),
    subscribedStaff: stringType().optional(),
    requiresAssignment: RequiresAssignment$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      defaultTimeframe: "default_timeframe",
      subscribedStaff: "subscribed_staff",
      requiresAssignment: "requires_assignment"
    });
  });
  ((Queue$) => {
    Queue$.inboundSchema = Queue$inboundSchema;
    Queue$.outboundSchema = Queue$outboundSchema;
  })(Queue$ ||= {});
  QueueInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: QueueActive$inboundSchema.default(1),
    name: stringType().optional(),
    default_timeframe: numberType().int().optional(),
    subscribed_staff: stringType().optional(),
    requires_assignment: RequiresAssignment$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      default_timeframe: "defaultTimeframe",
      subscribed_staff: "subscribedStaff",
      requires_assignment: "requiresAssignment"
    });
  });
  QueueInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: QueueActive$outboundSchema.default(1),
    name: stringType().optional(),
    defaultTimeframe: numberType().int().optional(),
    subscribedStaff: stringType().optional(),
    requiresAssignment: RequiresAssignment$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      defaultTimeframe: "default_timeframe",
      subscribedStaff: "subscribed_staff",
      requiresAssignment: "requires_assignment"
    });
  });
  ((QueueInput$) => {
    QueueInput$.inboundSchema = QueueInput$inboundSchema;
    QueueInput$.outboundSchema = QueueInput$outboundSchema;
  })(QueueInput$ ||= {});
});

// src/models/components/result.ts
var Result$inboundSchema, Result$outboundSchema, Result$;
var init_result = __esm(() => {
  init_lib();
  Result$inboundSchema = objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  });
  Result$outboundSchema = objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  });
  ((Result$) => {
    Result$.inboundSchema = Result$inboundSchema;
    Result$.outboundSchema = Result$outboundSchema;
  })(Result$ ||= {});
});

// src/models/components/security.ts
var Security$inboundSchema, Security$outboundSchema, Security$;
var init_security2 = __esm(() => {
  init_lib();
  Security$inboundSchema = objectType({
    oauth2: stringType().optional(),
    apiKeyAuth: stringType().optional()
  });
  Security$outboundSchema = objectType({
    oauth2: stringType().optional(),
    apiKeyAuth: stringType().optional()
  });
  ((Security$) => {
    Security$.inboundSchema = Security$inboundSchema;
    Security$.outboundSchema = Security$outboundSchema;
  })(Security$ ||= {});
});

// src/models/components/securityrole.ts
var SecurityRoleActive, SecurityRoleActive$inboundSchema, SecurityRoleActive$outboundSchema, SecurityRoleActive$, SecurityRole$inboundSchema, SecurityRole$outboundSchema, SecurityRole$, SecurityRoleInput$inboundSchema, SecurityRoleInput$outboundSchema, SecurityRoleInput$;
var init_securityrole = __esm(() => {
  init_lib();
  init_primitives();
  SecurityRoleActive = {
    Zero: 0,
    One: 1
  };
  SecurityRoleActive$inboundSchema = nativeEnumType(SecurityRoleActive);
  SecurityRoleActive$outboundSchema = SecurityRoleActive$inboundSchema;
  ((SecurityRoleActive$) => {
    SecurityRoleActive$.inboundSchema = SecurityRoleActive$inboundSchema;
    SecurityRoleActive$.outboundSchema = SecurityRoleActive$outboundSchema;
  })(SecurityRoleActive$ ||= {});
  SecurityRole$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: SecurityRoleActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    role_description: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      role_description: "roleDescription"
    });
  });
  SecurityRole$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: SecurityRoleActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    roleDescription: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      roleDescription: "role_description"
    });
  });
  ((SecurityRole$) => {
    SecurityRole$.inboundSchema = SecurityRole$inboundSchema;
    SecurityRole$.outboundSchema = SecurityRole$outboundSchema;
  })(SecurityRole$ ||= {});
  SecurityRoleInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: SecurityRoleActive$inboundSchema.default(1),
    name: stringType(),
    role_description: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      role_description: "roleDescription"
    });
  });
  SecurityRoleInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: SecurityRoleActive$outboundSchema.default(1),
    name: stringType(),
    roleDescription: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      roleDescription: "role_description"
    });
  });
  ((SecurityRoleInput$) => {
    SecurityRoleInput$.inboundSchema = SecurityRoleInput$inboundSchema;
    SecurityRoleInput$.outboundSchema = SecurityRoleInput$outboundSchema;
  })(SecurityRoleInput$ ||= {});
});

// src/models/components/smstemplate.ts
var SmsTemplateActive, SmsTemplateActive$inboundSchema, SmsTemplateActive$outboundSchema, SmsTemplateActive$, SmsTemplate$inboundSchema, SmsTemplate$outboundSchema, SmsTemplate$, SmsTemplateInput$inboundSchema, SmsTemplateInput$outboundSchema, SmsTemplateInput$;
var init_smstemplate = __esm(() => {
  init_lib();
  init_primitives();
  SmsTemplateActive = {
    Zero: 0,
    One: 1
  };
  SmsTemplateActive$inboundSchema = nativeEnumType(SmsTemplateActive);
  SmsTemplateActive$outboundSchema = SmsTemplateActive$inboundSchema;
  ((SmsTemplateActive$) => {
    SmsTemplateActive$.inboundSchema = SmsTemplateActive$inboundSchema;
    SmsTemplateActive$.outboundSchema = SmsTemplateActive$outboundSchema;
  })(SmsTemplateActive$ ||= {});
  SmsTemplate$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: SmsTemplateActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    message: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate"
    });
  });
  SmsTemplate$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: SmsTemplateActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    message: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date"
    });
  });
  ((SmsTemplate$) => {
    SmsTemplate$.inboundSchema = SmsTemplate$inboundSchema;
    SmsTemplate$.outboundSchema = SmsTemplate$outboundSchema;
  })(SmsTemplate$ ||= {});
  SmsTemplateInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: SmsTemplateActive$inboundSchema.default(1),
    name: stringType(),
    message: stringType().optional()
  });
  SmsTemplateInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: SmsTemplateActive$outboundSchema.default(1),
    name: stringType(),
    message: stringType().optional()
  });
  ((SmsTemplateInput$) => {
    SmsTemplateInput$.inboundSchema = SmsTemplateInput$inboundSchema;
    SmsTemplateInput$.outboundSchema = SmsTemplateInput$outboundSchema;
  })(SmsTemplateInput$ ||= {});
});

// src/models/components/staff.ts
var StaffActive, HideFromSchedule, StaffActive$inboundSchema, StaffActive$outboundSchema, StaffActive$, HideFromSchedule$inboundSchema, HideFromSchedule$outboundSchema, HideFromSchedule$, Staff$inboundSchema, Staff$outboundSchema, Staff$, StaffInput$inboundSchema, StaffInput$outboundSchema, StaffInput$;
var init_staff = __esm(() => {
  init_lib();
  init_primitives();
  StaffActive = {
    Zero: 0,
    One: 1
  };
  HideFromSchedule = {
    Zero: 0,
    One: 1
  };
  StaffActive$inboundSchema = nativeEnumType(StaffActive);
  StaffActive$outboundSchema = StaffActive$inboundSchema;
  ((StaffActive$) => {
    StaffActive$.inboundSchema = StaffActive$inboundSchema;
    StaffActive$.outboundSchema = StaffActive$outboundSchema;
  })(StaffActive$ ||= {});
  HideFromSchedule$inboundSchema = nativeEnumType(HideFromSchedule);
  HideFromSchedule$outboundSchema = HideFromSchedule$inboundSchema;
  ((HideFromSchedule$) => {
    HideFromSchedule$.inboundSchema = HideFromSchedule$inboundSchema;
    HideFromSchedule$.outboundSchema = HideFromSchedule$outboundSchema;
  })(HideFromSchedule$ ||= {});
  Staff$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    first: stringType(),
    last: stringType(),
    email: stringType(),
    mobile: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    geo_timestamp: stringType().optional(),
    job_title: stringType().optional(),
    navigating_to_job_uuid: stringType().optional(),
    navigating_timestamp: stringType().optional(),
    navigating_expiry_timestamp: stringType().optional(),
    color: stringType().optional(),
    custom_icon_url: stringType().optional(),
    status_message: stringType().optional(),
    status_message_timestamp: stringType().optional(),
    can_receive_push_notification: stringType().optional(),
    hide_from_schedule: HideFromSchedule$inboundSchema.optional(),
    security_role_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      geo_timestamp: "geoTimestamp",
      job_title: "jobTitle",
      navigating_to_job_uuid: "navigatingToJobUuid",
      navigating_timestamp: "navigatingTimestamp",
      navigating_expiry_timestamp: "navigatingExpiryTimestamp",
      custom_icon_url: "customIconUrl",
      status_message: "statusMessage",
      status_message_timestamp: "statusMessageTimestamp",
      can_receive_push_notification: "canReceivePushNotification",
      hide_from_schedule: "hideFromSchedule",
      security_role_uuid: "securityRoleUuid"
    });
  });
  Staff$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    first: stringType(),
    last: stringType(),
    email: stringType(),
    mobile: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    geoTimestamp: stringType().optional(),
    jobTitle: stringType().optional(),
    navigatingToJobUuid: stringType().optional(),
    navigatingTimestamp: stringType().optional(),
    navigatingExpiryTimestamp: stringType().optional(),
    color: stringType().optional(),
    customIconUrl: stringType().optional(),
    statusMessage: stringType().optional(),
    statusMessageTimestamp: stringType().optional(),
    canReceivePushNotification: stringType().optional(),
    hideFromSchedule: HideFromSchedule$outboundSchema.optional(),
    securityRoleUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      geoTimestamp: "geo_timestamp",
      jobTitle: "job_title",
      navigatingToJobUuid: "navigating_to_job_uuid",
      navigatingTimestamp: "navigating_timestamp",
      navigatingExpiryTimestamp: "navigating_expiry_timestamp",
      customIconUrl: "custom_icon_url",
      statusMessage: "status_message",
      statusMessageTimestamp: "status_message_timestamp",
      canReceivePushNotification: "can_receive_push_notification",
      hideFromSchedule: "hide_from_schedule",
      securityRoleUuid: "security_role_uuid"
    });
  });
  ((Staff$) => {
    Staff$.inboundSchema = Staff$inboundSchema;
    Staff$.outboundSchema = Staff$outboundSchema;
  })(Staff$ ||= {});
  StaffInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffActive$inboundSchema.default(1),
    first: stringType(),
    last: stringType(),
    email: stringType(),
    mobile: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    geo_timestamp: stringType().optional(),
    job_title: stringType().optional(),
    navigating_to_job_uuid: stringType().optional(),
    navigating_timestamp: stringType().optional(),
    navigating_expiry_timestamp: stringType().optional(),
    color: stringType().optional(),
    custom_icon_url: stringType().optional(),
    status_message: stringType().optional(),
    status_message_timestamp: stringType().optional(),
    can_receive_push_notification: stringType().optional(),
    hide_from_schedule: HideFromSchedule$inboundSchema.optional(),
    security_role_uuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      geo_timestamp: "geoTimestamp",
      job_title: "jobTitle",
      navigating_to_job_uuid: "navigatingToJobUuid",
      navigating_timestamp: "navigatingTimestamp",
      navigating_expiry_timestamp: "navigatingExpiryTimestamp",
      custom_icon_url: "customIconUrl",
      status_message: "statusMessage",
      status_message_timestamp: "statusMessageTimestamp",
      can_receive_push_notification: "canReceivePushNotification",
      hide_from_schedule: "hideFromSchedule",
      security_role_uuid: "securityRoleUuid"
    });
  });
  StaffInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffActive$outboundSchema.default(1),
    first: stringType(),
    last: stringType(),
    email: stringType(),
    mobile: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    geoTimestamp: stringType().optional(),
    jobTitle: stringType().optional(),
    navigatingToJobUuid: stringType().optional(),
    navigatingTimestamp: stringType().optional(),
    navigatingExpiryTimestamp: stringType().optional(),
    color: stringType().optional(),
    customIconUrl: stringType().optional(),
    statusMessage: stringType().optional(),
    statusMessageTimestamp: stringType().optional(),
    canReceivePushNotification: stringType().optional(),
    hideFromSchedule: HideFromSchedule$outboundSchema.optional(),
    securityRoleUuid: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      geoTimestamp: "geo_timestamp",
      jobTitle: "job_title",
      navigatingToJobUuid: "navigating_to_job_uuid",
      navigatingTimestamp: "navigating_timestamp",
      navigatingExpiryTimestamp: "navigating_expiry_timestamp",
      customIconUrl: "custom_icon_url",
      statusMessage: "status_message",
      statusMessageTimestamp: "status_message_timestamp",
      canReceivePushNotification: "can_receive_push_notification",
      hideFromSchedule: "hide_from_schedule",
      securityRoleUuid: "security_role_uuid"
    });
  });
  ((StaffInput$) => {
    StaffInput$.inboundSchema = StaffInput$inboundSchema;
    StaffInput$.outboundSchema = StaffInput$outboundSchema;
  })(StaffInput$ ||= {});
});

// src/models/components/staffmessage.ts
var StaffMessageActive, StaffMessageActive$inboundSchema, StaffMessageActive$outboundSchema, StaffMessageActive$, StaffMessage$inboundSchema, StaffMessage$outboundSchema, StaffMessage$, StaffMessageInput$inboundSchema, StaffMessageInput$outboundSchema, StaffMessageInput$;
var init_staffmessage = __esm(() => {
  init_lib();
  init_primitives();
  StaffMessageActive = {
    Zero: 0,
    One: 1
  };
  StaffMessageActive$inboundSchema = nativeEnumType(StaffMessageActive);
  StaffMessageActive$outboundSchema = StaffMessageActive$inboundSchema;
  ((StaffMessageActive$) => {
    StaffMessageActive$.inboundSchema = StaffMessageActive$inboundSchema;
    StaffMessageActive$.outboundSchema = StaffMessageActive$outboundSchema;
  })(StaffMessageActive$ ||= {});
  StaffMessage$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffMessageActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    from_staff_uuid: stringType().optional(),
    to_staff_uuid: stringType().optional(),
    sent_timestamp: stringType().optional(),
    delivered_timestamp: stringType().optional(),
    read_timestamp: stringType().optional(),
    message: stringType().optional(),
    regarding_job_uuid: stringType().optional(),
    attached_json: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      from_staff_uuid: "fromStaffUuid",
      to_staff_uuid: "toStaffUuid",
      sent_timestamp: "sentTimestamp",
      delivered_timestamp: "deliveredTimestamp",
      read_timestamp: "readTimestamp",
      regarding_job_uuid: "regardingJobUuid",
      attached_json: "attachedJson"
    });
  });
  StaffMessage$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffMessageActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    fromStaffUuid: stringType().optional(),
    toStaffUuid: stringType().optional(),
    sentTimestamp: stringType().optional(),
    deliveredTimestamp: stringType().optional(),
    readTimestamp: stringType().optional(),
    message: stringType().optional(),
    regardingJobUuid: stringType().optional(),
    attachedJson: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      fromStaffUuid: "from_staff_uuid",
      toStaffUuid: "to_staff_uuid",
      sentTimestamp: "sent_timestamp",
      deliveredTimestamp: "delivered_timestamp",
      readTimestamp: "read_timestamp",
      regardingJobUuid: "regarding_job_uuid",
      attachedJson: "attached_json"
    });
  });
  ((StaffMessage$) => {
    StaffMessage$.inboundSchema = StaffMessage$inboundSchema;
    StaffMessage$.outboundSchema = StaffMessage$outboundSchema;
  })(StaffMessage$ ||= {});
  StaffMessageInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffMessageActive$inboundSchema.default(1),
    from_staff_uuid: stringType().optional(),
    to_staff_uuid: stringType().optional(),
    sent_timestamp: stringType().optional(),
    delivered_timestamp: stringType().optional(),
    read_timestamp: stringType().optional(),
    message: stringType().optional(),
    regarding_job_uuid: stringType().optional(),
    attached_json: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      from_staff_uuid: "fromStaffUuid",
      to_staff_uuid: "toStaffUuid",
      sent_timestamp: "sentTimestamp",
      delivered_timestamp: "deliveredTimestamp",
      read_timestamp: "readTimestamp",
      regarding_job_uuid: "regardingJobUuid",
      attached_json: "attachedJson"
    });
  });
  StaffMessageInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: StaffMessageActive$outboundSchema.default(1),
    fromStaffUuid: stringType().optional(),
    toStaffUuid: stringType().optional(),
    sentTimestamp: stringType().optional(),
    deliveredTimestamp: stringType().optional(),
    readTimestamp: stringType().optional(),
    message: stringType().optional(),
    regardingJobUuid: stringType().optional(),
    attachedJson: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      fromStaffUuid: "from_staff_uuid",
      toStaffUuid: "to_staff_uuid",
      sentTimestamp: "sent_timestamp",
      deliveredTimestamp: "delivered_timestamp",
      readTimestamp: "read_timestamp",
      regardingJobUuid: "regarding_job_uuid",
      attachedJson: "attached_json"
    });
  });
  ((StaffMessageInput$) => {
    StaffMessageInput$.inboundSchema = StaffMessageInput$inboundSchema;
    StaffMessageInput$.outboundSchema = StaffMessageInput$outboundSchema;
  })(StaffMessageInput$ ||= {});
});

// src/models/components/task.ts
var TaskActive, TaskActive$inboundSchema, TaskActive$outboundSchema, TaskActive$, Task$inboundSchema, Task$outboundSchema, Task$, TaskInput$inboundSchema, TaskInput$outboundSchema, TaskInput$;
var init_task = __esm(() => {
  init_lib();
  init_primitives();
  TaskActive = {
    Zero: 0,
    One: 1
  };
  TaskActive$inboundSchema = nativeEnumType(TaskActive);
  TaskActive$outboundSchema = TaskActive$inboundSchema;
  ((TaskActive$) => {
    TaskActive$.inboundSchema = TaskActive$inboundSchema;
    TaskActive$.outboundSchema = TaskActive$outboundSchema;
  })(TaskActive$ ||= {});
  Task$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaskActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    due_date: stringType().optional(),
    task_details: stringType().optional(),
    name: stringType(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    task_complete: stringType().optional(),
    completed_timestamp: stringType().optional(),
    completed_by_staff_uuid: stringType().optional(),
    assigned_to_staff_uuid: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    created_by_staff_uuid: stringType().optional(),
    create_date: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      due_date: "dueDate",
      task_details: "taskDetails",
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      task_complete: "taskComplete",
      completed_timestamp: "completedTimestamp",
      completed_by_staff_uuid: "completedByStaffUuid",
      assigned_to_staff_uuid: "assignedToStaffUuid",
      created_by_staff_uuid: "createdByStaffUuid",
      create_date: "createDate"
    });
  });
  Task$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaskActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    dueDate: stringType().optional(),
    taskDetails: stringType().optional(),
    name: stringType(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    taskComplete: stringType().optional(),
    completedTimestamp: stringType().optional(),
    completedByStaffUuid: stringType().optional(),
    assignedToStaffUuid: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    createdByStaffUuid: stringType().optional(),
    createDate: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      dueDate: "due_date",
      taskDetails: "task_details",
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      taskComplete: "task_complete",
      completedTimestamp: "completed_timestamp",
      completedByStaffUuid: "completed_by_staff_uuid",
      assignedToStaffUuid: "assigned_to_staff_uuid",
      createdByStaffUuid: "created_by_staff_uuid",
      createDate: "create_date"
    });
  });
  ((Task$) => {
    Task$.inboundSchema = Task$inboundSchema;
    Task$.outboundSchema = Task$outboundSchema;
  })(Task$ ||= {});
  TaskInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaskActive$inboundSchema.default(1),
    due_date: stringType().optional(),
    task_details: stringType().optional(),
    name: stringType(),
    related_object: stringType().optional(),
    related_object_uuid: stringType().optional(),
    task_complete: stringType().optional(),
    completed_timestamp: stringType().optional(),
    completed_by_staff_uuid: stringType().optional(),
    assigned_to_staff_uuid: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    created_by_staff_uuid: stringType().optional(),
    create_date: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      due_date: "dueDate",
      task_details: "taskDetails",
      related_object: "relatedObject",
      related_object_uuid: "relatedObjectUuid",
      task_complete: "taskComplete",
      completed_timestamp: "completedTimestamp",
      completed_by_staff_uuid: "completedByStaffUuid",
      assigned_to_staff_uuid: "assignedToStaffUuid",
      created_by_staff_uuid: "createdByStaffUuid",
      create_date: "createDate"
    });
  });
  TaskInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaskActive$outboundSchema.default(1),
    dueDate: stringType().optional(),
    taskDetails: stringType().optional(),
    name: stringType(),
    relatedObject: stringType().optional(),
    relatedObjectUuid: stringType().optional(),
    taskComplete: stringType().optional(),
    completedTimestamp: stringType().optional(),
    completedByStaffUuid: stringType().optional(),
    assignedToStaffUuid: stringType().optional(),
    lng: numberType().optional(),
    lat: numberType().optional(),
    createdByStaffUuid: stringType().optional(),
    createDate: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      dueDate: "due_date",
      taskDetails: "task_details",
      relatedObject: "related_object",
      relatedObjectUuid: "related_object_uuid",
      taskComplete: "task_complete",
      completedTimestamp: "completed_timestamp",
      completedByStaffUuid: "completed_by_staff_uuid",
      assignedToStaffUuid: "assigned_to_staff_uuid",
      createdByStaffUuid: "created_by_staff_uuid",
      createDate: "create_date"
    });
  });
  ((TaskInput$) => {
    TaskInput$.inboundSchema = TaskInput$inboundSchema;
    TaskInput$.outboundSchema = TaskInput$outboundSchema;
  })(TaskInput$ ||= {});
});

// src/models/components/taxrate.ts
var TaxRateActive, IsDefaultTaxRate, TaxRateActive$inboundSchema, TaxRateActive$outboundSchema, TaxRateActive$, IsDefaultTaxRate$inboundSchema, IsDefaultTaxRate$outboundSchema, IsDefaultTaxRate$, TaxRate$inboundSchema, TaxRate$outboundSchema, TaxRate$, TaxRateInput$inboundSchema, TaxRateInput$outboundSchema, TaxRateInput$;
var init_taxrate = __esm(() => {
  init_lib();
  init_primitives();
  TaxRateActive = {
    Zero: 0,
    One: 1
  };
  IsDefaultTaxRate = {
    Zero: 0,
    One: 1
  };
  TaxRateActive$inboundSchema = nativeEnumType(TaxRateActive);
  TaxRateActive$outboundSchema = TaxRateActive$inboundSchema;
  ((TaxRateActive$) => {
    TaxRateActive$.inboundSchema = TaxRateActive$inboundSchema;
    TaxRateActive$.outboundSchema = TaxRateActive$outboundSchema;
  })(TaxRateActive$ ||= {});
  IsDefaultTaxRate$inboundSchema = nativeEnumType(IsDefaultTaxRate);
  IsDefaultTaxRate$outboundSchema = IsDefaultTaxRate$inboundSchema;
  ((IsDefaultTaxRate$) => {
    IsDefaultTaxRate$.inboundSchema = IsDefaultTaxRate$inboundSchema;
    IsDefaultTaxRate$.outboundSchema = IsDefaultTaxRate$outboundSchema;
  })(IsDefaultTaxRate$ ||= {});
  TaxRate$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaxRateActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    amount: stringType().optional(),
    is_default_tax_rate: IsDefaultTaxRate$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      is_default_tax_rate: "isDefaultTaxRate"
    });
  });
  TaxRate$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaxRateActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    amount: stringType().optional(),
    isDefaultTaxRate: IsDefaultTaxRate$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      isDefaultTaxRate: "is_default_tax_rate"
    });
  });
  ((TaxRate$) => {
    TaxRate$.inboundSchema = TaxRate$inboundSchema;
    TaxRate$.outboundSchema = TaxRate$outboundSchema;
  })(TaxRate$ ||= {});
  TaxRateInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaxRateActive$inboundSchema.default(1),
    name: stringType(),
    amount: stringType().optional(),
    is_default_tax_rate: IsDefaultTaxRate$inboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      is_default_tax_rate: "isDefaultTaxRate"
    });
  });
  TaxRateInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: TaxRateActive$outboundSchema.default(1),
    name: stringType(),
    amount: stringType().optional(),
    isDefaultTaxRate: IsDefaultTaxRate$outboundSchema.optional()
  }).transform((v2) => {
    return remap(v2, {
      isDefaultTaxRate: "is_default_tax_rate"
    });
  });
  ((TaxRateInput$) => {
    TaxRateInput$.inboundSchema = TaxRateInput$inboundSchema;
    TaxRateInput$.outboundSchema = TaxRateInput$outboundSchema;
  })(TaxRateInput$ ||= {});
});

// src/models/components/vendor.ts
var VendorActive, VendorActive$inboundSchema, VendorActive$outboundSchema, VendorActive$, Vendor$inboundSchema, Vendor$outboundSchema, Vendor$, VendorInput$inboundSchema, VendorInput$outboundSchema, VendorInput$;
var init_vendor = __esm(() => {
  init_lib();
  init_primitives();
  VendorActive = {
    Zero: 0,
    One: 1
  };
  VendorActive$inboundSchema = nativeEnumType(VendorActive);
  VendorActive$outboundSchema = VendorActive$inboundSchema;
  ((VendorActive$) => {
    VendorActive$.inboundSchema = VendorActive$inboundSchema;
    VendorActive$.outboundSchema = VendorActive$outboundSchema;
  })(VendorActive$ ||= {});
  Vendor$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: VendorActive$inboundSchema.default(1),
    edit_date: stringType().optional(),
    name: stringType(),
    abn_number: stringType().optional(),
    business_number: stringType().optional(),
    website: stringType().optional(),
    email: stringType().optional(),
    email_accounts: stringType().optional(),
    billing_address: stringType().optional(),
    accepted_payment_methods: stringType().optional(),
    default_region: stringType().optional(),
    currency: stringType().optional(),
    opening_time_monday: stringType().optional(),
    closing_time_monday: stringType().optional(),
    opening_time_tuesday: stringType().optional(),
    closing_time_tuesday: stringType().optional(),
    opening_time_wednesday: stringType().optional(),
    closing_time_wednesday: stringType().optional(),
    opening_time_thursday: stringType().optional(),
    closing_time_thursday: stringType().optional(),
    opening_time_friday: stringType().optional(),
    closing_time_friday: stringType().optional(),
    opening_time_saturday: stringType().optional(),
    closing_time_saturday: stringType().optional(),
    opening_time_sunday: stringType().optional(),
    closing_time_sunday: stringType().optional(),
    timezone_name: stringType().optional(),
    invoice_terms: stringType().optional(),
    job_default_status: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      edit_date: "editDate",
      abn_number: "abnNumber",
      business_number: "businessNumber",
      email_accounts: "emailAccounts",
      billing_address: "billingAddress",
      accepted_payment_methods: "acceptedPaymentMethods",
      default_region: "defaultRegion",
      opening_time_monday: "openingTimeMonday",
      closing_time_monday: "closingTimeMonday",
      opening_time_tuesday: "openingTimeTuesday",
      closing_time_tuesday: "closingTimeTuesday",
      opening_time_wednesday: "openingTimeWednesday",
      closing_time_wednesday: "closingTimeWednesday",
      opening_time_thursday: "openingTimeThursday",
      closing_time_thursday: "closingTimeThursday",
      opening_time_friday: "openingTimeFriday",
      closing_time_friday: "closingTimeFriday",
      opening_time_saturday: "openingTimeSaturday",
      closing_time_saturday: "closingTimeSaturday",
      opening_time_sunday: "openingTimeSunday",
      closing_time_sunday: "closingTimeSunday",
      timezone_name: "timezoneName",
      invoice_terms: "invoiceTerms",
      job_default_status: "jobDefaultStatus"
    });
  });
  Vendor$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: VendorActive$outboundSchema.default(1),
    editDate: stringType().optional(),
    name: stringType(),
    abnNumber: stringType().optional(),
    businessNumber: stringType().optional(),
    website: stringType().optional(),
    email: stringType().optional(),
    emailAccounts: stringType().optional(),
    billingAddress: stringType().optional(),
    acceptedPaymentMethods: stringType().optional(),
    defaultRegion: stringType().optional(),
    currency: stringType().optional(),
    openingTimeMonday: stringType().optional(),
    closingTimeMonday: stringType().optional(),
    openingTimeTuesday: stringType().optional(),
    closingTimeTuesday: stringType().optional(),
    openingTimeWednesday: stringType().optional(),
    closingTimeWednesday: stringType().optional(),
    openingTimeThursday: stringType().optional(),
    closingTimeThursday: stringType().optional(),
    openingTimeFriday: stringType().optional(),
    closingTimeFriday: stringType().optional(),
    openingTimeSaturday: stringType().optional(),
    closingTimeSaturday: stringType().optional(),
    openingTimeSunday: stringType().optional(),
    closingTimeSunday: stringType().optional(),
    timezoneName: stringType().optional(),
    invoiceTerms: stringType().optional(),
    jobDefaultStatus: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      editDate: "edit_date",
      abnNumber: "abn_number",
      businessNumber: "business_number",
      emailAccounts: "email_accounts",
      billingAddress: "billing_address",
      acceptedPaymentMethods: "accepted_payment_methods",
      defaultRegion: "default_region",
      openingTimeMonday: "opening_time_monday",
      closingTimeMonday: "closing_time_monday",
      openingTimeTuesday: "opening_time_tuesday",
      closingTimeTuesday: "closing_time_tuesday",
      openingTimeWednesday: "opening_time_wednesday",
      closingTimeWednesday: "closing_time_wednesday",
      openingTimeThursday: "opening_time_thursday",
      closingTimeThursday: "closing_time_thursday",
      openingTimeFriday: "opening_time_friday",
      closingTimeFriday: "closing_time_friday",
      openingTimeSaturday: "opening_time_saturday",
      closingTimeSaturday: "closing_time_saturday",
      openingTimeSunday: "opening_time_sunday",
      closingTimeSunday: "closing_time_sunday",
      timezoneName: "timezone_name",
      invoiceTerms: "invoice_terms",
      jobDefaultStatus: "job_default_status"
    });
  });
  ((Vendor$) => {
    Vendor$.inboundSchema = Vendor$inboundSchema;
    Vendor$.outboundSchema = Vendor$outboundSchema;
  })(Vendor$ ||= {});
  VendorInput$inboundSchema = objectType({
    uuid: stringType().optional(),
    active: VendorActive$inboundSchema.default(1),
    name: stringType(),
    abn_number: stringType().optional(),
    business_number: stringType().optional(),
    website: stringType().optional(),
    email: stringType().optional(),
    email_accounts: stringType().optional(),
    billing_address: stringType().optional(),
    accepted_payment_methods: stringType().optional(),
    default_region: stringType().optional(),
    currency: stringType().optional(),
    opening_time_monday: stringType().optional(),
    closing_time_monday: stringType().optional(),
    opening_time_tuesday: stringType().optional(),
    closing_time_tuesday: stringType().optional(),
    opening_time_wednesday: stringType().optional(),
    closing_time_wednesday: stringType().optional(),
    opening_time_thursday: stringType().optional(),
    closing_time_thursday: stringType().optional(),
    opening_time_friday: stringType().optional(),
    closing_time_friday: stringType().optional(),
    opening_time_saturday: stringType().optional(),
    closing_time_saturday: stringType().optional(),
    opening_time_sunday: stringType().optional(),
    closing_time_sunday: stringType().optional(),
    timezone_name: stringType().optional(),
    invoice_terms: stringType().optional(),
    job_default_status: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      abn_number: "abnNumber",
      business_number: "businessNumber",
      email_accounts: "emailAccounts",
      billing_address: "billingAddress",
      accepted_payment_methods: "acceptedPaymentMethods",
      default_region: "defaultRegion",
      opening_time_monday: "openingTimeMonday",
      closing_time_monday: "closingTimeMonday",
      opening_time_tuesday: "openingTimeTuesday",
      closing_time_tuesday: "closingTimeTuesday",
      opening_time_wednesday: "openingTimeWednesday",
      closing_time_wednesday: "closingTimeWednesday",
      opening_time_thursday: "openingTimeThursday",
      closing_time_thursday: "closingTimeThursday",
      opening_time_friday: "openingTimeFriday",
      closing_time_friday: "closingTimeFriday",
      opening_time_saturday: "openingTimeSaturday",
      closing_time_saturday: "closingTimeSaturday",
      opening_time_sunday: "openingTimeSunday",
      closing_time_sunday: "closingTimeSunday",
      timezone_name: "timezoneName",
      invoice_terms: "invoiceTerms",
      job_default_status: "jobDefaultStatus"
    });
  });
  VendorInput$outboundSchema = objectType({
    uuid: stringType().optional(),
    active: VendorActive$outboundSchema.default(1),
    name: stringType(),
    abnNumber: stringType().optional(),
    businessNumber: stringType().optional(),
    website: stringType().optional(),
    email: stringType().optional(),
    emailAccounts: stringType().optional(),
    billingAddress: stringType().optional(),
    acceptedPaymentMethods: stringType().optional(),
    defaultRegion: stringType().optional(),
    currency: stringType().optional(),
    openingTimeMonday: stringType().optional(),
    closingTimeMonday: stringType().optional(),
    openingTimeTuesday: stringType().optional(),
    closingTimeTuesday: stringType().optional(),
    openingTimeWednesday: stringType().optional(),
    closingTimeWednesday: stringType().optional(),
    openingTimeThursday: stringType().optional(),
    closingTimeThursday: stringType().optional(),
    openingTimeFriday: stringType().optional(),
    closingTimeFriday: stringType().optional(),
    openingTimeSaturday: stringType().optional(),
    closingTimeSaturday: stringType().optional(),
    openingTimeSunday: stringType().optional(),
    closingTimeSunday: stringType().optional(),
    timezoneName: stringType().optional(),
    invoiceTerms: stringType().optional(),
    jobDefaultStatus: stringType().optional()
  }).transform((v2) => {
    return remap(v2, {
      abnNumber: "abn_number",
      businessNumber: "business_number",
      emailAccounts: "email_accounts",
      billingAddress: "billing_address",
      acceptedPaymentMethods: "accepted_payment_methods",
      defaultRegion: "default_region",
      openingTimeMonday: "opening_time_monday",
      closingTimeMonday: "closing_time_monday",
      openingTimeTuesday: "opening_time_tuesday",
      closingTimeTuesday: "closing_time_tuesday",
      openingTimeWednesday: "opening_time_wednesday",
      closingTimeWednesday: "closing_time_wednesday",
      openingTimeThursday: "opening_time_thursday",
      closingTimeThursday: "closing_time_thursday",
      openingTimeFriday: "opening_time_friday",
      closingTimeFriday: "closing_time_friday",
      openingTimeSaturday: "opening_time_saturday",
      closingTimeSaturday: "closing_time_saturday",
      openingTimeSunday: "opening_time_sunday",
      closingTimeSunday: "closing_time_sunday",
      timezoneName: "timezone_name",
      invoiceTerms: "invoice_terms",
      jobDefaultStatus: "job_default_status"
    });
  });
  ((VendorInput$) => {
    VendorInput$.inboundSchema = VendorInput$inboundSchema;
    VendorInput$.outboundSchema = VendorInput$outboundSchema;
  })(VendorInput$ ||= {});
});

// src/models/components/index.ts
var init_components = __esm(() => {
  init_allocationwindow();
  init_asset();
  init_assettype();
  init_assettypefield();
  init_attachment();
  init_badge();
  init_category();
  init_company();
  init_companycontact();
  init_emailtemplate();
  init_error();
  init_feedback();
  init_form();
  init_formfield();
  init_formresponse();
  init_job();
  init_jobactivity();
  init_joballocation();
  init_jobchecklist();
  init_jobcontact();
  init_jobmaterial();
  init_jobmaterialbundle();
  init_jobpayment();
  init_knowledgearticle();
  init_location();
  init_material();
  init_materialbundle();
  init_note();
  init_queue();
  init_result();
  init_security2();
  init_securityrole();
  init_smstemplate();
  init_staff();
  init_staffmessage();
  init_task();
  init_taxrate();
  init_vendor();
});

// src/models/errors/error.ts
var ErrorT, ErrorT$inboundSchema2, ErrorT$outboundSchema2, ErrorT$2;
var init_error2 = __esm(() => {
  init_lib();
  ErrorT = class ErrorT extends Error {
    errorCode;
    data$;
    constructor(err) {
      const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
      super(message);
      this.data$ = err;
      if (err.errorCode != null)
        this.errorCode = err.errorCode;
      this.name = "ErrorT";
    }
  };
  ErrorT$inboundSchema2 = objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  }).transform((v2) => {
    return new ErrorT(v2);
  });
  ErrorT$outboundSchema2 = instanceOfType(ErrorT).transform((v2) => v2.data$).pipe(objectType({
    errorCode: numberType().optional(),
    message: stringType().optional()
  }));
  ((ErrorT$) => {
    ErrorT$.inboundSchema = ErrorT$inboundSchema2;
    ErrorT$.outboundSchema = ErrorT$outboundSchema2;
  })(ErrorT$2 ||= {});
});

// src/models/errors/index.ts
var init_errors = __esm(() => {
  init_apierror();
  init_error2();
  init_httpclienterrors();
  init_sdkvalidationerror();
});

// src/models/operations/createallocationwindows.ts
var CreateAllocationWindowsResponseResult$inboundSchema, CreateAllocationWindowsResponseResult$outboundSchema, CreateAllocationWindowsResponseResult$, CreateAllocationWindowsResponse$inboundSchema, CreateAllocationWindowsResponse$outboundSchema, CreateAllocationWindowsResponse$;
var init_createallocationwindows = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateAllocationWindowsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateAllocationWindowsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateAllocationWindowsResponseResult$) => {
    CreateAllocationWindowsResponseResult$.inboundSchema = CreateAllocationWindowsResponseResult$inboundSchema;
    CreateAllocationWindowsResponseResult$.outboundSchema = CreateAllocationWindowsResponseResult$outboundSchema;
  })(CreateAllocationWindowsResponseResult$ ||= {});
  CreateAllocationWindowsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateAllocationWindowsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateAllocationWindowsResponse$) => {
    CreateAllocationWindowsResponse$.inboundSchema = CreateAllocationWindowsResponse$inboundSchema;
    CreateAllocationWindowsResponse$.outboundSchema = CreateAllocationWindowsResponse$outboundSchema;
  })(CreateAllocationWindowsResponse$ ||= {});
});

// src/models/operations/createassettypefields.ts
var CreateAssetTypeFieldsResponseResult$inboundSchema, CreateAssetTypeFieldsResponseResult$outboundSchema, CreateAssetTypeFieldsResponseResult$, CreateAssetTypeFieldsResponse$inboundSchema, CreateAssetTypeFieldsResponse$outboundSchema, CreateAssetTypeFieldsResponse$;
var init_createassettypefields = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateAssetTypeFieldsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateAssetTypeFieldsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateAssetTypeFieldsResponseResult$) => {
    CreateAssetTypeFieldsResponseResult$.inboundSchema = CreateAssetTypeFieldsResponseResult$inboundSchema;
    CreateAssetTypeFieldsResponseResult$.outboundSchema = CreateAssetTypeFieldsResponseResult$outboundSchema;
  })(CreateAssetTypeFieldsResponseResult$ ||= {});
  CreateAssetTypeFieldsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateAssetTypeFieldsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateAssetTypeFieldsResponse$) => {
    CreateAssetTypeFieldsResponse$.inboundSchema = CreateAssetTypeFieldsResponse$inboundSchema;
    CreateAssetTypeFieldsResponse$.outboundSchema = CreateAssetTypeFieldsResponse$outboundSchema;
  })(CreateAssetTypeFieldsResponse$ ||= {});
});

// src/models/operations/createassettypes.ts
var CreateAssetTypesResponseResult$inboundSchema, CreateAssetTypesResponseResult$outboundSchema, CreateAssetTypesResponseResult$, CreateAssetTypesResponse$inboundSchema, CreateAssetTypesResponse$outboundSchema, CreateAssetTypesResponse$;
var init_createassettypes = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateAssetTypesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateAssetTypesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateAssetTypesResponseResult$) => {
    CreateAssetTypesResponseResult$.inboundSchema = CreateAssetTypesResponseResult$inboundSchema;
    CreateAssetTypesResponseResult$.outboundSchema = CreateAssetTypesResponseResult$outboundSchema;
  })(CreateAssetTypesResponseResult$ ||= {});
  CreateAssetTypesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateAssetTypesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateAssetTypesResponse$) => {
    CreateAssetTypesResponse$.inboundSchema = CreateAssetTypesResponse$inboundSchema;
    CreateAssetTypesResponse$.outboundSchema = CreateAssetTypesResponse$outboundSchema;
  })(CreateAssetTypesResponse$ ||= {});
});

// src/models/operations/createattachments.ts
var CreateAttachmentsResponseResult$inboundSchema, CreateAttachmentsResponseResult$outboundSchema, CreateAttachmentsResponseResult$, CreateAttachmentsResponse$inboundSchema, CreateAttachmentsResponse$outboundSchema, CreateAttachmentsResponse$;
var init_createattachments = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateAttachmentsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateAttachmentsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateAttachmentsResponseResult$) => {
    CreateAttachmentsResponseResult$.inboundSchema = CreateAttachmentsResponseResult$inboundSchema;
    CreateAttachmentsResponseResult$.outboundSchema = CreateAttachmentsResponseResult$outboundSchema;
  })(CreateAttachmentsResponseResult$ ||= {});
  CreateAttachmentsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateAttachmentsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateAttachmentsResponse$) => {
    CreateAttachmentsResponse$.inboundSchema = CreateAttachmentsResponse$inboundSchema;
    CreateAttachmentsResponse$.outboundSchema = CreateAttachmentsResponse$outboundSchema;
  })(CreateAttachmentsResponse$ ||= {});
});

// src/models/operations/createbadges.ts
var CreateBadgesResponseResult$inboundSchema, CreateBadgesResponseResult$outboundSchema, CreateBadgesResponseResult$, CreateBadgesResponse$inboundSchema, CreateBadgesResponse$outboundSchema, CreateBadgesResponse$;
var init_createbadges = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateBadgesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateBadgesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateBadgesResponseResult$) => {
    CreateBadgesResponseResult$.inboundSchema = CreateBadgesResponseResult$inboundSchema;
    CreateBadgesResponseResult$.outboundSchema = CreateBadgesResponseResult$outboundSchema;
  })(CreateBadgesResponseResult$ ||= {});
  CreateBadgesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateBadgesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateBadgesResponse$) => {
    CreateBadgesResponse$.inboundSchema = CreateBadgesResponse$inboundSchema;
    CreateBadgesResponse$.outboundSchema = CreateBadgesResponse$outboundSchema;
  })(CreateBadgesResponse$ ||= {});
});

// src/models/operations/createbundles.ts
var CreateBundlesResponseResult$inboundSchema, CreateBundlesResponseResult$outboundSchema, CreateBundlesResponseResult$, CreateBundlesResponse$inboundSchema, CreateBundlesResponse$outboundSchema, CreateBundlesResponse$;
var init_createbundles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateBundlesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateBundlesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateBundlesResponseResult$) => {
    CreateBundlesResponseResult$.inboundSchema = CreateBundlesResponseResult$inboundSchema;
    CreateBundlesResponseResult$.outboundSchema = CreateBundlesResponseResult$outboundSchema;
  })(CreateBundlesResponseResult$ ||= {});
  CreateBundlesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateBundlesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateBundlesResponse$) => {
    CreateBundlesResponse$.inboundSchema = CreateBundlesResponse$inboundSchema;
    CreateBundlesResponse$.outboundSchema = CreateBundlesResponse$outboundSchema;
  })(CreateBundlesResponse$ ||= {});
});

// src/models/operations/createcategories.ts
var CreateCategoriesResponseResult$inboundSchema, CreateCategoriesResponseResult$outboundSchema, CreateCategoriesResponseResult$, CreateCategoriesResponse$inboundSchema, CreateCategoriesResponse$outboundSchema, CreateCategoriesResponse$;
var init_createcategories = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateCategoriesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateCategoriesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateCategoriesResponseResult$) => {
    CreateCategoriesResponseResult$.inboundSchema = CreateCategoriesResponseResult$inboundSchema;
    CreateCategoriesResponseResult$.outboundSchema = CreateCategoriesResponseResult$outboundSchema;
  })(CreateCategoriesResponseResult$ ||= {});
  CreateCategoriesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateCategoriesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateCategoriesResponse$) => {
    CreateCategoriesResponse$.inboundSchema = CreateCategoriesResponse$inboundSchema;
    CreateCategoriesResponse$.outboundSchema = CreateCategoriesResponse$outboundSchema;
  })(CreateCategoriesResponse$ ||= {});
});

// src/models/operations/createclients.ts
var CreateClientsResponseResult$inboundSchema, CreateClientsResponseResult$outboundSchema, CreateClientsResponseResult$, CreateClientsResponse$inboundSchema, CreateClientsResponse$outboundSchema, CreateClientsResponse$;
var init_createclients = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateClientsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateClientsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateClientsResponseResult$) => {
    CreateClientsResponseResult$.inboundSchema = CreateClientsResponseResult$inboundSchema;
    CreateClientsResponseResult$.outboundSchema = CreateClientsResponseResult$outboundSchema;
  })(CreateClientsResponseResult$ ||= {});
  CreateClientsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateClientsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateClientsResponse$) => {
    CreateClientsResponse$.inboundSchema = CreateClientsResponse$inboundSchema;
    CreateClientsResponse$.outboundSchema = CreateClientsResponse$outboundSchema;
  })(CreateClientsResponse$ ||= {});
});

// src/models/operations/createcompanycontacts.ts
var CreateCompanyContactsResponseResult$inboundSchema, CreateCompanyContactsResponseResult$outboundSchema, CreateCompanyContactsResponseResult$, CreateCompanyContactsResponse$inboundSchema, CreateCompanyContactsResponse$outboundSchema, CreateCompanyContactsResponse$;
var init_createcompanycontacts = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateCompanyContactsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateCompanyContactsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateCompanyContactsResponseResult$) => {
    CreateCompanyContactsResponseResult$.inboundSchema = CreateCompanyContactsResponseResult$inboundSchema;
    CreateCompanyContactsResponseResult$.outboundSchema = CreateCompanyContactsResponseResult$outboundSchema;
  })(CreateCompanyContactsResponseResult$ ||= {});
  CreateCompanyContactsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateCompanyContactsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateCompanyContactsResponse$) => {
    CreateCompanyContactsResponse$.inboundSchema = CreateCompanyContactsResponse$inboundSchema;
    CreateCompanyContactsResponse$.outboundSchema = CreateCompanyContactsResponse$outboundSchema;
  })(CreateCompanyContactsResponse$ ||= {});
});

// src/models/operations/createemailtemplates.ts
var CreateEmailTemplatesResponseResult$inboundSchema, CreateEmailTemplatesResponseResult$outboundSchema, CreateEmailTemplatesResponseResult$, CreateEmailTemplatesResponse$inboundSchema, CreateEmailTemplatesResponse$outboundSchema, CreateEmailTemplatesResponse$;
var init_createemailtemplates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateEmailTemplatesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateEmailTemplatesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateEmailTemplatesResponseResult$) => {
    CreateEmailTemplatesResponseResult$.inboundSchema = CreateEmailTemplatesResponseResult$inboundSchema;
    CreateEmailTemplatesResponseResult$.outboundSchema = CreateEmailTemplatesResponseResult$outboundSchema;
  })(CreateEmailTemplatesResponseResult$ ||= {});
  CreateEmailTemplatesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateEmailTemplatesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateEmailTemplatesResponse$) => {
    CreateEmailTemplatesResponse$.inboundSchema = CreateEmailTemplatesResponse$inboundSchema;
    CreateEmailTemplatesResponse$.outboundSchema = CreateEmailTemplatesResponse$outboundSchema;
  })(CreateEmailTemplatesResponse$ ||= {});
});

// src/models/operations/createfeedback.ts
var CreateFeedbackResponseResult$inboundSchema, CreateFeedbackResponseResult$outboundSchema, CreateFeedbackResponseResult$, CreateFeedbackResponse$inboundSchema, CreateFeedbackResponse$outboundSchema, CreateFeedbackResponse$;
var init_createfeedback = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateFeedbackResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateFeedbackResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateFeedbackResponseResult$) => {
    CreateFeedbackResponseResult$.inboundSchema = CreateFeedbackResponseResult$inboundSchema;
    CreateFeedbackResponseResult$.outboundSchema = CreateFeedbackResponseResult$outboundSchema;
  })(CreateFeedbackResponseResult$ ||= {});
  CreateFeedbackResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateFeedbackResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateFeedbackResponse$) => {
    CreateFeedbackResponse$.inboundSchema = CreateFeedbackResponse$inboundSchema;
    CreateFeedbackResponse$.outboundSchema = CreateFeedbackResponse$outboundSchema;
  })(CreateFeedbackResponse$ ||= {});
});

// src/models/operations/createformfields.ts
var CreateFormFieldsResponseResult$inboundSchema, CreateFormFieldsResponseResult$outboundSchema, CreateFormFieldsResponseResult$, CreateFormFieldsResponse$inboundSchema, CreateFormFieldsResponse$outboundSchema, CreateFormFieldsResponse$;
var init_createformfields = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateFormFieldsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateFormFieldsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateFormFieldsResponseResult$) => {
    CreateFormFieldsResponseResult$.inboundSchema = CreateFormFieldsResponseResult$inboundSchema;
    CreateFormFieldsResponseResult$.outboundSchema = CreateFormFieldsResponseResult$outboundSchema;
  })(CreateFormFieldsResponseResult$ ||= {});
  CreateFormFieldsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateFormFieldsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateFormFieldsResponse$) => {
    CreateFormFieldsResponse$.inboundSchema = CreateFormFieldsResponse$inboundSchema;
    CreateFormFieldsResponse$.outboundSchema = CreateFormFieldsResponse$outboundSchema;
  })(CreateFormFieldsResponse$ ||= {});
});

// src/models/operations/createformresponses.ts
var CreateFormResponsesResponseResult$inboundSchema, CreateFormResponsesResponseResult$outboundSchema, CreateFormResponsesResponseResult$, CreateFormResponsesResponse$inboundSchema, CreateFormResponsesResponse$outboundSchema, CreateFormResponsesResponse$;
var init_createformresponses = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateFormResponsesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateFormResponsesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateFormResponsesResponseResult$) => {
    CreateFormResponsesResponseResult$.inboundSchema = CreateFormResponsesResponseResult$inboundSchema;
    CreateFormResponsesResponseResult$.outboundSchema = CreateFormResponsesResponseResult$outboundSchema;
  })(CreateFormResponsesResponseResult$ ||= {});
  CreateFormResponsesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateFormResponsesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateFormResponsesResponse$) => {
    CreateFormResponsesResponse$.inboundSchema = CreateFormResponsesResponse$inboundSchema;
    CreateFormResponsesResponse$.outboundSchema = CreateFormResponsesResponse$outboundSchema;
  })(CreateFormResponsesResponse$ ||= {});
});

// src/models/operations/createforms.ts
var CreateFormsResponseResult$inboundSchema, CreateFormsResponseResult$outboundSchema, CreateFormsResponseResult$, CreateFormsResponse$inboundSchema, CreateFormsResponse$outboundSchema, CreateFormsResponse$;
var init_createforms = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateFormsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateFormsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateFormsResponseResult$) => {
    CreateFormsResponseResult$.inboundSchema = CreateFormsResponseResult$inboundSchema;
    CreateFormsResponseResult$.outboundSchema = CreateFormsResponseResult$outboundSchema;
  })(CreateFormsResponseResult$ ||= {});
  CreateFormsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateFormsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateFormsResponse$) => {
    CreateFormsResponse$.inboundSchema = CreateFormsResponse$inboundSchema;
    CreateFormsResponse$.outboundSchema = CreateFormsResponse$outboundSchema;
  })(CreateFormsResponse$ ||= {});
});

// src/models/operations/createjobactivities.ts
var CreateJobActivitiesResponseResult$inboundSchema, CreateJobActivitiesResponseResult$outboundSchema, CreateJobActivitiesResponseResult$, CreateJobActivitiesResponse$inboundSchema, CreateJobActivitiesResponse$outboundSchema, CreateJobActivitiesResponse$;
var init_createjobactivities = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobActivitiesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobActivitiesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobActivitiesResponseResult$) => {
    CreateJobActivitiesResponseResult$.inboundSchema = CreateJobActivitiesResponseResult$inboundSchema;
    CreateJobActivitiesResponseResult$.outboundSchema = CreateJobActivitiesResponseResult$outboundSchema;
  })(CreateJobActivitiesResponseResult$ ||= {});
  CreateJobActivitiesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobActivitiesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobActivitiesResponse$) => {
    CreateJobActivitiesResponse$.inboundSchema = CreateJobActivitiesResponse$inboundSchema;
    CreateJobActivitiesResponse$.outboundSchema = CreateJobActivitiesResponse$outboundSchema;
  })(CreateJobActivitiesResponse$ ||= {});
});

// src/models/operations/createjoballocations.ts
var CreateJobAllocationsResponseResult$inboundSchema, CreateJobAllocationsResponseResult$outboundSchema, CreateJobAllocationsResponseResult$, CreateJobAllocationsResponse$inboundSchema, CreateJobAllocationsResponse$outboundSchema, CreateJobAllocationsResponse$;
var init_createjoballocations = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobAllocationsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobAllocationsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobAllocationsResponseResult$) => {
    CreateJobAllocationsResponseResult$.inboundSchema = CreateJobAllocationsResponseResult$inboundSchema;
    CreateJobAllocationsResponseResult$.outboundSchema = CreateJobAllocationsResponseResult$outboundSchema;
  })(CreateJobAllocationsResponseResult$ ||= {});
  CreateJobAllocationsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobAllocationsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobAllocationsResponse$) => {
    CreateJobAllocationsResponse$.inboundSchema = CreateJobAllocationsResponse$inboundSchema;
    CreateJobAllocationsResponse$.outboundSchema = CreateJobAllocationsResponse$outboundSchema;
  })(CreateJobAllocationsResponse$ ||= {});
});

// src/models/operations/createjobchecklists.ts
var CreateJobChecklistsResponseResult$inboundSchema, CreateJobChecklistsResponseResult$outboundSchema, CreateJobChecklistsResponseResult$, CreateJobChecklistsResponse$inboundSchema, CreateJobChecklistsResponse$outboundSchema, CreateJobChecklistsResponse$;
var init_createjobchecklists = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobChecklistsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobChecklistsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobChecklistsResponseResult$) => {
    CreateJobChecklistsResponseResult$.inboundSchema = CreateJobChecklistsResponseResult$inboundSchema;
    CreateJobChecklistsResponseResult$.outboundSchema = CreateJobChecklistsResponseResult$outboundSchema;
  })(CreateJobChecklistsResponseResult$ ||= {});
  CreateJobChecklistsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobChecklistsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobChecklistsResponse$) => {
    CreateJobChecklistsResponse$.inboundSchema = CreateJobChecklistsResponse$inboundSchema;
    CreateJobChecklistsResponse$.outboundSchema = CreateJobChecklistsResponse$outboundSchema;
  })(CreateJobChecklistsResponse$ ||= {});
});

// src/models/operations/createjobcontacts.ts
var CreateJobContactsResponseResult$inboundSchema, CreateJobContactsResponseResult$outboundSchema, CreateJobContactsResponseResult$, CreateJobContactsResponse$inboundSchema, CreateJobContactsResponse$outboundSchema, CreateJobContactsResponse$;
var init_createjobcontacts = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobContactsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobContactsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobContactsResponseResult$) => {
    CreateJobContactsResponseResult$.inboundSchema = CreateJobContactsResponseResult$inboundSchema;
    CreateJobContactsResponseResult$.outboundSchema = CreateJobContactsResponseResult$outboundSchema;
  })(CreateJobContactsResponseResult$ ||= {});
  CreateJobContactsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobContactsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobContactsResponse$) => {
    CreateJobContactsResponse$.inboundSchema = CreateJobContactsResponse$inboundSchema;
    CreateJobContactsResponse$.outboundSchema = CreateJobContactsResponse$outboundSchema;
  })(CreateJobContactsResponse$ ||= {});
});

// src/models/operations/createjobmaterialbundles.ts
var CreateJobMaterialBundlesResponseResult$inboundSchema, CreateJobMaterialBundlesResponseResult$outboundSchema, CreateJobMaterialBundlesResponseResult$, CreateJobMaterialBundlesResponse$inboundSchema, CreateJobMaterialBundlesResponse$outboundSchema, CreateJobMaterialBundlesResponse$;
var init_createjobmaterialbundles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobMaterialBundlesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobMaterialBundlesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobMaterialBundlesResponseResult$) => {
    CreateJobMaterialBundlesResponseResult$.inboundSchema = CreateJobMaterialBundlesResponseResult$inboundSchema;
    CreateJobMaterialBundlesResponseResult$.outboundSchema = CreateJobMaterialBundlesResponseResult$outboundSchema;
  })(CreateJobMaterialBundlesResponseResult$ ||= {});
  CreateJobMaterialBundlesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobMaterialBundlesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobMaterialBundlesResponse$) => {
    CreateJobMaterialBundlesResponse$.inboundSchema = CreateJobMaterialBundlesResponse$inboundSchema;
    CreateJobMaterialBundlesResponse$.outboundSchema = CreateJobMaterialBundlesResponse$outboundSchema;
  })(CreateJobMaterialBundlesResponse$ ||= {});
});

// src/models/operations/createjobmaterials.ts
var CreateJobMaterialsResponseResult$inboundSchema, CreateJobMaterialsResponseResult$outboundSchema, CreateJobMaterialsResponseResult$, CreateJobMaterialsResponse$inboundSchema, CreateJobMaterialsResponse$outboundSchema, CreateJobMaterialsResponse$;
var init_createjobmaterials = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobMaterialsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobMaterialsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobMaterialsResponseResult$) => {
    CreateJobMaterialsResponseResult$.inboundSchema = CreateJobMaterialsResponseResult$inboundSchema;
    CreateJobMaterialsResponseResult$.outboundSchema = CreateJobMaterialsResponseResult$outboundSchema;
  })(CreateJobMaterialsResponseResult$ ||= {});
  CreateJobMaterialsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobMaterialsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobMaterialsResponse$) => {
    CreateJobMaterialsResponse$.inboundSchema = CreateJobMaterialsResponse$inboundSchema;
    CreateJobMaterialsResponse$.outboundSchema = CreateJobMaterialsResponse$outboundSchema;
  })(CreateJobMaterialsResponse$ ||= {});
});

// src/models/operations/createjobpayments.ts
var CreateJobPaymentsResponseResult$inboundSchema, CreateJobPaymentsResponseResult$outboundSchema, CreateJobPaymentsResponseResult$, CreateJobPaymentsResponse$inboundSchema, CreateJobPaymentsResponse$outboundSchema, CreateJobPaymentsResponse$;
var init_createjobpayments = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobPaymentsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobPaymentsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobPaymentsResponseResult$) => {
    CreateJobPaymentsResponseResult$.inboundSchema = CreateJobPaymentsResponseResult$inboundSchema;
    CreateJobPaymentsResponseResult$.outboundSchema = CreateJobPaymentsResponseResult$outboundSchema;
  })(CreateJobPaymentsResponseResult$ ||= {});
  CreateJobPaymentsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobPaymentsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobPaymentsResponse$) => {
    CreateJobPaymentsResponse$.inboundSchema = CreateJobPaymentsResponse$inboundSchema;
    CreateJobPaymentsResponse$.outboundSchema = CreateJobPaymentsResponse$outboundSchema;
  })(CreateJobPaymentsResponse$ ||= {});
});

// src/models/operations/createjobqueues.ts
var CreateJobQueuesResponseResult$inboundSchema, CreateJobQueuesResponseResult$outboundSchema, CreateJobQueuesResponseResult$, CreateJobQueuesResponse$inboundSchema, CreateJobQueuesResponse$outboundSchema, CreateJobQueuesResponse$;
var init_createjobqueues = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobQueuesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobQueuesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobQueuesResponseResult$) => {
    CreateJobQueuesResponseResult$.inboundSchema = CreateJobQueuesResponseResult$inboundSchema;
    CreateJobQueuesResponseResult$.outboundSchema = CreateJobQueuesResponseResult$outboundSchema;
  })(CreateJobQueuesResponseResult$ ||= {});
  CreateJobQueuesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobQueuesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobQueuesResponse$) => {
    CreateJobQueuesResponse$.inboundSchema = CreateJobQueuesResponse$inboundSchema;
    CreateJobQueuesResponse$.outboundSchema = CreateJobQueuesResponse$outboundSchema;
  })(CreateJobQueuesResponse$ ||= {});
});

// src/models/operations/createjobs.ts
var CreateJobsResponseResult$inboundSchema, CreateJobsResponseResult$outboundSchema, CreateJobsResponseResult$, CreateJobsResponse$inboundSchema, CreateJobsResponse$outboundSchema, CreateJobsResponse$;
var init_createjobs = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateJobsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateJobsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateJobsResponseResult$) => {
    CreateJobsResponseResult$.inboundSchema = CreateJobsResponseResult$inboundSchema;
    CreateJobsResponseResult$.outboundSchema = CreateJobsResponseResult$outboundSchema;
  })(CreateJobsResponseResult$ ||= {});
  CreateJobsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateJobsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateJobsResponse$) => {
    CreateJobsResponse$.inboundSchema = CreateJobsResponse$inboundSchema;
    CreateJobsResponse$.outboundSchema = CreateJobsResponse$outboundSchema;
  })(CreateJobsResponse$ ||= {});
});

// src/models/operations/createknowledgearticles.ts
var CreateKnowledgeArticlesResponseResult$inboundSchema, CreateKnowledgeArticlesResponseResult$outboundSchema, CreateKnowledgeArticlesResponseResult$, CreateKnowledgeArticlesResponse$inboundSchema, CreateKnowledgeArticlesResponse$outboundSchema, CreateKnowledgeArticlesResponse$;
var init_createknowledgearticles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateKnowledgeArticlesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateKnowledgeArticlesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateKnowledgeArticlesResponseResult$) => {
    CreateKnowledgeArticlesResponseResult$.inboundSchema = CreateKnowledgeArticlesResponseResult$inboundSchema;
    CreateKnowledgeArticlesResponseResult$.outboundSchema = CreateKnowledgeArticlesResponseResult$outboundSchema;
  })(CreateKnowledgeArticlesResponseResult$ ||= {});
  CreateKnowledgeArticlesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateKnowledgeArticlesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateKnowledgeArticlesResponse$) => {
    CreateKnowledgeArticlesResponse$.inboundSchema = CreateKnowledgeArticlesResponse$inboundSchema;
    CreateKnowledgeArticlesResponse$.outboundSchema = CreateKnowledgeArticlesResponse$outboundSchema;
  })(CreateKnowledgeArticlesResponse$ ||= {});
});

// src/models/operations/createlocations.ts
var CreateLocationsResponseResult$inboundSchema, CreateLocationsResponseResult$outboundSchema, CreateLocationsResponseResult$, CreateLocationsResponse$inboundSchema, CreateLocationsResponse$outboundSchema, CreateLocationsResponse$;
var init_createlocations = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateLocationsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateLocationsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateLocationsResponseResult$) => {
    CreateLocationsResponseResult$.inboundSchema = CreateLocationsResponseResult$inboundSchema;
    CreateLocationsResponseResult$.outboundSchema = CreateLocationsResponseResult$outboundSchema;
  })(CreateLocationsResponseResult$ ||= {});
  CreateLocationsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateLocationsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateLocationsResponse$) => {
    CreateLocationsResponse$.inboundSchema = CreateLocationsResponse$inboundSchema;
    CreateLocationsResponse$.outboundSchema = CreateLocationsResponse$outboundSchema;
  })(CreateLocationsResponse$ ||= {});
});

// src/models/operations/creatematerials.ts
var CreateMaterialsResponseResult$inboundSchema, CreateMaterialsResponseResult$outboundSchema, CreateMaterialsResponseResult$, CreateMaterialsResponse$inboundSchema, CreateMaterialsResponse$outboundSchema, CreateMaterialsResponse$;
var init_creatematerials = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateMaterialsResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateMaterialsResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateMaterialsResponseResult$) => {
    CreateMaterialsResponseResult$.inboundSchema = CreateMaterialsResponseResult$inboundSchema;
    CreateMaterialsResponseResult$.outboundSchema = CreateMaterialsResponseResult$outboundSchema;
  })(CreateMaterialsResponseResult$ ||= {});
  CreateMaterialsResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateMaterialsResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateMaterialsResponse$) => {
    CreateMaterialsResponse$.inboundSchema = CreateMaterialsResponse$inboundSchema;
    CreateMaterialsResponse$.outboundSchema = CreateMaterialsResponse$outboundSchema;
  })(CreateMaterialsResponse$ ||= {});
});

// src/models/operations/createnotes.ts
var CreateNotesResponseResult$inboundSchema, CreateNotesResponseResult$outboundSchema, CreateNotesResponseResult$, CreateNotesResponse$inboundSchema, CreateNotesResponse$outboundSchema, CreateNotesResponse$;
var init_createnotes = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateNotesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateNotesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateNotesResponseResult$) => {
    CreateNotesResponseResult$.inboundSchema = CreateNotesResponseResult$inboundSchema;
    CreateNotesResponseResult$.outboundSchema = CreateNotesResponseResult$outboundSchema;
  })(CreateNotesResponseResult$ ||= {});
  CreateNotesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateNotesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateNotesResponse$) => {
    CreateNotesResponse$.inboundSchema = CreateNotesResponse$inboundSchema;
    CreateNotesResponse$.outboundSchema = CreateNotesResponse$outboundSchema;
  })(CreateNotesResponse$ ||= {});
});

// src/models/operations/createsecurityroles.ts
var CreateSecurityRolesResponseResult$inboundSchema, CreateSecurityRolesResponseResult$outboundSchema, CreateSecurityRolesResponseResult$, CreateSecurityRolesResponse$inboundSchema, CreateSecurityRolesResponse$outboundSchema, CreateSecurityRolesResponse$;
var init_createsecurityroles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateSecurityRolesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateSecurityRolesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateSecurityRolesResponseResult$) => {
    CreateSecurityRolesResponseResult$.inboundSchema = CreateSecurityRolesResponseResult$inboundSchema;
    CreateSecurityRolesResponseResult$.outboundSchema = CreateSecurityRolesResponseResult$outboundSchema;
  })(CreateSecurityRolesResponseResult$ ||= {});
  CreateSecurityRolesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateSecurityRolesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateSecurityRolesResponse$) => {
    CreateSecurityRolesResponse$.inboundSchema = CreateSecurityRolesResponse$inboundSchema;
    CreateSecurityRolesResponse$.outboundSchema = CreateSecurityRolesResponse$outboundSchema;
  })(CreateSecurityRolesResponse$ ||= {});
});

// src/models/operations/createsmstemplates.ts
var CreateSMSTemplatesResponseResult$inboundSchema, CreateSMSTemplatesResponseResult$outboundSchema, CreateSMSTemplatesResponseResult$, CreateSMSTemplatesResponse$inboundSchema, CreateSMSTemplatesResponse$outboundSchema, CreateSMSTemplatesResponse$;
var init_createsmstemplates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateSMSTemplatesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateSMSTemplatesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateSMSTemplatesResponseResult$) => {
    CreateSMSTemplatesResponseResult$.inboundSchema = CreateSMSTemplatesResponseResult$inboundSchema;
    CreateSMSTemplatesResponseResult$.outboundSchema = CreateSMSTemplatesResponseResult$outboundSchema;
  })(CreateSMSTemplatesResponseResult$ ||= {});
  CreateSMSTemplatesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateSMSTemplatesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateSMSTemplatesResponse$) => {
    CreateSMSTemplatesResponse$.inboundSchema = CreateSMSTemplatesResponse$inboundSchema;
    CreateSMSTemplatesResponse$.outboundSchema = CreateSMSTemplatesResponse$outboundSchema;
  })(CreateSMSTemplatesResponse$ ||= {});
});

// src/models/operations/createstaffmembers.ts
var CreateStaffMembersResponseResult$inboundSchema, CreateStaffMembersResponseResult$outboundSchema, CreateStaffMembersResponseResult$, CreateStaffMembersResponse$inboundSchema, CreateStaffMembersResponse$outboundSchema, CreateStaffMembersResponse$;
var init_createstaffmembers = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateStaffMembersResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateStaffMembersResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateStaffMembersResponseResult$) => {
    CreateStaffMembersResponseResult$.inboundSchema = CreateStaffMembersResponseResult$inboundSchema;
    CreateStaffMembersResponseResult$.outboundSchema = CreateStaffMembersResponseResult$outboundSchema;
  })(CreateStaffMembersResponseResult$ ||= {});
  CreateStaffMembersResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateStaffMembersResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateStaffMembersResponse$) => {
    CreateStaffMembersResponse$.inboundSchema = CreateStaffMembersResponse$inboundSchema;
    CreateStaffMembersResponse$.outboundSchema = CreateStaffMembersResponse$outboundSchema;
  })(CreateStaffMembersResponse$ ||= {});
});

// src/models/operations/createstaffmessages.ts
var CreateStaffMessagesResponseResult$inboundSchema, CreateStaffMessagesResponseResult$outboundSchema, CreateStaffMessagesResponseResult$, CreateStaffMessagesResponse$inboundSchema, CreateStaffMessagesResponse$outboundSchema, CreateStaffMessagesResponse$;
var init_createstaffmessages = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateStaffMessagesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateStaffMessagesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateStaffMessagesResponseResult$) => {
    CreateStaffMessagesResponseResult$.inboundSchema = CreateStaffMessagesResponseResult$inboundSchema;
    CreateStaffMessagesResponseResult$.outboundSchema = CreateStaffMessagesResponseResult$outboundSchema;
  })(CreateStaffMessagesResponseResult$ ||= {});
  CreateStaffMessagesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateStaffMessagesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateStaffMessagesResponse$) => {
    CreateStaffMessagesResponse$.inboundSchema = CreateStaffMessagesResponse$inboundSchema;
    CreateStaffMessagesResponse$.outboundSchema = CreateStaffMessagesResponse$outboundSchema;
  })(CreateStaffMessagesResponse$ ||= {});
});

// src/models/operations/createtasks.ts
var CreateTasksResponseResult$inboundSchema, CreateTasksResponseResult$outboundSchema, CreateTasksResponseResult$, CreateTasksResponse$inboundSchema, CreateTasksResponse$outboundSchema, CreateTasksResponse$;
var init_createtasks = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateTasksResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateTasksResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateTasksResponseResult$) => {
    CreateTasksResponseResult$.inboundSchema = CreateTasksResponseResult$inboundSchema;
    CreateTasksResponseResult$.outboundSchema = CreateTasksResponseResult$outboundSchema;
  })(CreateTasksResponseResult$ ||= {});
  CreateTasksResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateTasksResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateTasksResponse$) => {
    CreateTasksResponse$.inboundSchema = CreateTasksResponse$inboundSchema;
    CreateTasksResponse$.outboundSchema = CreateTasksResponse$outboundSchema;
  })(CreateTasksResponse$ ||= {});
});

// src/models/operations/createtaxrates.ts
var CreateTaxRatesResponseResult$inboundSchema, CreateTaxRatesResponseResult$outboundSchema, CreateTaxRatesResponseResult$, CreateTaxRatesResponse$inboundSchema, CreateTaxRatesResponse$outboundSchema, CreateTaxRatesResponse$;
var init_createtaxrates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  CreateTaxRatesResponseResult$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  CreateTaxRatesResponseResult$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((CreateTaxRatesResponseResult$) => {
    CreateTaxRatesResponseResult$.inboundSchema = CreateTaxRatesResponseResult$inboundSchema;
    CreateTaxRatesResponseResult$.outboundSchema = CreateTaxRatesResponseResult$outboundSchema;
  })(CreateTaxRatesResponseResult$ ||= {});
  CreateTaxRatesResponse$inboundSchema = objectType({
    Headers: recordType(arrayType(stringType())),
    Result: unionType([
      Result$inboundSchema,
      ErrorT$inboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      Headers: "headers",
      Result: "result"
    });
  });
  CreateTaxRatesResponse$outboundSchema = objectType({
    headers: recordType(arrayType(stringType())),
    result: unionType([
      Result$outboundSchema,
      ErrorT$outboundSchema
    ])
  }).transform((v2) => {
    return remap(v2, {
      headers: "Headers",
      result: "Result"
    });
  });
  ((CreateTaxRatesResponse$) => {
    CreateTaxRatesResponse$.inboundSchema = CreateTaxRatesResponse$inboundSchema;
    CreateTaxRatesResponse$.outboundSchema = CreateTaxRatesResponse$outboundSchema;
  })(CreateTaxRatesResponse$ ||= {});
});

// src/models/operations/deleteallocationwindows.ts
var DeleteAllocationWindowsRequest$inboundSchema, DeleteAllocationWindowsRequest$outboundSchema, DeleteAllocationWindowsRequest$, DeleteAllocationWindowsResponse$inboundSchema, DeleteAllocationWindowsResponse$outboundSchema, DeleteAllocationWindowsResponse$;
var init_deleteallocationwindows = __esm(() => {
  init_lib();
  init_components();
  DeleteAllocationWindowsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteAllocationWindowsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteAllocationWindowsRequest$) => {
    DeleteAllocationWindowsRequest$.inboundSchema = DeleteAllocationWindowsRequest$inboundSchema;
    DeleteAllocationWindowsRequest$.outboundSchema = DeleteAllocationWindowsRequest$outboundSchema;
  })(DeleteAllocationWindowsRequest$ ||= {});
  DeleteAllocationWindowsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteAllocationWindowsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteAllocationWindowsResponse$) => {
    DeleteAllocationWindowsResponse$.inboundSchema = DeleteAllocationWindowsResponse$inboundSchema;
    DeleteAllocationWindowsResponse$.outboundSchema = DeleteAllocationWindowsResponse$outboundSchema;
  })(DeleteAllocationWindowsResponse$ ||= {});
});

// src/models/operations/deleteassets.ts
var DeleteAssetsRequest$inboundSchema, DeleteAssetsRequest$outboundSchema, DeleteAssetsRequest$, DeleteAssetsResponse$inboundSchema, DeleteAssetsResponse$outboundSchema, DeleteAssetsResponse$;
var init_deleteassets = __esm(() => {
  init_lib();
  init_components();
  DeleteAssetsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteAssetsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteAssetsRequest$) => {
    DeleteAssetsRequest$.inboundSchema = DeleteAssetsRequest$inboundSchema;
    DeleteAssetsRequest$.outboundSchema = DeleteAssetsRequest$outboundSchema;
  })(DeleteAssetsRequest$ ||= {});
  DeleteAssetsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteAssetsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteAssetsResponse$) => {
    DeleteAssetsResponse$.inboundSchema = DeleteAssetsResponse$inboundSchema;
    DeleteAssetsResponse$.outboundSchema = DeleteAssetsResponse$outboundSchema;
  })(DeleteAssetsResponse$ ||= {});
});

// src/models/operations/deleteassettypefields.ts
var DeleteAssetTypeFieldsRequest$inboundSchema, DeleteAssetTypeFieldsRequest$outboundSchema, DeleteAssetTypeFieldsRequest$, DeleteAssetTypeFieldsResponse$inboundSchema, DeleteAssetTypeFieldsResponse$outboundSchema, DeleteAssetTypeFieldsResponse$;
var init_deleteassettypefields = __esm(() => {
  init_lib();
  init_components();
  DeleteAssetTypeFieldsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteAssetTypeFieldsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteAssetTypeFieldsRequest$) => {
    DeleteAssetTypeFieldsRequest$.inboundSchema = DeleteAssetTypeFieldsRequest$inboundSchema;
    DeleteAssetTypeFieldsRequest$.outboundSchema = DeleteAssetTypeFieldsRequest$outboundSchema;
  })(DeleteAssetTypeFieldsRequest$ ||= {});
  DeleteAssetTypeFieldsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteAssetTypeFieldsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteAssetTypeFieldsResponse$) => {
    DeleteAssetTypeFieldsResponse$.inboundSchema = DeleteAssetTypeFieldsResponse$inboundSchema;
    DeleteAssetTypeFieldsResponse$.outboundSchema = DeleteAssetTypeFieldsResponse$outboundSchema;
  })(DeleteAssetTypeFieldsResponse$ ||= {});
});

// src/models/operations/deleteassettypes.ts
var DeleteAssetTypesRequest$inboundSchema, DeleteAssetTypesRequest$outboundSchema, DeleteAssetTypesRequest$, DeleteAssetTypesResponse$inboundSchema, DeleteAssetTypesResponse$outboundSchema, DeleteAssetTypesResponse$;
var init_deleteassettypes = __esm(() => {
  init_lib();
  init_components();
  DeleteAssetTypesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteAssetTypesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteAssetTypesRequest$) => {
    DeleteAssetTypesRequest$.inboundSchema = DeleteAssetTypesRequest$inboundSchema;
    DeleteAssetTypesRequest$.outboundSchema = DeleteAssetTypesRequest$outboundSchema;
  })(DeleteAssetTypesRequest$ ||= {});
  DeleteAssetTypesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteAssetTypesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteAssetTypesResponse$) => {
    DeleteAssetTypesResponse$.inboundSchema = DeleteAssetTypesResponse$inboundSchema;
    DeleteAssetTypesResponse$.outboundSchema = DeleteAssetTypesResponse$outboundSchema;
  })(DeleteAssetTypesResponse$ ||= {});
});

// src/models/operations/deleteattachments.ts
var DeleteAttachmentsRequest$inboundSchema, DeleteAttachmentsRequest$outboundSchema, DeleteAttachmentsRequest$, DeleteAttachmentsResponse$inboundSchema, DeleteAttachmentsResponse$outboundSchema, DeleteAttachmentsResponse$;
var init_deleteattachments = __esm(() => {
  init_lib();
  init_components();
  DeleteAttachmentsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteAttachmentsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteAttachmentsRequest$) => {
    DeleteAttachmentsRequest$.inboundSchema = DeleteAttachmentsRequest$inboundSchema;
    DeleteAttachmentsRequest$.outboundSchema = DeleteAttachmentsRequest$outboundSchema;
  })(DeleteAttachmentsRequest$ ||= {});
  DeleteAttachmentsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteAttachmentsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteAttachmentsResponse$) => {
    DeleteAttachmentsResponse$.inboundSchema = DeleteAttachmentsResponse$inboundSchema;
    DeleteAttachmentsResponse$.outboundSchema = DeleteAttachmentsResponse$outboundSchema;
  })(DeleteAttachmentsResponse$ ||= {});
});

// src/models/operations/deletebadges.ts
var DeleteBadgesRequest$inboundSchema, DeleteBadgesRequest$outboundSchema, DeleteBadgesRequest$, DeleteBadgesResponse$inboundSchema, DeleteBadgesResponse$outboundSchema, DeleteBadgesResponse$;
var init_deletebadges = __esm(() => {
  init_lib();
  init_components();
  DeleteBadgesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteBadgesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteBadgesRequest$) => {
    DeleteBadgesRequest$.inboundSchema = DeleteBadgesRequest$inboundSchema;
    DeleteBadgesRequest$.outboundSchema = DeleteBadgesRequest$outboundSchema;
  })(DeleteBadgesRequest$ ||= {});
  DeleteBadgesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteBadgesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteBadgesResponse$) => {
    DeleteBadgesResponse$.inboundSchema = DeleteBadgesResponse$inboundSchema;
    DeleteBadgesResponse$.outboundSchema = DeleteBadgesResponse$outboundSchema;
  })(DeleteBadgesResponse$ ||= {});
});

// src/models/operations/deletebundles.ts
var DeleteBundlesRequest$inboundSchema, DeleteBundlesRequest$outboundSchema, DeleteBundlesRequest$, DeleteBundlesResponse$inboundSchema, DeleteBundlesResponse$outboundSchema, DeleteBundlesResponse$;
var init_deletebundles = __esm(() => {
  init_lib();
  init_components();
  DeleteBundlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteBundlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteBundlesRequest$) => {
    DeleteBundlesRequest$.inboundSchema = DeleteBundlesRequest$inboundSchema;
    DeleteBundlesRequest$.outboundSchema = DeleteBundlesRequest$outboundSchema;
  })(DeleteBundlesRequest$ ||= {});
  DeleteBundlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteBundlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteBundlesResponse$) => {
    DeleteBundlesResponse$.inboundSchema = DeleteBundlesResponse$inboundSchema;
    DeleteBundlesResponse$.outboundSchema = DeleteBundlesResponse$outboundSchema;
  })(DeleteBundlesResponse$ ||= {});
});

// src/models/operations/deletecategories.ts
var DeleteCategoriesRequest$inboundSchema, DeleteCategoriesRequest$outboundSchema, DeleteCategoriesRequest$, DeleteCategoriesResponse$inboundSchema, DeleteCategoriesResponse$outboundSchema, DeleteCategoriesResponse$;
var init_deletecategories = __esm(() => {
  init_lib();
  init_components();
  DeleteCategoriesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteCategoriesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteCategoriesRequest$) => {
    DeleteCategoriesRequest$.inboundSchema = DeleteCategoriesRequest$inboundSchema;
    DeleteCategoriesRequest$.outboundSchema = DeleteCategoriesRequest$outboundSchema;
  })(DeleteCategoriesRequest$ ||= {});
  DeleteCategoriesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteCategoriesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteCategoriesResponse$) => {
    DeleteCategoriesResponse$.inboundSchema = DeleteCategoriesResponse$inboundSchema;
    DeleteCategoriesResponse$.outboundSchema = DeleteCategoriesResponse$outboundSchema;
  })(DeleteCategoriesResponse$ ||= {});
});

// src/models/operations/deleteclients.ts
var DeleteClientsRequest$inboundSchema, DeleteClientsRequest$outboundSchema, DeleteClientsRequest$, DeleteClientsResponse$inboundSchema, DeleteClientsResponse$outboundSchema, DeleteClientsResponse$;
var init_deleteclients = __esm(() => {
  init_lib();
  init_components();
  DeleteClientsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteClientsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteClientsRequest$) => {
    DeleteClientsRequest$.inboundSchema = DeleteClientsRequest$inboundSchema;
    DeleteClientsRequest$.outboundSchema = DeleteClientsRequest$outboundSchema;
  })(DeleteClientsRequest$ ||= {});
  DeleteClientsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteClientsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteClientsResponse$) => {
    DeleteClientsResponse$.inboundSchema = DeleteClientsResponse$inboundSchema;
    DeleteClientsResponse$.outboundSchema = DeleteClientsResponse$outboundSchema;
  })(DeleteClientsResponse$ ||= {});
});

// src/models/operations/deletecompanycontacts.ts
var DeleteCompanyContactsRequest$inboundSchema, DeleteCompanyContactsRequest$outboundSchema, DeleteCompanyContactsRequest$, DeleteCompanyContactsResponse$inboundSchema, DeleteCompanyContactsResponse$outboundSchema, DeleteCompanyContactsResponse$;
var init_deletecompanycontacts = __esm(() => {
  init_lib();
  init_components();
  DeleteCompanyContactsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteCompanyContactsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteCompanyContactsRequest$) => {
    DeleteCompanyContactsRequest$.inboundSchema = DeleteCompanyContactsRequest$inboundSchema;
    DeleteCompanyContactsRequest$.outboundSchema = DeleteCompanyContactsRequest$outboundSchema;
  })(DeleteCompanyContactsRequest$ ||= {});
  DeleteCompanyContactsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteCompanyContactsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteCompanyContactsResponse$) => {
    DeleteCompanyContactsResponse$.inboundSchema = DeleteCompanyContactsResponse$inboundSchema;
    DeleteCompanyContactsResponse$.outboundSchema = DeleteCompanyContactsResponse$outboundSchema;
  })(DeleteCompanyContactsResponse$ ||= {});
});

// src/models/operations/deleteemailtemplates.ts
var DeleteEmailTemplatesRequest$inboundSchema, DeleteEmailTemplatesRequest$outboundSchema, DeleteEmailTemplatesRequest$, DeleteEmailTemplatesResponse$inboundSchema, DeleteEmailTemplatesResponse$outboundSchema, DeleteEmailTemplatesResponse$;
var init_deleteemailtemplates = __esm(() => {
  init_lib();
  init_components();
  DeleteEmailTemplatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteEmailTemplatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteEmailTemplatesRequest$) => {
    DeleteEmailTemplatesRequest$.inboundSchema = DeleteEmailTemplatesRequest$inboundSchema;
    DeleteEmailTemplatesRequest$.outboundSchema = DeleteEmailTemplatesRequest$outboundSchema;
  })(DeleteEmailTemplatesRequest$ ||= {});
  DeleteEmailTemplatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteEmailTemplatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteEmailTemplatesResponse$) => {
    DeleteEmailTemplatesResponse$.inboundSchema = DeleteEmailTemplatesResponse$inboundSchema;
    DeleteEmailTemplatesResponse$.outboundSchema = DeleteEmailTemplatesResponse$outboundSchema;
  })(DeleteEmailTemplatesResponse$ ||= {});
});

// src/models/operations/deletefeedback.ts
var DeleteFeedbackRequest$inboundSchema, DeleteFeedbackRequest$outboundSchema, DeleteFeedbackRequest$, DeleteFeedbackResponse$inboundSchema, DeleteFeedbackResponse$outboundSchema, DeleteFeedbackResponse$;
var init_deletefeedback = __esm(() => {
  init_lib();
  init_components();
  DeleteFeedbackRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteFeedbackRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteFeedbackRequest$) => {
    DeleteFeedbackRequest$.inboundSchema = DeleteFeedbackRequest$inboundSchema;
    DeleteFeedbackRequest$.outboundSchema = DeleteFeedbackRequest$outboundSchema;
  })(DeleteFeedbackRequest$ ||= {});
  DeleteFeedbackResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteFeedbackResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteFeedbackResponse$) => {
    DeleteFeedbackResponse$.inboundSchema = DeleteFeedbackResponse$inboundSchema;
    DeleteFeedbackResponse$.outboundSchema = DeleteFeedbackResponse$outboundSchema;
  })(DeleteFeedbackResponse$ ||= {});
});

// src/models/operations/deleteformfields.ts
var DeleteFormFieldsRequest$inboundSchema, DeleteFormFieldsRequest$outboundSchema, DeleteFormFieldsRequest$, DeleteFormFieldsResponse$inboundSchema, DeleteFormFieldsResponse$outboundSchema, DeleteFormFieldsResponse$;
var init_deleteformfields = __esm(() => {
  init_lib();
  init_components();
  DeleteFormFieldsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteFormFieldsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteFormFieldsRequest$) => {
    DeleteFormFieldsRequest$.inboundSchema = DeleteFormFieldsRequest$inboundSchema;
    DeleteFormFieldsRequest$.outboundSchema = DeleteFormFieldsRequest$outboundSchema;
  })(DeleteFormFieldsRequest$ ||= {});
  DeleteFormFieldsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteFormFieldsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteFormFieldsResponse$) => {
    DeleteFormFieldsResponse$.inboundSchema = DeleteFormFieldsResponse$inboundSchema;
    DeleteFormFieldsResponse$.outboundSchema = DeleteFormFieldsResponse$outboundSchema;
  })(DeleteFormFieldsResponse$ ||= {});
});

// src/models/operations/deleteformresponses.ts
var DeleteFormResponsesRequest$inboundSchema, DeleteFormResponsesRequest$outboundSchema, DeleteFormResponsesRequest$, DeleteFormResponsesResponse$inboundSchema, DeleteFormResponsesResponse$outboundSchema, DeleteFormResponsesResponse$;
var init_deleteformresponses = __esm(() => {
  init_lib();
  init_components();
  DeleteFormResponsesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteFormResponsesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteFormResponsesRequest$) => {
    DeleteFormResponsesRequest$.inboundSchema = DeleteFormResponsesRequest$inboundSchema;
    DeleteFormResponsesRequest$.outboundSchema = DeleteFormResponsesRequest$outboundSchema;
  })(DeleteFormResponsesRequest$ ||= {});
  DeleteFormResponsesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteFormResponsesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteFormResponsesResponse$) => {
    DeleteFormResponsesResponse$.inboundSchema = DeleteFormResponsesResponse$inboundSchema;
    DeleteFormResponsesResponse$.outboundSchema = DeleteFormResponsesResponse$outboundSchema;
  })(DeleteFormResponsesResponse$ ||= {});
});

// src/models/operations/deleteforms.ts
var DeleteFormsRequest$inboundSchema, DeleteFormsRequest$outboundSchema, DeleteFormsRequest$, DeleteFormsResponse$inboundSchema, DeleteFormsResponse$outboundSchema, DeleteFormsResponse$;
var init_deleteforms = __esm(() => {
  init_lib();
  init_components();
  DeleteFormsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteFormsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteFormsRequest$) => {
    DeleteFormsRequest$.inboundSchema = DeleteFormsRequest$inboundSchema;
    DeleteFormsRequest$.outboundSchema = DeleteFormsRequest$outboundSchema;
  })(DeleteFormsRequest$ ||= {});
  DeleteFormsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteFormsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteFormsResponse$) => {
    DeleteFormsResponse$.inboundSchema = DeleteFormsResponse$inboundSchema;
    DeleteFormsResponse$.outboundSchema = DeleteFormsResponse$outboundSchema;
  })(DeleteFormsResponse$ ||= {});
});

// src/models/operations/deletejobactivities.ts
var DeleteJobActivitiesRequest$inboundSchema, DeleteJobActivitiesRequest$outboundSchema, DeleteJobActivitiesRequest$, DeleteJobActivitiesResponse$inboundSchema, DeleteJobActivitiesResponse$outboundSchema, DeleteJobActivitiesResponse$;
var init_deletejobactivities = __esm(() => {
  init_lib();
  init_components();
  DeleteJobActivitiesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobActivitiesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobActivitiesRequest$) => {
    DeleteJobActivitiesRequest$.inboundSchema = DeleteJobActivitiesRequest$inboundSchema;
    DeleteJobActivitiesRequest$.outboundSchema = DeleteJobActivitiesRequest$outboundSchema;
  })(DeleteJobActivitiesRequest$ ||= {});
  DeleteJobActivitiesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobActivitiesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobActivitiesResponse$) => {
    DeleteJobActivitiesResponse$.inboundSchema = DeleteJobActivitiesResponse$inboundSchema;
    DeleteJobActivitiesResponse$.outboundSchema = DeleteJobActivitiesResponse$outboundSchema;
  })(DeleteJobActivitiesResponse$ ||= {});
});

// src/models/operations/deletejoballocations.ts
var DeleteJobAllocationsRequest$inboundSchema, DeleteJobAllocationsRequest$outboundSchema, DeleteJobAllocationsRequest$, DeleteJobAllocationsResponse$inboundSchema, DeleteJobAllocationsResponse$outboundSchema, DeleteJobAllocationsResponse$;
var init_deletejoballocations = __esm(() => {
  init_lib();
  init_components();
  DeleteJobAllocationsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobAllocationsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobAllocationsRequest$) => {
    DeleteJobAllocationsRequest$.inboundSchema = DeleteJobAllocationsRequest$inboundSchema;
    DeleteJobAllocationsRequest$.outboundSchema = DeleteJobAllocationsRequest$outboundSchema;
  })(DeleteJobAllocationsRequest$ ||= {});
  DeleteJobAllocationsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobAllocationsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobAllocationsResponse$) => {
    DeleteJobAllocationsResponse$.inboundSchema = DeleteJobAllocationsResponse$inboundSchema;
    DeleteJobAllocationsResponse$.outboundSchema = DeleteJobAllocationsResponse$outboundSchema;
  })(DeleteJobAllocationsResponse$ ||= {});
});

// src/models/operations/deletejobchecklists.ts
var DeleteJobChecklistsRequest$inboundSchema, DeleteJobChecklistsRequest$outboundSchema, DeleteJobChecklistsRequest$, DeleteJobChecklistsResponse$inboundSchema, DeleteJobChecklistsResponse$outboundSchema, DeleteJobChecklistsResponse$;
var init_deletejobchecklists = __esm(() => {
  init_lib();
  init_components();
  DeleteJobChecklistsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobChecklistsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobChecklistsRequest$) => {
    DeleteJobChecklistsRequest$.inboundSchema = DeleteJobChecklistsRequest$inboundSchema;
    DeleteJobChecklistsRequest$.outboundSchema = DeleteJobChecklistsRequest$outboundSchema;
  })(DeleteJobChecklistsRequest$ ||= {});
  DeleteJobChecklistsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobChecklistsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobChecklistsResponse$) => {
    DeleteJobChecklistsResponse$.inboundSchema = DeleteJobChecklistsResponse$inboundSchema;
    DeleteJobChecklistsResponse$.outboundSchema = DeleteJobChecklistsResponse$outboundSchema;
  })(DeleteJobChecklistsResponse$ ||= {});
});

// src/models/operations/deletejobcontacts.ts
var DeleteJobContactsRequest$inboundSchema, DeleteJobContactsRequest$outboundSchema, DeleteJobContactsRequest$, DeleteJobContactsResponse$inboundSchema, DeleteJobContactsResponse$outboundSchema, DeleteJobContactsResponse$;
var init_deletejobcontacts = __esm(() => {
  init_lib();
  init_components();
  DeleteJobContactsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobContactsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobContactsRequest$) => {
    DeleteJobContactsRequest$.inboundSchema = DeleteJobContactsRequest$inboundSchema;
    DeleteJobContactsRequest$.outboundSchema = DeleteJobContactsRequest$outboundSchema;
  })(DeleteJobContactsRequest$ ||= {});
  DeleteJobContactsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobContactsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobContactsResponse$) => {
    DeleteJobContactsResponse$.inboundSchema = DeleteJobContactsResponse$inboundSchema;
    DeleteJobContactsResponse$.outboundSchema = DeleteJobContactsResponse$outboundSchema;
  })(DeleteJobContactsResponse$ ||= {});
});

// src/models/operations/deletejobmaterialbundles.ts
var DeleteJobMaterialBundlesRequest$inboundSchema, DeleteJobMaterialBundlesRequest$outboundSchema, DeleteJobMaterialBundlesRequest$, DeleteJobMaterialBundlesResponse$inboundSchema, DeleteJobMaterialBundlesResponse$outboundSchema, DeleteJobMaterialBundlesResponse$;
var init_deletejobmaterialbundles = __esm(() => {
  init_lib();
  init_components();
  DeleteJobMaterialBundlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobMaterialBundlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobMaterialBundlesRequest$) => {
    DeleteJobMaterialBundlesRequest$.inboundSchema = DeleteJobMaterialBundlesRequest$inboundSchema;
    DeleteJobMaterialBundlesRequest$.outboundSchema = DeleteJobMaterialBundlesRequest$outboundSchema;
  })(DeleteJobMaterialBundlesRequest$ ||= {});
  DeleteJobMaterialBundlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobMaterialBundlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobMaterialBundlesResponse$) => {
    DeleteJobMaterialBundlesResponse$.inboundSchema = DeleteJobMaterialBundlesResponse$inboundSchema;
    DeleteJobMaterialBundlesResponse$.outboundSchema = DeleteJobMaterialBundlesResponse$outboundSchema;
  })(DeleteJobMaterialBundlesResponse$ ||= {});
});

// src/models/operations/deletejobmaterials.ts
var DeleteJobMaterialsRequest$inboundSchema, DeleteJobMaterialsRequest$outboundSchema, DeleteJobMaterialsRequest$, DeleteJobMaterialsResponse$inboundSchema, DeleteJobMaterialsResponse$outboundSchema, DeleteJobMaterialsResponse$;
var init_deletejobmaterials = __esm(() => {
  init_lib();
  init_components();
  DeleteJobMaterialsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobMaterialsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobMaterialsRequest$) => {
    DeleteJobMaterialsRequest$.inboundSchema = DeleteJobMaterialsRequest$inboundSchema;
    DeleteJobMaterialsRequest$.outboundSchema = DeleteJobMaterialsRequest$outboundSchema;
  })(DeleteJobMaterialsRequest$ ||= {});
  DeleteJobMaterialsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobMaterialsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobMaterialsResponse$) => {
    DeleteJobMaterialsResponse$.inboundSchema = DeleteJobMaterialsResponse$inboundSchema;
    DeleteJobMaterialsResponse$.outboundSchema = DeleteJobMaterialsResponse$outboundSchema;
  })(DeleteJobMaterialsResponse$ ||= {});
});

// src/models/operations/deletejobpayments.ts
var DeleteJobPaymentsRequest$inboundSchema, DeleteJobPaymentsRequest$outboundSchema, DeleteJobPaymentsRequest$, DeleteJobPaymentsResponse$inboundSchema, DeleteJobPaymentsResponse$outboundSchema, DeleteJobPaymentsResponse$;
var init_deletejobpayments = __esm(() => {
  init_lib();
  init_components();
  DeleteJobPaymentsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobPaymentsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobPaymentsRequest$) => {
    DeleteJobPaymentsRequest$.inboundSchema = DeleteJobPaymentsRequest$inboundSchema;
    DeleteJobPaymentsRequest$.outboundSchema = DeleteJobPaymentsRequest$outboundSchema;
  })(DeleteJobPaymentsRequest$ ||= {});
  DeleteJobPaymentsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobPaymentsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobPaymentsResponse$) => {
    DeleteJobPaymentsResponse$.inboundSchema = DeleteJobPaymentsResponse$inboundSchema;
    DeleteJobPaymentsResponse$.outboundSchema = DeleteJobPaymentsResponse$outboundSchema;
  })(DeleteJobPaymentsResponse$ ||= {});
});

// src/models/operations/deletejobqueues.ts
var DeleteJobQueuesRequest$inboundSchema, DeleteJobQueuesRequest$outboundSchema, DeleteJobQueuesRequest$, DeleteJobQueuesResponse$inboundSchema, DeleteJobQueuesResponse$outboundSchema, DeleteJobQueuesResponse$;
var init_deletejobqueues = __esm(() => {
  init_lib();
  init_components();
  DeleteJobQueuesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobQueuesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobQueuesRequest$) => {
    DeleteJobQueuesRequest$.inboundSchema = DeleteJobQueuesRequest$inboundSchema;
    DeleteJobQueuesRequest$.outboundSchema = DeleteJobQueuesRequest$outboundSchema;
  })(DeleteJobQueuesRequest$ ||= {});
  DeleteJobQueuesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobQueuesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobQueuesResponse$) => {
    DeleteJobQueuesResponse$.inboundSchema = DeleteJobQueuesResponse$inboundSchema;
    DeleteJobQueuesResponse$.outboundSchema = DeleteJobQueuesResponse$outboundSchema;
  })(DeleteJobQueuesResponse$ ||= {});
});

// src/models/operations/deletejobs.ts
var DeleteJobsRequest$inboundSchema, DeleteJobsRequest$outboundSchema, DeleteJobsRequest$, DeleteJobsResponse$inboundSchema, DeleteJobsResponse$outboundSchema, DeleteJobsResponse$;
var init_deletejobs = __esm(() => {
  init_lib();
  init_components();
  DeleteJobsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteJobsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteJobsRequest$) => {
    DeleteJobsRequest$.inboundSchema = DeleteJobsRequest$inboundSchema;
    DeleteJobsRequest$.outboundSchema = DeleteJobsRequest$outboundSchema;
  })(DeleteJobsRequest$ ||= {});
  DeleteJobsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteJobsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteJobsResponse$) => {
    DeleteJobsResponse$.inboundSchema = DeleteJobsResponse$inboundSchema;
    DeleteJobsResponse$.outboundSchema = DeleteJobsResponse$outboundSchema;
  })(DeleteJobsResponse$ ||= {});
});

// src/models/operations/deleteknowledgearticles.ts
var DeleteKnowledgeArticlesRequest$inboundSchema, DeleteKnowledgeArticlesRequest$outboundSchema, DeleteKnowledgeArticlesRequest$, DeleteKnowledgeArticlesResponse$inboundSchema, DeleteKnowledgeArticlesResponse$outboundSchema, DeleteKnowledgeArticlesResponse$;
var init_deleteknowledgearticles = __esm(() => {
  init_lib();
  init_components();
  DeleteKnowledgeArticlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteKnowledgeArticlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteKnowledgeArticlesRequest$) => {
    DeleteKnowledgeArticlesRequest$.inboundSchema = DeleteKnowledgeArticlesRequest$inboundSchema;
    DeleteKnowledgeArticlesRequest$.outboundSchema = DeleteKnowledgeArticlesRequest$outboundSchema;
  })(DeleteKnowledgeArticlesRequest$ ||= {});
  DeleteKnowledgeArticlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteKnowledgeArticlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteKnowledgeArticlesResponse$) => {
    DeleteKnowledgeArticlesResponse$.inboundSchema = DeleteKnowledgeArticlesResponse$inboundSchema;
    DeleteKnowledgeArticlesResponse$.outboundSchema = DeleteKnowledgeArticlesResponse$outboundSchema;
  })(DeleteKnowledgeArticlesResponse$ ||= {});
});

// src/models/operations/deletelocations.ts
var DeleteLocationsRequest$inboundSchema, DeleteLocationsRequest$outboundSchema, DeleteLocationsRequest$, DeleteLocationsResponse$inboundSchema, DeleteLocationsResponse$outboundSchema, DeleteLocationsResponse$;
var init_deletelocations = __esm(() => {
  init_lib();
  init_components();
  DeleteLocationsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteLocationsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteLocationsRequest$) => {
    DeleteLocationsRequest$.inboundSchema = DeleteLocationsRequest$inboundSchema;
    DeleteLocationsRequest$.outboundSchema = DeleteLocationsRequest$outboundSchema;
  })(DeleteLocationsRequest$ ||= {});
  DeleteLocationsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteLocationsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteLocationsResponse$) => {
    DeleteLocationsResponse$.inboundSchema = DeleteLocationsResponse$inboundSchema;
    DeleteLocationsResponse$.outboundSchema = DeleteLocationsResponse$outboundSchema;
  })(DeleteLocationsResponse$ ||= {});
});

// src/models/operations/deletematerials.ts
var DeleteMaterialsRequest$inboundSchema, DeleteMaterialsRequest$outboundSchema, DeleteMaterialsRequest$, DeleteMaterialsResponse$inboundSchema, DeleteMaterialsResponse$outboundSchema, DeleteMaterialsResponse$;
var init_deletematerials = __esm(() => {
  init_lib();
  init_components();
  DeleteMaterialsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteMaterialsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteMaterialsRequest$) => {
    DeleteMaterialsRequest$.inboundSchema = DeleteMaterialsRequest$inboundSchema;
    DeleteMaterialsRequest$.outboundSchema = DeleteMaterialsRequest$outboundSchema;
  })(DeleteMaterialsRequest$ ||= {});
  DeleteMaterialsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteMaterialsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteMaterialsResponse$) => {
    DeleteMaterialsResponse$.inboundSchema = DeleteMaterialsResponse$inboundSchema;
    DeleteMaterialsResponse$.outboundSchema = DeleteMaterialsResponse$outboundSchema;
  })(DeleteMaterialsResponse$ ||= {});
});

// src/models/operations/deletenotes.ts
var DeleteNotesRequest$inboundSchema, DeleteNotesRequest$outboundSchema, DeleteNotesRequest$, DeleteNotesResponse$inboundSchema, DeleteNotesResponse$outboundSchema, DeleteNotesResponse$;
var init_deletenotes = __esm(() => {
  init_lib();
  init_components();
  DeleteNotesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteNotesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteNotesRequest$) => {
    DeleteNotesRequest$.inboundSchema = DeleteNotesRequest$inboundSchema;
    DeleteNotesRequest$.outboundSchema = DeleteNotesRequest$outboundSchema;
  })(DeleteNotesRequest$ ||= {});
  DeleteNotesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteNotesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteNotesResponse$) => {
    DeleteNotesResponse$.inboundSchema = DeleteNotesResponse$inboundSchema;
    DeleteNotesResponse$.outboundSchema = DeleteNotesResponse$outboundSchema;
  })(DeleteNotesResponse$ ||= {});
});

// src/models/operations/deletesecurityroles.ts
var DeleteSecurityRolesRequest$inboundSchema, DeleteSecurityRolesRequest$outboundSchema, DeleteSecurityRolesRequest$, DeleteSecurityRolesResponse$inboundSchema, DeleteSecurityRolesResponse$outboundSchema, DeleteSecurityRolesResponse$;
var init_deletesecurityroles = __esm(() => {
  init_lib();
  init_components();
  DeleteSecurityRolesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteSecurityRolesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteSecurityRolesRequest$) => {
    DeleteSecurityRolesRequest$.inboundSchema = DeleteSecurityRolesRequest$inboundSchema;
    DeleteSecurityRolesRequest$.outboundSchema = DeleteSecurityRolesRequest$outboundSchema;
  })(DeleteSecurityRolesRequest$ ||= {});
  DeleteSecurityRolesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteSecurityRolesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteSecurityRolesResponse$) => {
    DeleteSecurityRolesResponse$.inboundSchema = DeleteSecurityRolesResponse$inboundSchema;
    DeleteSecurityRolesResponse$.outboundSchema = DeleteSecurityRolesResponse$outboundSchema;
  })(DeleteSecurityRolesResponse$ ||= {});
});

// src/models/operations/deletesmstemplates.ts
var DeleteSMSTemplatesRequest$inboundSchema, DeleteSMSTemplatesRequest$outboundSchema, DeleteSMSTemplatesRequest$, DeleteSMSTemplatesResponse$inboundSchema, DeleteSMSTemplatesResponse$outboundSchema, DeleteSMSTemplatesResponse$;
var init_deletesmstemplates = __esm(() => {
  init_lib();
  init_components();
  DeleteSMSTemplatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteSMSTemplatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteSMSTemplatesRequest$) => {
    DeleteSMSTemplatesRequest$.inboundSchema = DeleteSMSTemplatesRequest$inboundSchema;
    DeleteSMSTemplatesRequest$.outboundSchema = DeleteSMSTemplatesRequest$outboundSchema;
  })(DeleteSMSTemplatesRequest$ ||= {});
  DeleteSMSTemplatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteSMSTemplatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteSMSTemplatesResponse$) => {
    DeleteSMSTemplatesResponse$.inboundSchema = DeleteSMSTemplatesResponse$inboundSchema;
    DeleteSMSTemplatesResponse$.outboundSchema = DeleteSMSTemplatesResponse$outboundSchema;
  })(DeleteSMSTemplatesResponse$ ||= {});
});

// src/models/operations/deletestaffmembers.ts
var DeleteStaffMembersRequest$inboundSchema, DeleteStaffMembersRequest$outboundSchema, DeleteStaffMembersRequest$, DeleteStaffMembersResponse$inboundSchema, DeleteStaffMembersResponse$outboundSchema, DeleteStaffMembersResponse$;
var init_deletestaffmembers = __esm(() => {
  init_lib();
  init_components();
  DeleteStaffMembersRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteStaffMembersRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteStaffMembersRequest$) => {
    DeleteStaffMembersRequest$.inboundSchema = DeleteStaffMembersRequest$inboundSchema;
    DeleteStaffMembersRequest$.outboundSchema = DeleteStaffMembersRequest$outboundSchema;
  })(DeleteStaffMembersRequest$ ||= {});
  DeleteStaffMembersResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteStaffMembersResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteStaffMembersResponse$) => {
    DeleteStaffMembersResponse$.inboundSchema = DeleteStaffMembersResponse$inboundSchema;
    DeleteStaffMembersResponse$.outboundSchema = DeleteStaffMembersResponse$outboundSchema;
  })(DeleteStaffMembersResponse$ ||= {});
});

// src/models/operations/deletestaffmessages.ts
var DeleteStaffMessagesRequest$inboundSchema, DeleteStaffMessagesRequest$outboundSchema, DeleteStaffMessagesRequest$, DeleteStaffMessagesResponse$inboundSchema, DeleteStaffMessagesResponse$outboundSchema, DeleteStaffMessagesResponse$;
var init_deletestaffmessages = __esm(() => {
  init_lib();
  init_components();
  DeleteStaffMessagesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteStaffMessagesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteStaffMessagesRequest$) => {
    DeleteStaffMessagesRequest$.inboundSchema = DeleteStaffMessagesRequest$inboundSchema;
    DeleteStaffMessagesRequest$.outboundSchema = DeleteStaffMessagesRequest$outboundSchema;
  })(DeleteStaffMessagesRequest$ ||= {});
  DeleteStaffMessagesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteStaffMessagesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteStaffMessagesResponse$) => {
    DeleteStaffMessagesResponse$.inboundSchema = DeleteStaffMessagesResponse$inboundSchema;
    DeleteStaffMessagesResponse$.outboundSchema = DeleteStaffMessagesResponse$outboundSchema;
  })(DeleteStaffMessagesResponse$ ||= {});
});

// src/models/operations/deletetasks.ts
var DeleteTasksRequest$inboundSchema, DeleteTasksRequest$outboundSchema, DeleteTasksRequest$, DeleteTasksResponse$inboundSchema, DeleteTasksResponse$outboundSchema, DeleteTasksResponse$;
var init_deletetasks = __esm(() => {
  init_lib();
  init_components();
  DeleteTasksRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteTasksRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteTasksRequest$) => {
    DeleteTasksRequest$.inboundSchema = DeleteTasksRequest$inboundSchema;
    DeleteTasksRequest$.outboundSchema = DeleteTasksRequest$outboundSchema;
  })(DeleteTasksRequest$ ||= {});
  DeleteTasksResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteTasksResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteTasksResponse$) => {
    DeleteTasksResponse$.inboundSchema = DeleteTasksResponse$inboundSchema;
    DeleteTasksResponse$.outboundSchema = DeleteTasksResponse$outboundSchema;
  })(DeleteTasksResponse$ ||= {});
});

// src/models/operations/deletetaxrates.ts
var DeleteTaxRatesRequest$inboundSchema, DeleteTaxRatesRequest$outboundSchema, DeleteTaxRatesRequest$, DeleteTaxRatesResponse$inboundSchema, DeleteTaxRatesResponse$outboundSchema, DeleteTaxRatesResponse$;
var init_deletetaxrates = __esm(() => {
  init_lib();
  init_components();
  DeleteTaxRatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  DeleteTaxRatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((DeleteTaxRatesRequest$) => {
    DeleteTaxRatesRequest$.inboundSchema = DeleteTaxRatesRequest$inboundSchema;
    DeleteTaxRatesRequest$.outboundSchema = DeleteTaxRatesRequest$outboundSchema;
  })(DeleteTaxRatesRequest$ ||= {});
  DeleteTaxRatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  DeleteTaxRatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((DeleteTaxRatesResponse$) => {
    DeleteTaxRatesResponse$.inboundSchema = DeleteTaxRatesResponse$inboundSchema;
    DeleteTaxRatesResponse$.outboundSchema = DeleteTaxRatesResponse$outboundSchema;
  })(DeleteTaxRatesResponse$ ||= {});
});

// src/models/operations/getallocationwindows.ts
var GetAllocationWindowsRequest$inboundSchema, GetAllocationWindowsRequest$outboundSchema, GetAllocationWindowsRequest$, GetAllocationWindowsResponse$inboundSchema, GetAllocationWindowsResponse$outboundSchema, GetAllocationWindowsResponse$;
var init_getallocationwindows = __esm(() => {
  init_lib();
  init_components();
  GetAllocationWindowsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetAllocationWindowsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetAllocationWindowsRequest$) => {
    GetAllocationWindowsRequest$.inboundSchema = GetAllocationWindowsRequest$inboundSchema;
    GetAllocationWindowsRequest$.outboundSchema = GetAllocationWindowsRequest$outboundSchema;
  })(GetAllocationWindowsRequest$ ||= {});
  GetAllocationWindowsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    AllocationWindow$inboundSchema
  ]);
  GetAllocationWindowsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    AllocationWindow$outboundSchema
  ]);
  ((GetAllocationWindowsResponse$) => {
    GetAllocationWindowsResponse$.inboundSchema = GetAllocationWindowsResponse$inboundSchema;
    GetAllocationWindowsResponse$.outboundSchema = GetAllocationWindowsResponse$outboundSchema;
  })(GetAllocationWindowsResponse$ ||= {});
});

// src/models/operations/getassets.ts
var GetAssetsRequest$inboundSchema, GetAssetsRequest$outboundSchema, GetAssetsRequest$, GetAssetsResponse$inboundSchema, GetAssetsResponse$outboundSchema, GetAssetsResponse$;
var init_getassets = __esm(() => {
  init_lib();
  init_components();
  GetAssetsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetAssetsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetAssetsRequest$) => {
    GetAssetsRequest$.inboundSchema = GetAssetsRequest$inboundSchema;
    GetAssetsRequest$.outboundSchema = GetAssetsRequest$outboundSchema;
  })(GetAssetsRequest$ ||= {});
  GetAssetsResponse$inboundSchema = unionType([ErrorT$inboundSchema, Asset$inboundSchema]);
  GetAssetsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Asset$outboundSchema
  ]);
  ((GetAssetsResponse$) => {
    GetAssetsResponse$.inboundSchema = GetAssetsResponse$inboundSchema;
    GetAssetsResponse$.outboundSchema = GetAssetsResponse$outboundSchema;
  })(GetAssetsResponse$ ||= {});
});

// src/models/operations/getassettypefields.ts
var GetAssetTypeFieldsRequest$inboundSchema, GetAssetTypeFieldsRequest$outboundSchema, GetAssetTypeFieldsRequest$, GetAssetTypeFieldsResponse$inboundSchema, GetAssetTypeFieldsResponse$outboundSchema, GetAssetTypeFieldsResponse$;
var init_getassettypefields = __esm(() => {
  init_lib();
  init_components();
  GetAssetTypeFieldsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetAssetTypeFieldsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetAssetTypeFieldsRequest$) => {
    GetAssetTypeFieldsRequest$.inboundSchema = GetAssetTypeFieldsRequest$inboundSchema;
    GetAssetTypeFieldsRequest$.outboundSchema = GetAssetTypeFieldsRequest$outboundSchema;
  })(GetAssetTypeFieldsRequest$ ||= {});
  GetAssetTypeFieldsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    AssetTypeField$inboundSchema
  ]);
  GetAssetTypeFieldsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    AssetTypeField$outboundSchema
  ]);
  ((GetAssetTypeFieldsResponse$) => {
    GetAssetTypeFieldsResponse$.inboundSchema = GetAssetTypeFieldsResponse$inboundSchema;
    GetAssetTypeFieldsResponse$.outboundSchema = GetAssetTypeFieldsResponse$outboundSchema;
  })(GetAssetTypeFieldsResponse$ ||= {});
});

// src/models/operations/getassettypes.ts
var GetAssetTypesRequest$inboundSchema, GetAssetTypesRequest$outboundSchema, GetAssetTypesRequest$, GetAssetTypesResponse$inboundSchema, GetAssetTypesResponse$outboundSchema, GetAssetTypesResponse$;
var init_getassettypes = __esm(() => {
  init_lib();
  init_components();
  GetAssetTypesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetAssetTypesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetAssetTypesRequest$) => {
    GetAssetTypesRequest$.inboundSchema = GetAssetTypesRequest$inboundSchema;
    GetAssetTypesRequest$.outboundSchema = GetAssetTypesRequest$outboundSchema;
  })(GetAssetTypesRequest$ ||= {});
  GetAssetTypesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    AssetType$inboundSchema
  ]);
  GetAssetTypesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    AssetType$outboundSchema
  ]);
  ((GetAssetTypesResponse$) => {
    GetAssetTypesResponse$.inboundSchema = GetAssetTypesResponse$inboundSchema;
    GetAssetTypesResponse$.outboundSchema = GetAssetTypesResponse$outboundSchema;
  })(GetAssetTypesResponse$ ||= {});
});

// src/models/operations/getattachments.ts
var GetAttachmentsRequest$inboundSchema, GetAttachmentsRequest$outboundSchema, GetAttachmentsRequest$, GetAttachmentsResponse$inboundSchema, GetAttachmentsResponse$outboundSchema, GetAttachmentsResponse$;
var init_getattachments = __esm(() => {
  init_lib();
  init_components();
  GetAttachmentsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetAttachmentsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetAttachmentsRequest$) => {
    GetAttachmentsRequest$.inboundSchema = GetAttachmentsRequest$inboundSchema;
    GetAttachmentsRequest$.outboundSchema = GetAttachmentsRequest$outboundSchema;
  })(GetAttachmentsRequest$ ||= {});
  GetAttachmentsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Attachment$inboundSchema
  ]);
  GetAttachmentsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Attachment$outboundSchema
  ]);
  ((GetAttachmentsResponse$) => {
    GetAttachmentsResponse$.inboundSchema = GetAttachmentsResponse$inboundSchema;
    GetAttachmentsResponse$.outboundSchema = GetAttachmentsResponse$outboundSchema;
  })(GetAttachmentsResponse$ ||= {});
});

// src/models/operations/getbadges.ts
var GetBadgesRequest$inboundSchema, GetBadgesRequest$outboundSchema, GetBadgesRequest$, GetBadgesResponse$inboundSchema, GetBadgesResponse$outboundSchema, GetBadgesResponse$;
var init_getbadges = __esm(() => {
  init_lib();
  init_components();
  GetBadgesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetBadgesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetBadgesRequest$) => {
    GetBadgesRequest$.inboundSchema = GetBadgesRequest$inboundSchema;
    GetBadgesRequest$.outboundSchema = GetBadgesRequest$outboundSchema;
  })(GetBadgesRequest$ ||= {});
  GetBadgesResponse$inboundSchema = unionType([ErrorT$inboundSchema, Badge$inboundSchema]);
  GetBadgesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Badge$outboundSchema
  ]);
  ((GetBadgesResponse$) => {
    GetBadgesResponse$.inboundSchema = GetBadgesResponse$inboundSchema;
    GetBadgesResponse$.outboundSchema = GetBadgesResponse$outboundSchema;
  })(GetBadgesResponse$ ||= {});
});

// src/models/operations/getbundles.ts
var GetBundlesRequest$inboundSchema, GetBundlesRequest$outboundSchema, GetBundlesRequest$, GetBundlesResponse$inboundSchema, GetBundlesResponse$outboundSchema, GetBundlesResponse$;
var init_getbundles = __esm(() => {
  init_lib();
  init_components();
  GetBundlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetBundlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetBundlesRequest$) => {
    GetBundlesRequest$.inboundSchema = GetBundlesRequest$inboundSchema;
    GetBundlesRequest$.outboundSchema = GetBundlesRequest$outboundSchema;
  })(GetBundlesRequest$ ||= {});
  GetBundlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    MaterialBundle$inboundSchema
  ]);
  GetBundlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    MaterialBundle$outboundSchema
  ]);
  ((GetBundlesResponse$) => {
    GetBundlesResponse$.inboundSchema = GetBundlesResponse$inboundSchema;
    GetBundlesResponse$.outboundSchema = GetBundlesResponse$outboundSchema;
  })(GetBundlesResponse$ ||= {});
});

// src/models/operations/getcategories.ts
var GetCategoriesRequest$inboundSchema, GetCategoriesRequest$outboundSchema, GetCategoriesRequest$, GetCategoriesResponse$inboundSchema, GetCategoriesResponse$outboundSchema, GetCategoriesResponse$;
var init_getcategories = __esm(() => {
  init_lib();
  init_components();
  GetCategoriesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetCategoriesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetCategoriesRequest$) => {
    GetCategoriesRequest$.inboundSchema = GetCategoriesRequest$inboundSchema;
    GetCategoriesRequest$.outboundSchema = GetCategoriesRequest$outboundSchema;
  })(GetCategoriesRequest$ ||= {});
  GetCategoriesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Category$inboundSchema
  ]);
  GetCategoriesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Category$outboundSchema
  ]);
  ((GetCategoriesResponse$) => {
    GetCategoriesResponse$.inboundSchema = GetCategoriesResponse$inboundSchema;
    GetCategoriesResponse$.outboundSchema = GetCategoriesResponse$outboundSchema;
  })(GetCategoriesResponse$ ||= {});
});

// src/models/operations/getclients.ts
var GetClientsRequest$inboundSchema, GetClientsRequest$outboundSchema, GetClientsRequest$, GetClientsResponse$inboundSchema, GetClientsResponse$outboundSchema, GetClientsResponse$;
var init_getclients = __esm(() => {
  init_lib();
  init_components();
  GetClientsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetClientsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetClientsRequest$) => {
    GetClientsRequest$.inboundSchema = GetClientsRequest$inboundSchema;
    GetClientsRequest$.outboundSchema = GetClientsRequest$outboundSchema;
  })(GetClientsRequest$ ||= {});
  GetClientsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Company$inboundSchema
  ]);
  GetClientsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Company$outboundSchema
  ]);
  ((GetClientsResponse$) => {
    GetClientsResponse$.inboundSchema = GetClientsResponse$inboundSchema;
    GetClientsResponse$.outboundSchema = GetClientsResponse$outboundSchema;
  })(GetClientsResponse$ ||= {});
});

// src/models/operations/getcompanycontacts.ts
var GetCompanyContactsRequest$inboundSchema, GetCompanyContactsRequest$outboundSchema, GetCompanyContactsRequest$, GetCompanyContactsResponse$inboundSchema, GetCompanyContactsResponse$outboundSchema, GetCompanyContactsResponse$;
var init_getcompanycontacts = __esm(() => {
  init_lib();
  init_components();
  GetCompanyContactsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetCompanyContactsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetCompanyContactsRequest$) => {
    GetCompanyContactsRequest$.inboundSchema = GetCompanyContactsRequest$inboundSchema;
    GetCompanyContactsRequest$.outboundSchema = GetCompanyContactsRequest$outboundSchema;
  })(GetCompanyContactsRequest$ ||= {});
  GetCompanyContactsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    CompanyContact$inboundSchema
  ]);
  GetCompanyContactsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    CompanyContact$outboundSchema
  ]);
  ((GetCompanyContactsResponse$) => {
    GetCompanyContactsResponse$.inboundSchema = GetCompanyContactsResponse$inboundSchema;
    GetCompanyContactsResponse$.outboundSchema = GetCompanyContactsResponse$outboundSchema;
  })(GetCompanyContactsResponse$ ||= {});
});

// src/models/operations/getemailtemplates.ts
var GetEmailTemplatesRequest$inboundSchema, GetEmailTemplatesRequest$outboundSchema, GetEmailTemplatesRequest$, GetEmailTemplatesResponse$inboundSchema, GetEmailTemplatesResponse$outboundSchema, GetEmailTemplatesResponse$;
var init_getemailtemplates = __esm(() => {
  init_lib();
  init_components();
  GetEmailTemplatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetEmailTemplatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetEmailTemplatesRequest$) => {
    GetEmailTemplatesRequest$.inboundSchema = GetEmailTemplatesRequest$inboundSchema;
    GetEmailTemplatesRequest$.outboundSchema = GetEmailTemplatesRequest$outboundSchema;
  })(GetEmailTemplatesRequest$ ||= {});
  GetEmailTemplatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    EmailTemplate$inboundSchema
  ]);
  GetEmailTemplatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    EmailTemplate$outboundSchema
  ]);
  ((GetEmailTemplatesResponse$) => {
    GetEmailTemplatesResponse$.inboundSchema = GetEmailTemplatesResponse$inboundSchema;
    GetEmailTemplatesResponse$.outboundSchema = GetEmailTemplatesResponse$outboundSchema;
  })(GetEmailTemplatesResponse$ ||= {});
});

// src/models/operations/getfeedback.ts
var GetFeedbackRequest$inboundSchema, GetFeedbackRequest$outboundSchema, GetFeedbackRequest$, GetFeedbackResponse$inboundSchema, GetFeedbackResponse$outboundSchema, GetFeedbackResponse$;
var init_getfeedback = __esm(() => {
  init_lib();
  init_components();
  GetFeedbackRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetFeedbackRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetFeedbackRequest$) => {
    GetFeedbackRequest$.inboundSchema = GetFeedbackRequest$inboundSchema;
    GetFeedbackRequest$.outboundSchema = GetFeedbackRequest$outboundSchema;
  })(GetFeedbackRequest$ ||= {});
  GetFeedbackResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Feedback$inboundSchema
  ]);
  GetFeedbackResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Feedback$outboundSchema
  ]);
  ((GetFeedbackResponse$) => {
    GetFeedbackResponse$.inboundSchema = GetFeedbackResponse$inboundSchema;
    GetFeedbackResponse$.outboundSchema = GetFeedbackResponse$outboundSchema;
  })(GetFeedbackResponse$ ||= {});
});

// src/models/operations/getformfields.ts
var GetFormFieldsRequest$inboundSchema, GetFormFieldsRequest$outboundSchema, GetFormFieldsRequest$, GetFormFieldsResponse$inboundSchema, GetFormFieldsResponse$outboundSchema, GetFormFieldsResponse$;
var init_getformfields = __esm(() => {
  init_lib();
  init_components();
  GetFormFieldsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetFormFieldsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetFormFieldsRequest$) => {
    GetFormFieldsRequest$.inboundSchema = GetFormFieldsRequest$inboundSchema;
    GetFormFieldsRequest$.outboundSchema = GetFormFieldsRequest$outboundSchema;
  })(GetFormFieldsRequest$ ||= {});
  GetFormFieldsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    FormField$inboundSchema
  ]);
  GetFormFieldsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    FormField$outboundSchema
  ]);
  ((GetFormFieldsResponse$) => {
    GetFormFieldsResponse$.inboundSchema = GetFormFieldsResponse$inboundSchema;
    GetFormFieldsResponse$.outboundSchema = GetFormFieldsResponse$outboundSchema;
  })(GetFormFieldsResponse$ ||= {});
});

// src/models/operations/getformresponses.ts
var GetFormResponsesRequest$inboundSchema, GetFormResponsesRequest$outboundSchema, GetFormResponsesRequest$, GetFormResponsesResponse$inboundSchema, GetFormResponsesResponse$outboundSchema, GetFormResponsesResponse$;
var init_getformresponses = __esm(() => {
  init_lib();
  init_components();
  GetFormResponsesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetFormResponsesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetFormResponsesRequest$) => {
    GetFormResponsesRequest$.inboundSchema = GetFormResponsesRequest$inboundSchema;
    GetFormResponsesRequest$.outboundSchema = GetFormResponsesRequest$outboundSchema;
  })(GetFormResponsesRequest$ ||= {});
  GetFormResponsesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    FormResponse$inboundSchema
  ]);
  GetFormResponsesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    FormResponse$outboundSchema
  ]);
  ((GetFormResponsesResponse$) => {
    GetFormResponsesResponse$.inboundSchema = GetFormResponsesResponse$inboundSchema;
    GetFormResponsesResponse$.outboundSchema = GetFormResponsesResponse$outboundSchema;
  })(GetFormResponsesResponse$ ||= {});
});

// src/models/operations/getforms.ts
var GetFormsRequest$inboundSchema, GetFormsRequest$outboundSchema, GetFormsRequest$, GetFormsResponse$inboundSchema, GetFormsResponse$outboundSchema, GetFormsResponse$;
var init_getforms = __esm(() => {
  init_lib();
  init_components();
  GetFormsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetFormsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetFormsRequest$) => {
    GetFormsRequest$.inboundSchema = GetFormsRequest$inboundSchema;
    GetFormsRequest$.outboundSchema = GetFormsRequest$outboundSchema;
  })(GetFormsRequest$ ||= {});
  GetFormsResponse$inboundSchema = unionType([ErrorT$inboundSchema, Form$inboundSchema]);
  GetFormsResponse$outboundSchema = unionType([ErrorT$outboundSchema, Form$outboundSchema]);
  ((GetFormsResponse$) => {
    GetFormsResponse$.inboundSchema = GetFormsResponse$inboundSchema;
    GetFormsResponse$.outboundSchema = GetFormsResponse$outboundSchema;
  })(GetFormsResponse$ ||= {});
});

// src/models/operations/getjobactivities.ts
var GetJobActivitiesRequest$inboundSchema, GetJobActivitiesRequest$outboundSchema, GetJobActivitiesRequest$, GetJobActivitiesResponse$inboundSchema, GetJobActivitiesResponse$outboundSchema, GetJobActivitiesResponse$;
var init_getjobactivities = __esm(() => {
  init_lib();
  init_components();
  GetJobActivitiesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobActivitiesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobActivitiesRequest$) => {
    GetJobActivitiesRequest$.inboundSchema = GetJobActivitiesRequest$inboundSchema;
    GetJobActivitiesRequest$.outboundSchema = GetJobActivitiesRequest$outboundSchema;
  })(GetJobActivitiesRequest$ ||= {});
  GetJobActivitiesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobActivity$inboundSchema
  ]);
  GetJobActivitiesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobActivity$outboundSchema
  ]);
  ((GetJobActivitiesResponse$) => {
    GetJobActivitiesResponse$.inboundSchema = GetJobActivitiesResponse$inboundSchema;
    GetJobActivitiesResponse$.outboundSchema = GetJobActivitiesResponse$outboundSchema;
  })(GetJobActivitiesResponse$ ||= {});
});

// src/models/operations/getjoballocations.ts
var GetJobAllocationsRequest$inboundSchema, GetJobAllocationsRequest$outboundSchema, GetJobAllocationsRequest$, GetJobAllocationsResponse$inboundSchema, GetJobAllocationsResponse$outboundSchema, GetJobAllocationsResponse$;
var init_getjoballocations = __esm(() => {
  init_lib();
  init_components();
  GetJobAllocationsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobAllocationsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobAllocationsRequest$) => {
    GetJobAllocationsRequest$.inboundSchema = GetJobAllocationsRequest$inboundSchema;
    GetJobAllocationsRequest$.outboundSchema = GetJobAllocationsRequest$outboundSchema;
  })(GetJobAllocationsRequest$ ||= {});
  GetJobAllocationsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobAllocation$inboundSchema
  ]);
  GetJobAllocationsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobAllocation$outboundSchema
  ]);
  ((GetJobAllocationsResponse$) => {
    GetJobAllocationsResponse$.inboundSchema = GetJobAllocationsResponse$inboundSchema;
    GetJobAllocationsResponse$.outboundSchema = GetJobAllocationsResponse$outboundSchema;
  })(GetJobAllocationsResponse$ ||= {});
});

// src/models/operations/getjobchecklists.ts
var GetJobChecklistsRequest$inboundSchema, GetJobChecklistsRequest$outboundSchema, GetJobChecklistsRequest$, GetJobChecklistsResponse$inboundSchema, GetJobChecklistsResponse$outboundSchema, GetJobChecklistsResponse$;
var init_getjobchecklists = __esm(() => {
  init_lib();
  init_components();
  GetJobChecklistsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobChecklistsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobChecklistsRequest$) => {
    GetJobChecklistsRequest$.inboundSchema = GetJobChecklistsRequest$inboundSchema;
    GetJobChecklistsRequest$.outboundSchema = GetJobChecklistsRequest$outboundSchema;
  })(GetJobChecklistsRequest$ ||= {});
  GetJobChecklistsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobChecklist$inboundSchema
  ]);
  GetJobChecklistsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobChecklist$outboundSchema
  ]);
  ((GetJobChecklistsResponse$) => {
    GetJobChecklistsResponse$.inboundSchema = GetJobChecklistsResponse$inboundSchema;
    GetJobChecklistsResponse$.outboundSchema = GetJobChecklistsResponse$outboundSchema;
  })(GetJobChecklistsResponse$ ||= {});
});

// src/models/operations/getjobcontacts.ts
var GetJobContactsRequest$inboundSchema, GetJobContactsRequest$outboundSchema, GetJobContactsRequest$, GetJobContactsResponse$inboundSchema, GetJobContactsResponse$outboundSchema, GetJobContactsResponse$;
var init_getjobcontacts = __esm(() => {
  init_lib();
  init_components();
  GetJobContactsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobContactsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobContactsRequest$) => {
    GetJobContactsRequest$.inboundSchema = GetJobContactsRequest$inboundSchema;
    GetJobContactsRequest$.outboundSchema = GetJobContactsRequest$outboundSchema;
  })(GetJobContactsRequest$ ||= {});
  GetJobContactsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobContact$inboundSchema
  ]);
  GetJobContactsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobContact$outboundSchema
  ]);
  ((GetJobContactsResponse$) => {
    GetJobContactsResponse$.inboundSchema = GetJobContactsResponse$inboundSchema;
    GetJobContactsResponse$.outboundSchema = GetJobContactsResponse$outboundSchema;
  })(GetJobContactsResponse$ ||= {});
});

// src/models/operations/getjobmaterialbundles.ts
var GetJobMaterialBundlesRequest$inboundSchema, GetJobMaterialBundlesRequest$outboundSchema, GetJobMaterialBundlesRequest$, GetJobMaterialBundlesResponse$inboundSchema, GetJobMaterialBundlesResponse$outboundSchema, GetJobMaterialBundlesResponse$;
var init_getjobmaterialbundles = __esm(() => {
  init_lib();
  init_components();
  GetJobMaterialBundlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobMaterialBundlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobMaterialBundlesRequest$) => {
    GetJobMaterialBundlesRequest$.inboundSchema = GetJobMaterialBundlesRequest$inboundSchema;
    GetJobMaterialBundlesRequest$.outboundSchema = GetJobMaterialBundlesRequest$outboundSchema;
  })(GetJobMaterialBundlesRequest$ ||= {});
  GetJobMaterialBundlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobMaterialBundle$inboundSchema
  ]);
  GetJobMaterialBundlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobMaterialBundle$outboundSchema
  ]);
  ((GetJobMaterialBundlesResponse$) => {
    GetJobMaterialBundlesResponse$.inboundSchema = GetJobMaterialBundlesResponse$inboundSchema;
    GetJobMaterialBundlesResponse$.outboundSchema = GetJobMaterialBundlesResponse$outboundSchema;
  })(GetJobMaterialBundlesResponse$ ||= {});
});

// src/models/operations/getjobmaterials.ts
var GetJobMaterialsRequest$inboundSchema, GetJobMaterialsRequest$outboundSchema, GetJobMaterialsRequest$, GetJobMaterialsResponse$inboundSchema, GetJobMaterialsResponse$outboundSchema, GetJobMaterialsResponse$;
var init_getjobmaterials = __esm(() => {
  init_lib();
  init_components();
  GetJobMaterialsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobMaterialsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobMaterialsRequest$) => {
    GetJobMaterialsRequest$.inboundSchema = GetJobMaterialsRequest$inboundSchema;
    GetJobMaterialsRequest$.outboundSchema = GetJobMaterialsRequest$outboundSchema;
  })(GetJobMaterialsRequest$ ||= {});
  GetJobMaterialsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobMaterial$inboundSchema
  ]);
  GetJobMaterialsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobMaterial$outboundSchema
  ]);
  ((GetJobMaterialsResponse$) => {
    GetJobMaterialsResponse$.inboundSchema = GetJobMaterialsResponse$inboundSchema;
    GetJobMaterialsResponse$.outboundSchema = GetJobMaterialsResponse$outboundSchema;
  })(GetJobMaterialsResponse$ ||= {});
});

// src/models/operations/getjobpayments.ts
var GetJobPaymentsRequest$inboundSchema, GetJobPaymentsRequest$outboundSchema, GetJobPaymentsRequest$, GetJobPaymentsResponse$inboundSchema, GetJobPaymentsResponse$outboundSchema, GetJobPaymentsResponse$;
var init_getjobpayments = __esm(() => {
  init_lib();
  init_components();
  GetJobPaymentsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobPaymentsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobPaymentsRequest$) => {
    GetJobPaymentsRequest$.inboundSchema = GetJobPaymentsRequest$inboundSchema;
    GetJobPaymentsRequest$.outboundSchema = GetJobPaymentsRequest$outboundSchema;
  })(GetJobPaymentsRequest$ ||= {});
  GetJobPaymentsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    JobPayment$inboundSchema
  ]);
  GetJobPaymentsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    JobPayment$outboundSchema
  ]);
  ((GetJobPaymentsResponse$) => {
    GetJobPaymentsResponse$.inboundSchema = GetJobPaymentsResponse$inboundSchema;
    GetJobPaymentsResponse$.outboundSchema = GetJobPaymentsResponse$outboundSchema;
  })(GetJobPaymentsResponse$ ||= {});
});

// src/models/operations/getjobqueues.ts
var GetJobQueuesRequest$inboundSchema, GetJobQueuesRequest$outboundSchema, GetJobQueuesRequest$, GetJobQueuesResponse$inboundSchema, GetJobQueuesResponse$outboundSchema, GetJobQueuesResponse$;
var init_getjobqueues = __esm(() => {
  init_lib();
  init_components();
  GetJobQueuesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobQueuesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobQueuesRequest$) => {
    GetJobQueuesRequest$.inboundSchema = GetJobQueuesRequest$inboundSchema;
    GetJobQueuesRequest$.outboundSchema = GetJobQueuesRequest$outboundSchema;
  })(GetJobQueuesRequest$ ||= {});
  GetJobQueuesResponse$inboundSchema = unionType([ErrorT$inboundSchema, Queue$inboundSchema]);
  GetJobQueuesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Queue$outboundSchema
  ]);
  ((GetJobQueuesResponse$) => {
    GetJobQueuesResponse$.inboundSchema = GetJobQueuesResponse$inboundSchema;
    GetJobQueuesResponse$.outboundSchema = GetJobQueuesResponse$outboundSchema;
  })(GetJobQueuesResponse$ ||= {});
});

// src/models/operations/getjobs.ts
var GetJobsRequest$inboundSchema, GetJobsRequest$outboundSchema, GetJobsRequest$, GetJobsResponse$inboundSchema, GetJobsResponse$outboundSchema, GetJobsResponse$;
var init_getjobs = __esm(() => {
  init_lib();
  init_components();
  GetJobsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetJobsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetJobsRequest$) => {
    GetJobsRequest$.inboundSchema = GetJobsRequest$inboundSchema;
    GetJobsRequest$.outboundSchema = GetJobsRequest$outboundSchema;
  })(GetJobsRequest$ ||= {});
  GetJobsResponse$inboundSchema = unionType([ErrorT$inboundSchema, Job$inboundSchema]);
  GetJobsResponse$outboundSchema = unionType([ErrorT$outboundSchema, Job$outboundSchema]);
  ((GetJobsResponse$) => {
    GetJobsResponse$.inboundSchema = GetJobsResponse$inboundSchema;
    GetJobsResponse$.outboundSchema = GetJobsResponse$outboundSchema;
  })(GetJobsResponse$ ||= {});
});

// src/models/operations/getknowledgearticles.ts
var GetKnowledgeArticlesRequest$inboundSchema, GetKnowledgeArticlesRequest$outboundSchema, GetKnowledgeArticlesRequest$, GetKnowledgeArticlesResponse$inboundSchema, GetKnowledgeArticlesResponse$outboundSchema, GetKnowledgeArticlesResponse$;
var init_getknowledgearticles = __esm(() => {
  init_lib();
  init_components();
  GetKnowledgeArticlesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetKnowledgeArticlesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetKnowledgeArticlesRequest$) => {
    GetKnowledgeArticlesRequest$.inboundSchema = GetKnowledgeArticlesRequest$inboundSchema;
    GetKnowledgeArticlesRequest$.outboundSchema = GetKnowledgeArticlesRequest$outboundSchema;
  })(GetKnowledgeArticlesRequest$ ||= {});
  GetKnowledgeArticlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    KnowledgeArticle$inboundSchema
  ]);
  GetKnowledgeArticlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    KnowledgeArticle$outboundSchema
  ]);
  ((GetKnowledgeArticlesResponse$) => {
    GetKnowledgeArticlesResponse$.inboundSchema = GetKnowledgeArticlesResponse$inboundSchema;
    GetKnowledgeArticlesResponse$.outboundSchema = GetKnowledgeArticlesResponse$outboundSchema;
  })(GetKnowledgeArticlesResponse$ ||= {});
});

// src/models/operations/getlocations.ts
var GetLocationsRequest$inboundSchema, GetLocationsRequest$outboundSchema, GetLocationsRequest$, GetLocationsResponse$inboundSchema, GetLocationsResponse$outboundSchema, GetLocationsResponse$;
var init_getlocations = __esm(() => {
  init_lib();
  init_components();
  GetLocationsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetLocationsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetLocationsRequest$) => {
    GetLocationsRequest$.inboundSchema = GetLocationsRequest$inboundSchema;
    GetLocationsRequest$.outboundSchema = GetLocationsRequest$outboundSchema;
  })(GetLocationsRequest$ ||= {});
  GetLocationsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Location$inboundSchema
  ]);
  GetLocationsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Location$outboundSchema
  ]);
  ((GetLocationsResponse$) => {
    GetLocationsResponse$.inboundSchema = GetLocationsResponse$inboundSchema;
    GetLocationsResponse$.outboundSchema = GetLocationsResponse$outboundSchema;
  })(GetLocationsResponse$ ||= {});
});

// src/models/operations/getmaterials.ts
var GetMaterialsRequest$inboundSchema, GetMaterialsRequest$outboundSchema, GetMaterialsRequest$, GetMaterialsResponse$inboundSchema, GetMaterialsResponse$outboundSchema, GetMaterialsResponse$;
var init_getmaterials = __esm(() => {
  init_lib();
  init_components();
  GetMaterialsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetMaterialsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetMaterialsRequest$) => {
    GetMaterialsRequest$.inboundSchema = GetMaterialsRequest$inboundSchema;
    GetMaterialsRequest$.outboundSchema = GetMaterialsRequest$outboundSchema;
  })(GetMaterialsRequest$ ||= {});
  GetMaterialsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    Material$inboundSchema
  ]);
  GetMaterialsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Material$outboundSchema
  ]);
  ((GetMaterialsResponse$) => {
    GetMaterialsResponse$.inboundSchema = GetMaterialsResponse$inboundSchema;
    GetMaterialsResponse$.outboundSchema = GetMaterialsResponse$outboundSchema;
  })(GetMaterialsResponse$ ||= {});
});

// src/models/operations/getnotes.ts
var GetNotesRequest$inboundSchema, GetNotesRequest$outboundSchema, GetNotesRequest$, GetNotesResponse$inboundSchema, GetNotesResponse$outboundSchema, GetNotesResponse$;
var init_getnotes = __esm(() => {
  init_lib();
  init_components();
  GetNotesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetNotesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetNotesRequest$) => {
    GetNotesRequest$.inboundSchema = GetNotesRequest$inboundSchema;
    GetNotesRequest$.outboundSchema = GetNotesRequest$outboundSchema;
  })(GetNotesRequest$ ||= {});
  GetNotesResponse$inboundSchema = unionType([ErrorT$inboundSchema, Note$inboundSchema]);
  GetNotesResponse$outboundSchema = unionType([ErrorT$outboundSchema, Note$outboundSchema]);
  ((GetNotesResponse$) => {
    GetNotesResponse$.inboundSchema = GetNotesResponse$inboundSchema;
    GetNotesResponse$.outboundSchema = GetNotesResponse$outboundSchema;
  })(GetNotesResponse$ ||= {});
});

// src/models/operations/getsecurityroles.ts
var GetSecurityRolesRequest$inboundSchema, GetSecurityRolesRequest$outboundSchema, GetSecurityRolesRequest$, GetSecurityRolesResponse$inboundSchema, GetSecurityRolesResponse$outboundSchema, GetSecurityRolesResponse$;
var init_getsecurityroles = __esm(() => {
  init_lib();
  init_components();
  GetSecurityRolesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetSecurityRolesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetSecurityRolesRequest$) => {
    GetSecurityRolesRequest$.inboundSchema = GetSecurityRolesRequest$inboundSchema;
    GetSecurityRolesRequest$.outboundSchema = GetSecurityRolesRequest$outboundSchema;
  })(GetSecurityRolesRequest$ ||= {});
  GetSecurityRolesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    SecurityRole$inboundSchema
  ]);
  GetSecurityRolesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    SecurityRole$outboundSchema
  ]);
  ((GetSecurityRolesResponse$) => {
    GetSecurityRolesResponse$.inboundSchema = GetSecurityRolesResponse$inboundSchema;
    GetSecurityRolesResponse$.outboundSchema = GetSecurityRolesResponse$outboundSchema;
  })(GetSecurityRolesResponse$ ||= {});
});

// src/models/operations/getsmstemplates.ts
var GetSMSTemplatesRequest$inboundSchema, GetSMSTemplatesRequest$outboundSchema, GetSMSTemplatesRequest$, GetSMSTemplatesResponse$inboundSchema, GetSMSTemplatesResponse$outboundSchema, GetSMSTemplatesResponse$;
var init_getsmstemplates = __esm(() => {
  init_lib();
  init_components();
  GetSMSTemplatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetSMSTemplatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetSMSTemplatesRequest$) => {
    GetSMSTemplatesRequest$.inboundSchema = GetSMSTemplatesRequest$inboundSchema;
    GetSMSTemplatesRequest$.outboundSchema = GetSMSTemplatesRequest$outboundSchema;
  })(GetSMSTemplatesRequest$ ||= {});
  GetSMSTemplatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    SmsTemplate$inboundSchema
  ]);
  GetSMSTemplatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    SmsTemplate$outboundSchema
  ]);
  ((GetSMSTemplatesResponse$) => {
    GetSMSTemplatesResponse$.inboundSchema = GetSMSTemplatesResponse$inboundSchema;
    GetSMSTemplatesResponse$.outboundSchema = GetSMSTemplatesResponse$outboundSchema;
  })(GetSMSTemplatesResponse$ ||= {});
});

// src/models/operations/getstaffmembers.ts
var GetStaffMembersRequest$inboundSchema, GetStaffMembersRequest$outboundSchema, GetStaffMembersRequest$, GetStaffMembersResponse$inboundSchema, GetStaffMembersResponse$outboundSchema, GetStaffMembersResponse$;
var init_getstaffmembers = __esm(() => {
  init_lib();
  init_components();
  GetStaffMembersRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetStaffMembersRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetStaffMembersRequest$) => {
    GetStaffMembersRequest$.inboundSchema = GetStaffMembersRequest$inboundSchema;
    GetStaffMembersRequest$.outboundSchema = GetStaffMembersRequest$outboundSchema;
  })(GetStaffMembersRequest$ ||= {});
  GetStaffMembersResponse$inboundSchema = unionType([ErrorT$inboundSchema, Staff$inboundSchema]);
  GetStaffMembersResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Staff$outboundSchema
  ]);
  ((GetStaffMembersResponse$) => {
    GetStaffMembersResponse$.inboundSchema = GetStaffMembersResponse$inboundSchema;
    GetStaffMembersResponse$.outboundSchema = GetStaffMembersResponse$outboundSchema;
  })(GetStaffMembersResponse$ ||= {});
});

// src/models/operations/getstaffmessages.ts
var GetStaffMessagesRequest$inboundSchema, GetStaffMessagesRequest$outboundSchema, GetStaffMessagesRequest$, GetStaffMessagesResponse$inboundSchema, GetStaffMessagesResponse$outboundSchema, GetStaffMessagesResponse$;
var init_getstaffmessages = __esm(() => {
  init_lib();
  init_components();
  GetStaffMessagesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetStaffMessagesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetStaffMessagesRequest$) => {
    GetStaffMessagesRequest$.inboundSchema = GetStaffMessagesRequest$inboundSchema;
    GetStaffMessagesRequest$.outboundSchema = GetStaffMessagesRequest$outboundSchema;
  })(GetStaffMessagesRequest$ ||= {});
  GetStaffMessagesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    StaffMessage$inboundSchema
  ]);
  GetStaffMessagesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    StaffMessage$outboundSchema
  ]);
  ((GetStaffMessagesResponse$) => {
    GetStaffMessagesResponse$.inboundSchema = GetStaffMessagesResponse$inboundSchema;
    GetStaffMessagesResponse$.outboundSchema = GetStaffMessagesResponse$outboundSchema;
  })(GetStaffMessagesResponse$ ||= {});
});

// src/models/operations/gettasks.ts
var GetTasksRequest$inboundSchema, GetTasksRequest$outboundSchema, GetTasksRequest$, GetTasksResponse$inboundSchema, GetTasksResponse$outboundSchema, GetTasksResponse$;
var init_gettasks = __esm(() => {
  init_lib();
  init_components();
  GetTasksRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetTasksRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetTasksRequest$) => {
    GetTasksRequest$.inboundSchema = GetTasksRequest$inboundSchema;
    GetTasksRequest$.outboundSchema = GetTasksRequest$outboundSchema;
  })(GetTasksRequest$ ||= {});
  GetTasksResponse$inboundSchema = unionType([ErrorT$inboundSchema, Task$inboundSchema]);
  GetTasksResponse$outboundSchema = unionType([ErrorT$outboundSchema, Task$outboundSchema]);
  ((GetTasksResponse$) => {
    GetTasksResponse$.inboundSchema = GetTasksResponse$inboundSchema;
    GetTasksResponse$.outboundSchema = GetTasksResponse$outboundSchema;
  })(GetTasksResponse$ ||= {});
});

// src/models/operations/gettaxrates.ts
var GetTaxRatesRequest$inboundSchema, GetTaxRatesRequest$outboundSchema, GetTaxRatesRequest$, GetTaxRatesResponse$inboundSchema, GetTaxRatesResponse$outboundSchema, GetTaxRatesResponse$;
var init_gettaxrates = __esm(() => {
  init_lib();
  init_components();
  GetTaxRatesRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetTaxRatesRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetTaxRatesRequest$) => {
    GetTaxRatesRequest$.inboundSchema = GetTaxRatesRequest$inboundSchema;
    GetTaxRatesRequest$.outboundSchema = GetTaxRatesRequest$outboundSchema;
  })(GetTaxRatesRequest$ ||= {});
  GetTaxRatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    TaxRate$inboundSchema
  ]);
  GetTaxRatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    TaxRate$outboundSchema
  ]);
  ((GetTaxRatesResponse$) => {
    GetTaxRatesResponse$.inboundSchema = GetTaxRatesResponse$inboundSchema;
    GetTaxRatesResponse$.outboundSchema = GetTaxRatesResponse$outboundSchema;
  })(GetTaxRatesResponse$ ||= {});
});

// src/models/operations/getvendors.ts
var GetVendorsRequest$inboundSchema, GetVendorsRequest$outboundSchema, GetVendorsRequest$, GetVendorsResponse$inboundSchema, GetVendorsResponse$outboundSchema, GetVendorsResponse$;
var init_getvendors = __esm(() => {
  init_lib();
  init_components();
  GetVendorsRequest$inboundSchema = objectType({
    uuid: stringType()
  });
  GetVendorsRequest$outboundSchema = objectType({
    uuid: stringType()
  });
  ((GetVendorsRequest$) => {
    GetVendorsRequest$.inboundSchema = GetVendorsRequest$inboundSchema;
    GetVendorsRequest$.outboundSchema = GetVendorsRequest$outboundSchema;
  })(GetVendorsRequest$ ||= {});
  GetVendorsResponse$inboundSchema = unionType([ErrorT$inboundSchema, Vendor$inboundSchema]);
  GetVendorsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    Vendor$outboundSchema
  ]);
  ((GetVendorsResponse$) => {
    GetVendorsResponse$.inboundSchema = GetVendorsResponse$inboundSchema;
    GetVendorsResponse$.outboundSchema = GetVendorsResponse$outboundSchema;
  })(GetVendorsResponse$ ||= {});
});

// src/models/operations/listallocationwindows.ts
var ListAllocationWindowsResponse$inboundSchema, ListAllocationWindowsResponse$outboundSchema, ListAllocationWindowsResponse$;
var init_listallocationwindows = __esm(() => {
  init_lib();
  init_components();
  ListAllocationWindowsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(AllocationWindow$inboundSchema)
  ]);
  ListAllocationWindowsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(AllocationWindow$outboundSchema)
  ]);
  ((ListAllocationWindowsResponse$) => {
    ListAllocationWindowsResponse$.inboundSchema = ListAllocationWindowsResponse$inboundSchema;
    ListAllocationWindowsResponse$.outboundSchema = ListAllocationWindowsResponse$outboundSchema;
  })(ListAllocationWindowsResponse$ ||= {});
});

// src/models/operations/listassets.ts
var ListAssetsResponse$inboundSchema, ListAssetsResponse$outboundSchema, ListAssetsResponse$;
var init_listassets = __esm(() => {
  init_lib();
  init_components();
  ListAssetsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Asset$inboundSchema)
  ]);
  ListAssetsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Asset$outboundSchema)
  ]);
  ((ListAssetsResponse$) => {
    ListAssetsResponse$.inboundSchema = ListAssetsResponse$inboundSchema;
    ListAssetsResponse$.outboundSchema = ListAssetsResponse$outboundSchema;
  })(ListAssetsResponse$ ||= {});
});

// src/models/operations/listassettypefields.ts
var ListAssetTypeFieldsResponse$inboundSchema, ListAssetTypeFieldsResponse$outboundSchema, ListAssetTypeFieldsResponse$;
var init_listassettypefields = __esm(() => {
  init_lib();
  init_components();
  ListAssetTypeFieldsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(AssetTypeField$inboundSchema)
  ]);
  ListAssetTypeFieldsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(AssetTypeField$outboundSchema)
  ]);
  ((ListAssetTypeFieldsResponse$) => {
    ListAssetTypeFieldsResponse$.inboundSchema = ListAssetTypeFieldsResponse$inboundSchema;
    ListAssetTypeFieldsResponse$.outboundSchema = ListAssetTypeFieldsResponse$outboundSchema;
  })(ListAssetTypeFieldsResponse$ ||= {});
});

// src/models/operations/listassettypes.ts
var ListAssetTypesResponse$inboundSchema, ListAssetTypesResponse$outboundSchema, ListAssetTypesResponse$;
var init_listassettypes = __esm(() => {
  init_lib();
  init_components();
  ListAssetTypesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(AssetType$inboundSchema)
  ]);
  ListAssetTypesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(AssetType$outboundSchema)
  ]);
  ((ListAssetTypesResponse$) => {
    ListAssetTypesResponse$.inboundSchema = ListAssetTypesResponse$inboundSchema;
    ListAssetTypesResponse$.outboundSchema = ListAssetTypesResponse$outboundSchema;
  })(ListAssetTypesResponse$ ||= {});
});

// src/models/operations/listattachments.ts
var ListAttachmentsResponse$inboundSchema, ListAttachmentsResponse$outboundSchema, ListAttachmentsResponse$;
var init_listattachments = __esm(() => {
  init_lib();
  init_components();
  ListAttachmentsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Attachment$inboundSchema)
  ]);
  ListAttachmentsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Attachment$outboundSchema)
  ]);
  ((ListAttachmentsResponse$) => {
    ListAttachmentsResponse$.inboundSchema = ListAttachmentsResponse$inboundSchema;
    ListAttachmentsResponse$.outboundSchema = ListAttachmentsResponse$outboundSchema;
  })(ListAttachmentsResponse$ ||= {});
});

// src/models/operations/listbadges.ts
var ListBadgesResponse$inboundSchema, ListBadgesResponse$outboundSchema, ListBadgesResponse$;
var init_listbadges = __esm(() => {
  init_lib();
  init_components();
  ListBadgesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Badge$inboundSchema)
  ]);
  ListBadgesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Badge$outboundSchema)
  ]);
  ((ListBadgesResponse$) => {
    ListBadgesResponse$.inboundSchema = ListBadgesResponse$inboundSchema;
    ListBadgesResponse$.outboundSchema = ListBadgesResponse$outboundSchema;
  })(ListBadgesResponse$ ||= {});
});

// src/models/operations/listbundles.ts
var ListBundlesResponse$inboundSchema, ListBundlesResponse$outboundSchema, ListBundlesResponse$;
var init_listbundles = __esm(() => {
  init_lib();
  init_components();
  ListBundlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(MaterialBundle$inboundSchema)
  ]);
  ListBundlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(MaterialBundle$outboundSchema)
  ]);
  ((ListBundlesResponse$) => {
    ListBundlesResponse$.inboundSchema = ListBundlesResponse$inboundSchema;
    ListBundlesResponse$.outboundSchema = ListBundlesResponse$outboundSchema;
  })(ListBundlesResponse$ ||= {});
});

// src/models/operations/listcategories.ts
var ListCategoriesResponse$inboundSchema, ListCategoriesResponse$outboundSchema, ListCategoriesResponse$;
var init_listcategories = __esm(() => {
  init_lib();
  init_components();
  ListCategoriesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Category$inboundSchema)
  ]);
  ListCategoriesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Category$outboundSchema)
  ]);
  ((ListCategoriesResponse$) => {
    ListCategoriesResponse$.inboundSchema = ListCategoriesResponse$inboundSchema;
    ListCategoriesResponse$.outboundSchema = ListCategoriesResponse$outboundSchema;
  })(ListCategoriesResponse$ ||= {});
});

// src/models/operations/listclients.ts
var ListClientsResponse$inboundSchema, ListClientsResponse$outboundSchema, ListClientsResponse$;
var init_listclients = __esm(() => {
  init_lib();
  init_components();
  ListClientsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Company$inboundSchema)
  ]);
  ListClientsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Company$outboundSchema)
  ]);
  ((ListClientsResponse$) => {
    ListClientsResponse$.inboundSchema = ListClientsResponse$inboundSchema;
    ListClientsResponse$.outboundSchema = ListClientsResponse$outboundSchema;
  })(ListClientsResponse$ ||= {});
});

// src/models/operations/listcompanycontacts.ts
var ListCompanyContactsResponse$inboundSchema, ListCompanyContactsResponse$outboundSchema, ListCompanyContactsResponse$;
var init_listcompanycontacts = __esm(() => {
  init_lib();
  init_components();
  ListCompanyContactsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(CompanyContact$inboundSchema)
  ]);
  ListCompanyContactsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(CompanyContact$outboundSchema)
  ]);
  ((ListCompanyContactsResponse$) => {
    ListCompanyContactsResponse$.inboundSchema = ListCompanyContactsResponse$inboundSchema;
    ListCompanyContactsResponse$.outboundSchema = ListCompanyContactsResponse$outboundSchema;
  })(ListCompanyContactsResponse$ ||= {});
});

// src/models/operations/listemailtemplates.ts
var ListEmailTemplatesResponse$inboundSchema, ListEmailTemplatesResponse$outboundSchema, ListEmailTemplatesResponse$;
var init_listemailtemplates = __esm(() => {
  init_lib();
  init_components();
  ListEmailTemplatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(EmailTemplate$inboundSchema)
  ]);
  ListEmailTemplatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(EmailTemplate$outboundSchema)
  ]);
  ((ListEmailTemplatesResponse$) => {
    ListEmailTemplatesResponse$.inboundSchema = ListEmailTemplatesResponse$inboundSchema;
    ListEmailTemplatesResponse$.outboundSchema = ListEmailTemplatesResponse$outboundSchema;
  })(ListEmailTemplatesResponse$ ||= {});
});

// src/models/operations/listfeedback.ts
var ListFeedbackResponse$inboundSchema, ListFeedbackResponse$outboundSchema, ListFeedbackResponse$;
var init_listfeedback = __esm(() => {
  init_lib();
  init_components();
  ListFeedbackResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Feedback$inboundSchema)
  ]);
  ListFeedbackResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Feedback$outboundSchema)
  ]);
  ((ListFeedbackResponse$) => {
    ListFeedbackResponse$.inboundSchema = ListFeedbackResponse$inboundSchema;
    ListFeedbackResponse$.outboundSchema = ListFeedbackResponse$outboundSchema;
  })(ListFeedbackResponse$ ||= {});
});

// src/models/operations/listformfields.ts
var ListFormFieldsResponse$inboundSchema, ListFormFieldsResponse$outboundSchema, ListFormFieldsResponse$;
var init_listformfields = __esm(() => {
  init_lib();
  init_components();
  ListFormFieldsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(FormField$inboundSchema)
  ]);
  ListFormFieldsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(FormField$outboundSchema)
  ]);
  ((ListFormFieldsResponse$) => {
    ListFormFieldsResponse$.inboundSchema = ListFormFieldsResponse$inboundSchema;
    ListFormFieldsResponse$.outboundSchema = ListFormFieldsResponse$outboundSchema;
  })(ListFormFieldsResponse$ ||= {});
});

// src/models/operations/listformresponses.ts
var ListFormResponsesResponse$inboundSchema, ListFormResponsesResponse$outboundSchema, ListFormResponsesResponse$;
var init_listformresponses = __esm(() => {
  init_lib();
  init_components();
  ListFormResponsesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(FormResponse$inboundSchema)
  ]);
  ListFormResponsesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(FormResponse$outboundSchema)
  ]);
  ((ListFormResponsesResponse$) => {
    ListFormResponsesResponse$.inboundSchema = ListFormResponsesResponse$inboundSchema;
    ListFormResponsesResponse$.outboundSchema = ListFormResponsesResponse$outboundSchema;
  })(ListFormResponsesResponse$ ||= {});
});

// src/models/operations/listforms.ts
var ListFormsResponse$inboundSchema, ListFormsResponse$outboundSchema, ListFormsResponse$;
var init_listforms = __esm(() => {
  init_lib();
  init_components();
  ListFormsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Form$inboundSchema)
  ]);
  ListFormsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Form$outboundSchema)
  ]);
  ((ListFormsResponse$) => {
    ListFormsResponse$.inboundSchema = ListFormsResponse$inboundSchema;
    ListFormsResponse$.outboundSchema = ListFormsResponse$outboundSchema;
  })(ListFormsResponse$ ||= {});
});

// src/models/operations/listjobactivities.ts
var ListJobActivitiesResponse$inboundSchema, ListJobActivitiesResponse$outboundSchema, ListJobActivitiesResponse$;
var init_listjobactivities = __esm(() => {
  init_lib();
  init_components();
  ListJobActivitiesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobActivity$inboundSchema)
  ]);
  ListJobActivitiesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobActivity$outboundSchema)
  ]);
  ((ListJobActivitiesResponse$) => {
    ListJobActivitiesResponse$.inboundSchema = ListJobActivitiesResponse$inboundSchema;
    ListJobActivitiesResponse$.outboundSchema = ListJobActivitiesResponse$outboundSchema;
  })(ListJobActivitiesResponse$ ||= {});
});

// src/models/operations/listjoballocations.ts
var ListJobAllocationsResponse$inboundSchema, ListJobAllocationsResponse$outboundSchema, ListJobAllocationsResponse$;
var init_listjoballocations = __esm(() => {
  init_lib();
  init_components();
  ListJobAllocationsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobAllocation$inboundSchema)
  ]);
  ListJobAllocationsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobAllocation$outboundSchema)
  ]);
  ((ListJobAllocationsResponse$) => {
    ListJobAllocationsResponse$.inboundSchema = ListJobAllocationsResponse$inboundSchema;
    ListJobAllocationsResponse$.outboundSchema = ListJobAllocationsResponse$outboundSchema;
  })(ListJobAllocationsResponse$ ||= {});
});

// src/models/operations/listjobchecklists.ts
var ListJobChecklistsResponse$inboundSchema, ListJobChecklistsResponse$outboundSchema, ListJobChecklistsResponse$;
var init_listjobchecklists = __esm(() => {
  init_lib();
  init_components();
  ListJobChecklistsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobChecklist$inboundSchema)
  ]);
  ListJobChecklistsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobChecklist$outboundSchema)
  ]);
  ((ListJobChecklistsResponse$) => {
    ListJobChecklistsResponse$.inboundSchema = ListJobChecklistsResponse$inboundSchema;
    ListJobChecklistsResponse$.outboundSchema = ListJobChecklistsResponse$outboundSchema;
  })(ListJobChecklistsResponse$ ||= {});
});

// src/models/operations/listjobcontacts.ts
var ListJobContactsResponse$inboundSchema, ListJobContactsResponse$outboundSchema, ListJobContactsResponse$;
var init_listjobcontacts = __esm(() => {
  init_lib();
  init_components();
  ListJobContactsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobContact$inboundSchema)
  ]);
  ListJobContactsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobContact$outboundSchema)
  ]);
  ((ListJobContactsResponse$) => {
    ListJobContactsResponse$.inboundSchema = ListJobContactsResponse$inboundSchema;
    ListJobContactsResponse$.outboundSchema = ListJobContactsResponse$outboundSchema;
  })(ListJobContactsResponse$ ||= {});
});

// src/models/operations/listjobmaterialbundles.ts
var ListJobMaterialBundlesResponse$inboundSchema, ListJobMaterialBundlesResponse$outboundSchema, ListJobMaterialBundlesResponse$;
var init_listjobmaterialbundles = __esm(() => {
  init_lib();
  init_components();
  ListJobMaterialBundlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobMaterialBundle$inboundSchema)
  ]);
  ListJobMaterialBundlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobMaterialBundle$outboundSchema)
  ]);
  ((ListJobMaterialBundlesResponse$) => {
    ListJobMaterialBundlesResponse$.inboundSchema = ListJobMaterialBundlesResponse$inboundSchema;
    ListJobMaterialBundlesResponse$.outboundSchema = ListJobMaterialBundlesResponse$outboundSchema;
  })(ListJobMaterialBundlesResponse$ ||= {});
});

// src/models/operations/listjobmaterials.ts
var ListJobMaterialsResponse$inboundSchema, ListJobMaterialsResponse$outboundSchema, ListJobMaterialsResponse$;
var init_listjobmaterials = __esm(() => {
  init_lib();
  init_components();
  ListJobMaterialsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobMaterial$inboundSchema)
  ]);
  ListJobMaterialsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobMaterial$outboundSchema)
  ]);
  ((ListJobMaterialsResponse$) => {
    ListJobMaterialsResponse$.inboundSchema = ListJobMaterialsResponse$inboundSchema;
    ListJobMaterialsResponse$.outboundSchema = ListJobMaterialsResponse$outboundSchema;
  })(ListJobMaterialsResponse$ ||= {});
});

// src/models/operations/listjobpayments.ts
var ListJobPaymentsResponse$inboundSchema, ListJobPaymentsResponse$outboundSchema, ListJobPaymentsResponse$;
var init_listjobpayments = __esm(() => {
  init_lib();
  init_components();
  ListJobPaymentsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(JobPayment$inboundSchema)
  ]);
  ListJobPaymentsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(JobPayment$outboundSchema)
  ]);
  ((ListJobPaymentsResponse$) => {
    ListJobPaymentsResponse$.inboundSchema = ListJobPaymentsResponse$inboundSchema;
    ListJobPaymentsResponse$.outboundSchema = ListJobPaymentsResponse$outboundSchema;
  })(ListJobPaymentsResponse$ ||= {});
});

// src/models/operations/listjobqueues.ts
var ListJobQueuesResponse$inboundSchema, ListJobQueuesResponse$outboundSchema, ListJobQueuesResponse$;
var init_listjobqueues = __esm(() => {
  init_lib();
  init_components();
  ListJobQueuesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Queue$inboundSchema)
  ]);
  ListJobQueuesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Queue$outboundSchema)
  ]);
  ((ListJobQueuesResponse$) => {
    ListJobQueuesResponse$.inboundSchema = ListJobQueuesResponse$inboundSchema;
    ListJobQueuesResponse$.outboundSchema = ListJobQueuesResponse$outboundSchema;
  })(ListJobQueuesResponse$ ||= {});
});

// src/models/operations/listjobs.ts
var ListJobsResponse$inboundSchema, ListJobsResponse$outboundSchema, ListJobsResponse$;
var init_listjobs = __esm(() => {
  init_lib();
  init_components();
  ListJobsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Job$inboundSchema)
  ]);
  ListJobsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Job$outboundSchema)
  ]);
  ((ListJobsResponse$) => {
    ListJobsResponse$.inboundSchema = ListJobsResponse$inboundSchema;
    ListJobsResponse$.outboundSchema = ListJobsResponse$outboundSchema;
  })(ListJobsResponse$ ||= {});
});

// src/models/operations/listknowledgearticles.ts
var ListKnowledgeArticlesResponse$inboundSchema, ListKnowledgeArticlesResponse$outboundSchema, ListKnowledgeArticlesResponse$;
var init_listknowledgearticles = __esm(() => {
  init_lib();
  init_components();
  ListKnowledgeArticlesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(KnowledgeArticle$inboundSchema)
  ]);
  ListKnowledgeArticlesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(KnowledgeArticle$outboundSchema)
  ]);
  ((ListKnowledgeArticlesResponse$) => {
    ListKnowledgeArticlesResponse$.inboundSchema = ListKnowledgeArticlesResponse$inboundSchema;
    ListKnowledgeArticlesResponse$.outboundSchema = ListKnowledgeArticlesResponse$outboundSchema;
  })(ListKnowledgeArticlesResponse$ ||= {});
});

// src/models/operations/listlocations.ts
var ListLocationsResponse$inboundSchema, ListLocationsResponse$outboundSchema, ListLocationsResponse$;
var init_listlocations = __esm(() => {
  init_lib();
  init_components();
  ListLocationsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Location$inboundSchema)
  ]);
  ListLocationsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Location$outboundSchema)
  ]);
  ((ListLocationsResponse$) => {
    ListLocationsResponse$.inboundSchema = ListLocationsResponse$inboundSchema;
    ListLocationsResponse$.outboundSchema = ListLocationsResponse$outboundSchema;
  })(ListLocationsResponse$ ||= {});
});

// src/models/operations/listmaterials.ts
var ListMaterialsResponse$inboundSchema, ListMaterialsResponse$outboundSchema, ListMaterialsResponse$;
var init_listmaterials = __esm(() => {
  init_lib();
  init_components();
  ListMaterialsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Material$inboundSchema)
  ]);
  ListMaterialsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Material$outboundSchema)
  ]);
  ((ListMaterialsResponse$) => {
    ListMaterialsResponse$.inboundSchema = ListMaterialsResponse$inboundSchema;
    ListMaterialsResponse$.outboundSchema = ListMaterialsResponse$outboundSchema;
  })(ListMaterialsResponse$ ||= {});
});

// src/models/operations/listnotes.ts
var ListNotesResponse$inboundSchema, ListNotesResponse$outboundSchema, ListNotesResponse$;
var init_listnotes = __esm(() => {
  init_lib();
  init_components();
  ListNotesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Note$inboundSchema)
  ]);
  ListNotesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Note$outboundSchema)
  ]);
  ((ListNotesResponse$) => {
    ListNotesResponse$.inboundSchema = ListNotesResponse$inboundSchema;
    ListNotesResponse$.outboundSchema = ListNotesResponse$outboundSchema;
  })(ListNotesResponse$ ||= {});
});

// src/models/operations/listsecurityroles.ts
var ListSecurityRolesResponse$inboundSchema, ListSecurityRolesResponse$outboundSchema, ListSecurityRolesResponse$;
var init_listsecurityroles = __esm(() => {
  init_lib();
  init_components();
  ListSecurityRolesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(SecurityRole$inboundSchema)
  ]);
  ListSecurityRolesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(SecurityRole$outboundSchema)
  ]);
  ((ListSecurityRolesResponse$) => {
    ListSecurityRolesResponse$.inboundSchema = ListSecurityRolesResponse$inboundSchema;
    ListSecurityRolesResponse$.outboundSchema = ListSecurityRolesResponse$outboundSchema;
  })(ListSecurityRolesResponse$ ||= {});
});

// src/models/operations/listsmstemplates.ts
var ListSMSTemplatesResponse$inboundSchema, ListSMSTemplatesResponse$outboundSchema, ListSMSTemplatesResponse$;
var init_listsmstemplates = __esm(() => {
  init_lib();
  init_components();
  ListSMSTemplatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(SmsTemplate$inboundSchema)
  ]);
  ListSMSTemplatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(SmsTemplate$outboundSchema)
  ]);
  ((ListSMSTemplatesResponse$) => {
    ListSMSTemplatesResponse$.inboundSchema = ListSMSTemplatesResponse$inboundSchema;
    ListSMSTemplatesResponse$.outboundSchema = ListSMSTemplatesResponse$outboundSchema;
  })(ListSMSTemplatesResponse$ ||= {});
});

// src/models/operations/liststaffmembers.ts
var ListStaffMembersResponse$inboundSchema, ListStaffMembersResponse$outboundSchema, ListStaffMembersResponse$;
var init_liststaffmembers = __esm(() => {
  init_lib();
  init_components();
  ListStaffMembersResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Staff$inboundSchema)
  ]);
  ListStaffMembersResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Staff$outboundSchema)
  ]);
  ((ListStaffMembersResponse$) => {
    ListStaffMembersResponse$.inboundSchema = ListStaffMembersResponse$inboundSchema;
    ListStaffMembersResponse$.outboundSchema = ListStaffMembersResponse$outboundSchema;
  })(ListStaffMembersResponse$ ||= {});
});

// src/models/operations/liststaffmessages.ts
var ListStaffMessagesResponse$inboundSchema, ListStaffMessagesResponse$outboundSchema, ListStaffMessagesResponse$;
var init_liststaffmessages = __esm(() => {
  init_lib();
  init_components();
  ListStaffMessagesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(StaffMessage$inboundSchema)
  ]);
  ListStaffMessagesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(StaffMessage$outboundSchema)
  ]);
  ((ListStaffMessagesResponse$) => {
    ListStaffMessagesResponse$.inboundSchema = ListStaffMessagesResponse$inboundSchema;
    ListStaffMessagesResponse$.outboundSchema = ListStaffMessagesResponse$outboundSchema;
  })(ListStaffMessagesResponse$ ||= {});
});

// src/models/operations/listtasks.ts
var ListTasksResponse$inboundSchema, ListTasksResponse$outboundSchema, ListTasksResponse$;
var init_listtasks = __esm(() => {
  init_lib();
  init_components();
  ListTasksResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Task$inboundSchema)
  ]);
  ListTasksResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Task$outboundSchema)
  ]);
  ((ListTasksResponse$) => {
    ListTasksResponse$.inboundSchema = ListTasksResponse$inboundSchema;
    ListTasksResponse$.outboundSchema = ListTasksResponse$outboundSchema;
  })(ListTasksResponse$ ||= {});
});

// src/models/operations/listtaxrates.ts
var ListTaxRatesResponse$inboundSchema, ListTaxRatesResponse$outboundSchema, ListTaxRatesResponse$;
var init_listtaxrates = __esm(() => {
  init_lib();
  init_components();
  ListTaxRatesResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(TaxRate$inboundSchema)
  ]);
  ListTaxRatesResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(TaxRate$outboundSchema)
  ]);
  ((ListTaxRatesResponse$) => {
    ListTaxRatesResponse$.inboundSchema = ListTaxRatesResponse$inboundSchema;
    ListTaxRatesResponse$.outboundSchema = ListTaxRatesResponse$outboundSchema;
  })(ListTaxRatesResponse$ ||= {});
});

// src/models/operations/listvendors.ts
var ListVendorsResponse$inboundSchema, ListVendorsResponse$outboundSchema, ListVendorsResponse$;
var init_listvendors = __esm(() => {
  init_lib();
  init_components();
  ListVendorsResponse$inboundSchema = unionType([
    ErrorT$inboundSchema,
    arrayType(Vendor$inboundSchema)
  ]);
  ListVendorsResponse$outboundSchema = unionType([
    ErrorT$outboundSchema,
    arrayType(Vendor$outboundSchema)
  ]);
  ((ListVendorsResponse$) => {
    ListVendorsResponse$.inboundSchema = ListVendorsResponse$inboundSchema;
    ListVendorsResponse$.outboundSchema = ListVendorsResponse$outboundSchema;
  })(ListVendorsResponse$ ||= {});
});

// src/models/operations/updateallocationwindows.ts
var UpdateAllocationWindowsRequest$inboundSchema, UpdateAllocationWindowsRequest$outboundSchema, UpdateAllocationWindowsRequest$, UpdateAllocationWindowsResponse$inboundSchema, UpdateAllocationWindowsResponse$outboundSchema, UpdateAllocationWindowsResponse$;
var init_updateallocationwindows = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateAllocationWindowsRequest$inboundSchema = objectType({
    uuid: stringType(),
    AllocationWindow: AllocationWindowInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      AllocationWindow: "allocationWindow"
    });
  });
  UpdateAllocationWindowsRequest$outboundSchema = objectType({
    uuid: stringType(),
    allocationWindow: AllocationWindowInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      allocationWindow: "AllocationWindow"
    });
  });
  ((UpdateAllocationWindowsRequest$) => {
    UpdateAllocationWindowsRequest$.inboundSchema = UpdateAllocationWindowsRequest$inboundSchema;
    UpdateAllocationWindowsRequest$.outboundSchema = UpdateAllocationWindowsRequest$outboundSchema;
  })(UpdateAllocationWindowsRequest$ ||= {});
  UpdateAllocationWindowsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateAllocationWindowsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateAllocationWindowsResponse$) => {
    UpdateAllocationWindowsResponse$.inboundSchema = UpdateAllocationWindowsResponse$inboundSchema;
    UpdateAllocationWindowsResponse$.outboundSchema = UpdateAllocationWindowsResponse$outboundSchema;
  })(UpdateAllocationWindowsResponse$ ||= {});
});

// src/models/operations/updateassets.ts
var UpdateAssetsRequest$inboundSchema, UpdateAssetsRequest$outboundSchema, UpdateAssetsRequest$, UpdateAssetsResponse$inboundSchema, UpdateAssetsResponse$outboundSchema, UpdateAssetsResponse$;
var init_updateassets = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateAssetsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Asset: AssetInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Asset: "asset"
    });
  });
  UpdateAssetsRequest$outboundSchema = objectType({
    uuid: stringType(),
    asset: AssetInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      asset: "Asset"
    });
  });
  ((UpdateAssetsRequest$) => {
    UpdateAssetsRequest$.inboundSchema = UpdateAssetsRequest$inboundSchema;
    UpdateAssetsRequest$.outboundSchema = UpdateAssetsRequest$outboundSchema;
  })(UpdateAssetsRequest$ ||= {});
  UpdateAssetsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateAssetsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateAssetsResponse$) => {
    UpdateAssetsResponse$.inboundSchema = UpdateAssetsResponse$inboundSchema;
    UpdateAssetsResponse$.outboundSchema = UpdateAssetsResponse$outboundSchema;
  })(UpdateAssetsResponse$ ||= {});
});

// src/models/operations/updateassettypefields.ts
var UpdateAssetTypeFieldsRequest$inboundSchema, UpdateAssetTypeFieldsRequest$outboundSchema, UpdateAssetTypeFieldsRequest$, UpdateAssetTypeFieldsResponse$inboundSchema, UpdateAssetTypeFieldsResponse$outboundSchema, UpdateAssetTypeFieldsResponse$;
var init_updateassettypefields = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateAssetTypeFieldsRequest$inboundSchema = objectType({
    uuid: stringType(),
    AssetTypeField: AssetTypeFieldInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      AssetTypeField: "assetTypeField"
    });
  });
  UpdateAssetTypeFieldsRequest$outboundSchema = objectType({
    uuid: stringType(),
    assetTypeField: AssetTypeFieldInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      assetTypeField: "AssetTypeField"
    });
  });
  ((UpdateAssetTypeFieldsRequest$) => {
    UpdateAssetTypeFieldsRequest$.inboundSchema = UpdateAssetTypeFieldsRequest$inboundSchema;
    UpdateAssetTypeFieldsRequest$.outboundSchema = UpdateAssetTypeFieldsRequest$outboundSchema;
  })(UpdateAssetTypeFieldsRequest$ ||= {});
  UpdateAssetTypeFieldsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateAssetTypeFieldsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateAssetTypeFieldsResponse$) => {
    UpdateAssetTypeFieldsResponse$.inboundSchema = UpdateAssetTypeFieldsResponse$inboundSchema;
    UpdateAssetTypeFieldsResponse$.outboundSchema = UpdateAssetTypeFieldsResponse$outboundSchema;
  })(UpdateAssetTypeFieldsResponse$ ||= {});
});

// src/models/operations/updateassettypes.ts
var UpdateAssetTypesRequest$inboundSchema, UpdateAssetTypesRequest$outboundSchema, UpdateAssetTypesRequest$, UpdateAssetTypesResponse$inboundSchema, UpdateAssetTypesResponse$outboundSchema, UpdateAssetTypesResponse$;
var init_updateassettypes = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateAssetTypesRequest$inboundSchema = objectType({
    uuid: stringType(),
    AssetType: AssetTypeInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      AssetType: "assetType"
    });
  });
  UpdateAssetTypesRequest$outboundSchema = objectType({
    uuid: stringType(),
    assetType: AssetTypeInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      assetType: "AssetType"
    });
  });
  ((UpdateAssetTypesRequest$) => {
    UpdateAssetTypesRequest$.inboundSchema = UpdateAssetTypesRequest$inboundSchema;
    UpdateAssetTypesRequest$.outboundSchema = UpdateAssetTypesRequest$outboundSchema;
  })(UpdateAssetTypesRequest$ ||= {});
  UpdateAssetTypesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateAssetTypesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateAssetTypesResponse$) => {
    UpdateAssetTypesResponse$.inboundSchema = UpdateAssetTypesResponse$inboundSchema;
    UpdateAssetTypesResponse$.outboundSchema = UpdateAssetTypesResponse$outboundSchema;
  })(UpdateAssetTypesResponse$ ||= {});
});

// src/models/operations/updateattachments.ts
var UpdateAttachmentsRequest$inboundSchema, UpdateAttachmentsRequest$outboundSchema, UpdateAttachmentsRequest$, UpdateAttachmentsResponse$inboundSchema, UpdateAttachmentsResponse$outboundSchema, UpdateAttachmentsResponse$;
var init_updateattachments = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateAttachmentsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Attachment: AttachmentInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Attachment: "attachment"
    });
  });
  UpdateAttachmentsRequest$outboundSchema = objectType({
    uuid: stringType(),
    attachment: AttachmentInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      attachment: "Attachment"
    });
  });
  ((UpdateAttachmentsRequest$) => {
    UpdateAttachmentsRequest$.inboundSchema = UpdateAttachmentsRequest$inboundSchema;
    UpdateAttachmentsRequest$.outboundSchema = UpdateAttachmentsRequest$outboundSchema;
  })(UpdateAttachmentsRequest$ ||= {});
  UpdateAttachmentsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateAttachmentsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateAttachmentsResponse$) => {
    UpdateAttachmentsResponse$.inboundSchema = UpdateAttachmentsResponse$inboundSchema;
    UpdateAttachmentsResponse$.outboundSchema = UpdateAttachmentsResponse$outboundSchema;
  })(UpdateAttachmentsResponse$ ||= {});
});

// src/models/operations/updatebadges.ts
var UpdateBadgesRequest$inboundSchema, UpdateBadgesRequest$outboundSchema, UpdateBadgesRequest$, UpdateBadgesResponse$inboundSchema, UpdateBadgesResponse$outboundSchema, UpdateBadgesResponse$;
var init_updatebadges = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateBadgesRequest$inboundSchema = objectType({
    uuid: stringType(),
    Badge: BadgeInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Badge: "badge"
    });
  });
  UpdateBadgesRequest$outboundSchema = objectType({
    uuid: stringType(),
    badge: BadgeInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      badge: "Badge"
    });
  });
  ((UpdateBadgesRequest$) => {
    UpdateBadgesRequest$.inboundSchema = UpdateBadgesRequest$inboundSchema;
    UpdateBadgesRequest$.outboundSchema = UpdateBadgesRequest$outboundSchema;
  })(UpdateBadgesRequest$ ||= {});
  UpdateBadgesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateBadgesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateBadgesResponse$) => {
    UpdateBadgesResponse$.inboundSchema = UpdateBadgesResponse$inboundSchema;
    UpdateBadgesResponse$.outboundSchema = UpdateBadgesResponse$outboundSchema;
  })(UpdateBadgesResponse$ ||= {});
});

// src/models/operations/updatebundles.ts
var UpdateBundlesRequest$inboundSchema, UpdateBundlesRequest$outboundSchema, UpdateBundlesRequest$, UpdateBundlesResponse$inboundSchema, UpdateBundlesResponse$outboundSchema, UpdateBundlesResponse$;
var init_updatebundles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateBundlesRequest$inboundSchema = objectType({
    uuid: stringType(),
    MaterialBundle: MaterialBundleInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      MaterialBundle: "materialBundle"
    });
  });
  UpdateBundlesRequest$outboundSchema = objectType({
    uuid: stringType(),
    materialBundle: MaterialBundleInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      materialBundle: "MaterialBundle"
    });
  });
  ((UpdateBundlesRequest$) => {
    UpdateBundlesRequest$.inboundSchema = UpdateBundlesRequest$inboundSchema;
    UpdateBundlesRequest$.outboundSchema = UpdateBundlesRequest$outboundSchema;
  })(UpdateBundlesRequest$ ||= {});
  UpdateBundlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateBundlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateBundlesResponse$) => {
    UpdateBundlesResponse$.inboundSchema = UpdateBundlesResponse$inboundSchema;
    UpdateBundlesResponse$.outboundSchema = UpdateBundlesResponse$outboundSchema;
  })(UpdateBundlesResponse$ ||= {});
});

// src/models/operations/updatecategories.ts
var UpdateCategoriesRequest$inboundSchema, UpdateCategoriesRequest$outboundSchema, UpdateCategoriesRequest$, UpdateCategoriesResponse$inboundSchema, UpdateCategoriesResponse$outboundSchema, UpdateCategoriesResponse$;
var init_updatecategories = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateCategoriesRequest$inboundSchema = objectType({
    uuid: stringType(),
    Category: CategoryInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Category: "category"
    });
  });
  UpdateCategoriesRequest$outboundSchema = objectType({
    uuid: stringType(),
    category: CategoryInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      category: "Category"
    });
  });
  ((UpdateCategoriesRequest$) => {
    UpdateCategoriesRequest$.inboundSchema = UpdateCategoriesRequest$inboundSchema;
    UpdateCategoriesRequest$.outboundSchema = UpdateCategoriesRequest$outboundSchema;
  })(UpdateCategoriesRequest$ ||= {});
  UpdateCategoriesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateCategoriesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateCategoriesResponse$) => {
    UpdateCategoriesResponse$.inboundSchema = UpdateCategoriesResponse$inboundSchema;
    UpdateCategoriesResponse$.outboundSchema = UpdateCategoriesResponse$outboundSchema;
  })(UpdateCategoriesResponse$ ||= {});
});

// src/models/operations/updateclients.ts
var UpdateClientsRequest$inboundSchema, UpdateClientsRequest$outboundSchema, UpdateClientsRequest$, UpdateClientsResponse$inboundSchema, UpdateClientsResponse$outboundSchema, UpdateClientsResponse$;
var init_updateclients = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateClientsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Company: CompanyInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Company: "company"
    });
  });
  UpdateClientsRequest$outboundSchema = objectType({
    uuid: stringType(),
    company: CompanyInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      company: "Company"
    });
  });
  ((UpdateClientsRequest$) => {
    UpdateClientsRequest$.inboundSchema = UpdateClientsRequest$inboundSchema;
    UpdateClientsRequest$.outboundSchema = UpdateClientsRequest$outboundSchema;
  })(UpdateClientsRequest$ ||= {});
  UpdateClientsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateClientsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateClientsResponse$) => {
    UpdateClientsResponse$.inboundSchema = UpdateClientsResponse$inboundSchema;
    UpdateClientsResponse$.outboundSchema = UpdateClientsResponse$outboundSchema;
  })(UpdateClientsResponse$ ||= {});
});

// src/models/operations/updatecompanycontacts.ts
var UpdateCompanyContactsRequest$inboundSchema, UpdateCompanyContactsRequest$outboundSchema, UpdateCompanyContactsRequest$, UpdateCompanyContactsResponse$inboundSchema, UpdateCompanyContactsResponse$outboundSchema, UpdateCompanyContactsResponse$;
var init_updatecompanycontacts = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateCompanyContactsRequest$inboundSchema = objectType({
    uuid: stringType(),
    CompanyContact: CompanyContactInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      CompanyContact: "companyContact"
    });
  });
  UpdateCompanyContactsRequest$outboundSchema = objectType({
    uuid: stringType(),
    companyContact: CompanyContactInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      companyContact: "CompanyContact"
    });
  });
  ((UpdateCompanyContactsRequest$) => {
    UpdateCompanyContactsRequest$.inboundSchema = UpdateCompanyContactsRequest$inboundSchema;
    UpdateCompanyContactsRequest$.outboundSchema = UpdateCompanyContactsRequest$outboundSchema;
  })(UpdateCompanyContactsRequest$ ||= {});
  UpdateCompanyContactsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateCompanyContactsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateCompanyContactsResponse$) => {
    UpdateCompanyContactsResponse$.inboundSchema = UpdateCompanyContactsResponse$inboundSchema;
    UpdateCompanyContactsResponse$.outboundSchema = UpdateCompanyContactsResponse$outboundSchema;
  })(UpdateCompanyContactsResponse$ ||= {});
});

// src/models/operations/updateemailtemplates.ts
var UpdateEmailTemplatesRequest$inboundSchema, UpdateEmailTemplatesRequest$outboundSchema, UpdateEmailTemplatesRequest$, UpdateEmailTemplatesResponse$inboundSchema, UpdateEmailTemplatesResponse$outboundSchema, UpdateEmailTemplatesResponse$;
var init_updateemailtemplates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateEmailTemplatesRequest$inboundSchema = objectType({
    uuid: stringType(),
    EmailTemplate: EmailTemplateInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      EmailTemplate: "emailTemplate"
    });
  });
  UpdateEmailTemplatesRequest$outboundSchema = objectType({
    uuid: stringType(),
    emailTemplate: EmailTemplateInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      emailTemplate: "EmailTemplate"
    });
  });
  ((UpdateEmailTemplatesRequest$) => {
    UpdateEmailTemplatesRequest$.inboundSchema = UpdateEmailTemplatesRequest$inboundSchema;
    UpdateEmailTemplatesRequest$.outboundSchema = UpdateEmailTemplatesRequest$outboundSchema;
  })(UpdateEmailTemplatesRequest$ ||= {});
  UpdateEmailTemplatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateEmailTemplatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateEmailTemplatesResponse$) => {
    UpdateEmailTemplatesResponse$.inboundSchema = UpdateEmailTemplatesResponse$inboundSchema;
    UpdateEmailTemplatesResponse$.outboundSchema = UpdateEmailTemplatesResponse$outboundSchema;
  })(UpdateEmailTemplatesResponse$ ||= {});
});

// src/models/operations/updatefeedback.ts
var UpdateFeedbackRequest$inboundSchema, UpdateFeedbackRequest$outboundSchema, UpdateFeedbackRequest$, UpdateFeedbackResponse$inboundSchema, UpdateFeedbackResponse$outboundSchema, UpdateFeedbackResponse$;
var init_updatefeedback = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateFeedbackRequest$inboundSchema = objectType({
    uuid: stringType(),
    Feedback: FeedbackInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Feedback: "feedback"
    });
  });
  UpdateFeedbackRequest$outboundSchema = objectType({
    uuid: stringType(),
    feedback: FeedbackInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      feedback: "Feedback"
    });
  });
  ((UpdateFeedbackRequest$) => {
    UpdateFeedbackRequest$.inboundSchema = UpdateFeedbackRequest$inboundSchema;
    UpdateFeedbackRequest$.outboundSchema = UpdateFeedbackRequest$outboundSchema;
  })(UpdateFeedbackRequest$ ||= {});
  UpdateFeedbackResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateFeedbackResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateFeedbackResponse$) => {
    UpdateFeedbackResponse$.inboundSchema = UpdateFeedbackResponse$inboundSchema;
    UpdateFeedbackResponse$.outboundSchema = UpdateFeedbackResponse$outboundSchema;
  })(UpdateFeedbackResponse$ ||= {});
});

// src/models/operations/updateformfields.ts
var UpdateFormFieldsRequest$inboundSchema, UpdateFormFieldsRequest$outboundSchema, UpdateFormFieldsRequest$, UpdateFormFieldsResponse$inboundSchema, UpdateFormFieldsResponse$outboundSchema, UpdateFormFieldsResponse$;
var init_updateformfields = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateFormFieldsRequest$inboundSchema = objectType({
    uuid: stringType(),
    FormField: FormFieldInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      FormField: "formField"
    });
  });
  UpdateFormFieldsRequest$outboundSchema = objectType({
    uuid: stringType(),
    formField: FormFieldInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      formField: "FormField"
    });
  });
  ((UpdateFormFieldsRequest$) => {
    UpdateFormFieldsRequest$.inboundSchema = UpdateFormFieldsRequest$inboundSchema;
    UpdateFormFieldsRequest$.outboundSchema = UpdateFormFieldsRequest$outboundSchema;
  })(UpdateFormFieldsRequest$ ||= {});
  UpdateFormFieldsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateFormFieldsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateFormFieldsResponse$) => {
    UpdateFormFieldsResponse$.inboundSchema = UpdateFormFieldsResponse$inboundSchema;
    UpdateFormFieldsResponse$.outboundSchema = UpdateFormFieldsResponse$outboundSchema;
  })(UpdateFormFieldsResponse$ ||= {});
});

// src/models/operations/updateformresponses.ts
var UpdateFormResponsesRequest$inboundSchema, UpdateFormResponsesRequest$outboundSchema, UpdateFormResponsesRequest$, UpdateFormResponsesResponse$inboundSchema, UpdateFormResponsesResponse$outboundSchema, UpdateFormResponsesResponse$;
var init_updateformresponses = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateFormResponsesRequest$inboundSchema = objectType({
    uuid: stringType(),
    FormResponse: FormResponseInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      FormResponse: "formResponse"
    });
  });
  UpdateFormResponsesRequest$outboundSchema = objectType({
    uuid: stringType(),
    formResponse: FormResponseInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      formResponse: "FormResponse"
    });
  });
  ((UpdateFormResponsesRequest$) => {
    UpdateFormResponsesRequest$.inboundSchema = UpdateFormResponsesRequest$inboundSchema;
    UpdateFormResponsesRequest$.outboundSchema = UpdateFormResponsesRequest$outboundSchema;
  })(UpdateFormResponsesRequest$ ||= {});
  UpdateFormResponsesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateFormResponsesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateFormResponsesResponse$) => {
    UpdateFormResponsesResponse$.inboundSchema = UpdateFormResponsesResponse$inboundSchema;
    UpdateFormResponsesResponse$.outboundSchema = UpdateFormResponsesResponse$outboundSchema;
  })(UpdateFormResponsesResponse$ ||= {});
});

// src/models/operations/updateforms.ts
var UpdateFormsRequest$inboundSchema, UpdateFormsRequest$outboundSchema, UpdateFormsRequest$, UpdateFormsResponse$inboundSchema, UpdateFormsResponse$outboundSchema, UpdateFormsResponse$;
var init_updateforms = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateFormsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Form: FormInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Form: "form"
    });
  });
  UpdateFormsRequest$outboundSchema = objectType({
    uuid: stringType(),
    form: FormInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      form: "Form"
    });
  });
  ((UpdateFormsRequest$) => {
    UpdateFormsRequest$.inboundSchema = UpdateFormsRequest$inboundSchema;
    UpdateFormsRequest$.outboundSchema = UpdateFormsRequest$outboundSchema;
  })(UpdateFormsRequest$ ||= {});
  UpdateFormsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateFormsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateFormsResponse$) => {
    UpdateFormsResponse$.inboundSchema = UpdateFormsResponse$inboundSchema;
    UpdateFormsResponse$.outboundSchema = UpdateFormsResponse$outboundSchema;
  })(UpdateFormsResponse$ ||= {});
});

// src/models/operations/updatejobactivities.ts
var UpdateJobActivitiesRequest$inboundSchema, UpdateJobActivitiesRequest$outboundSchema, UpdateJobActivitiesRequest$, UpdateJobActivitiesResponse$inboundSchema, UpdateJobActivitiesResponse$outboundSchema, UpdateJobActivitiesResponse$;
var init_updatejobactivities = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobActivitiesRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobActivity: JobActivityInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobActivity: "jobActivity"
    });
  });
  UpdateJobActivitiesRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobActivity: JobActivityInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobActivity: "JobActivity"
    });
  });
  ((UpdateJobActivitiesRequest$) => {
    UpdateJobActivitiesRequest$.inboundSchema = UpdateJobActivitiesRequest$inboundSchema;
    UpdateJobActivitiesRequest$.outboundSchema = UpdateJobActivitiesRequest$outboundSchema;
  })(UpdateJobActivitiesRequest$ ||= {});
  UpdateJobActivitiesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobActivitiesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobActivitiesResponse$) => {
    UpdateJobActivitiesResponse$.inboundSchema = UpdateJobActivitiesResponse$inboundSchema;
    UpdateJobActivitiesResponse$.outboundSchema = UpdateJobActivitiesResponse$outboundSchema;
  })(UpdateJobActivitiesResponse$ ||= {});
});

// src/models/operations/updatejoballocations.ts
var UpdateJobAllocationsRequest$inboundSchema, UpdateJobAllocationsRequest$outboundSchema, UpdateJobAllocationsRequest$, UpdateJobAllocationsResponse$inboundSchema, UpdateJobAllocationsResponse$outboundSchema, UpdateJobAllocationsResponse$;
var init_updatejoballocations = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobAllocationsRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobAllocation: JobAllocationInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobAllocation: "jobAllocation"
    });
  });
  UpdateJobAllocationsRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobAllocation: JobAllocationInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobAllocation: "JobAllocation"
    });
  });
  ((UpdateJobAllocationsRequest$) => {
    UpdateJobAllocationsRequest$.inboundSchema = UpdateJobAllocationsRequest$inboundSchema;
    UpdateJobAllocationsRequest$.outboundSchema = UpdateJobAllocationsRequest$outboundSchema;
  })(UpdateJobAllocationsRequest$ ||= {});
  UpdateJobAllocationsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobAllocationsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobAllocationsResponse$) => {
    UpdateJobAllocationsResponse$.inboundSchema = UpdateJobAllocationsResponse$inboundSchema;
    UpdateJobAllocationsResponse$.outboundSchema = UpdateJobAllocationsResponse$outboundSchema;
  })(UpdateJobAllocationsResponse$ ||= {});
});

// src/models/operations/updatejobchecklists.ts
var UpdateJobChecklistsRequest$inboundSchema, UpdateJobChecklistsRequest$outboundSchema, UpdateJobChecklistsRequest$, UpdateJobChecklistsResponse$inboundSchema, UpdateJobChecklistsResponse$outboundSchema, UpdateJobChecklistsResponse$;
var init_updatejobchecklists = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobChecklistsRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobChecklist: JobChecklistInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobChecklist: "jobChecklist"
    });
  });
  UpdateJobChecklistsRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobChecklist: JobChecklistInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobChecklist: "JobChecklist"
    });
  });
  ((UpdateJobChecklistsRequest$) => {
    UpdateJobChecklistsRequest$.inboundSchema = UpdateJobChecklistsRequest$inboundSchema;
    UpdateJobChecklistsRequest$.outboundSchema = UpdateJobChecklistsRequest$outboundSchema;
  })(UpdateJobChecklistsRequest$ ||= {});
  UpdateJobChecklistsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobChecklistsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobChecklistsResponse$) => {
    UpdateJobChecklistsResponse$.inboundSchema = UpdateJobChecklistsResponse$inboundSchema;
    UpdateJobChecklistsResponse$.outboundSchema = UpdateJobChecklistsResponse$outboundSchema;
  })(UpdateJobChecklistsResponse$ ||= {});
});

// src/models/operations/updatejobcontacts.ts
var UpdateJobContactsRequest$inboundSchema, UpdateJobContactsRequest$outboundSchema, UpdateJobContactsRequest$, UpdateJobContactsResponse$inboundSchema, UpdateJobContactsResponse$outboundSchema, UpdateJobContactsResponse$;
var init_updatejobcontacts = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobContactsRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobContact: JobContactInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobContact: "jobContact"
    });
  });
  UpdateJobContactsRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobContact: JobContactInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobContact: "JobContact"
    });
  });
  ((UpdateJobContactsRequest$) => {
    UpdateJobContactsRequest$.inboundSchema = UpdateJobContactsRequest$inboundSchema;
    UpdateJobContactsRequest$.outboundSchema = UpdateJobContactsRequest$outboundSchema;
  })(UpdateJobContactsRequest$ ||= {});
  UpdateJobContactsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobContactsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobContactsResponse$) => {
    UpdateJobContactsResponse$.inboundSchema = UpdateJobContactsResponse$inboundSchema;
    UpdateJobContactsResponse$.outboundSchema = UpdateJobContactsResponse$outboundSchema;
  })(UpdateJobContactsResponse$ ||= {});
});

// src/models/operations/updatejobmaterialbundles.ts
var UpdateJobMaterialBundlesRequest$inboundSchema, UpdateJobMaterialBundlesRequest$outboundSchema, UpdateJobMaterialBundlesRequest$, UpdateJobMaterialBundlesResponse$inboundSchema, UpdateJobMaterialBundlesResponse$outboundSchema, UpdateJobMaterialBundlesResponse$;
var init_updatejobmaterialbundles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobMaterialBundlesRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobMaterialBundle: JobMaterialBundleInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobMaterialBundle: "jobMaterialBundle"
    });
  });
  UpdateJobMaterialBundlesRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobMaterialBundle: JobMaterialBundleInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobMaterialBundle: "JobMaterialBundle"
    });
  });
  ((UpdateJobMaterialBundlesRequest$) => {
    UpdateJobMaterialBundlesRequest$.inboundSchema = UpdateJobMaterialBundlesRequest$inboundSchema;
    UpdateJobMaterialBundlesRequest$.outboundSchema = UpdateJobMaterialBundlesRequest$outboundSchema;
  })(UpdateJobMaterialBundlesRequest$ ||= {});
  UpdateJobMaterialBundlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobMaterialBundlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobMaterialBundlesResponse$) => {
    UpdateJobMaterialBundlesResponse$.inboundSchema = UpdateJobMaterialBundlesResponse$inboundSchema;
    UpdateJobMaterialBundlesResponse$.outboundSchema = UpdateJobMaterialBundlesResponse$outboundSchema;
  })(UpdateJobMaterialBundlesResponse$ ||= {});
});

// src/models/operations/updatejobmaterials.ts
var UpdateJobMaterialsRequest$inboundSchema, UpdateJobMaterialsRequest$outboundSchema, UpdateJobMaterialsRequest$, UpdateJobMaterialsResponse$inboundSchema, UpdateJobMaterialsResponse$outboundSchema, UpdateJobMaterialsResponse$;
var init_updatejobmaterials = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobMaterialsRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobMaterial: JobMaterialInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobMaterial: "jobMaterial"
    });
  });
  UpdateJobMaterialsRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobMaterial: JobMaterialInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobMaterial: "JobMaterial"
    });
  });
  ((UpdateJobMaterialsRequest$) => {
    UpdateJobMaterialsRequest$.inboundSchema = UpdateJobMaterialsRequest$inboundSchema;
    UpdateJobMaterialsRequest$.outboundSchema = UpdateJobMaterialsRequest$outboundSchema;
  })(UpdateJobMaterialsRequest$ ||= {});
  UpdateJobMaterialsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobMaterialsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobMaterialsResponse$) => {
    UpdateJobMaterialsResponse$.inboundSchema = UpdateJobMaterialsResponse$inboundSchema;
    UpdateJobMaterialsResponse$.outboundSchema = UpdateJobMaterialsResponse$outboundSchema;
  })(UpdateJobMaterialsResponse$ ||= {});
});

// src/models/operations/updatejobpayments.ts
var UpdateJobPaymentsRequest$inboundSchema, UpdateJobPaymentsRequest$outboundSchema, UpdateJobPaymentsRequest$, UpdateJobPaymentsResponse$inboundSchema, UpdateJobPaymentsResponse$outboundSchema, UpdateJobPaymentsResponse$;
var init_updatejobpayments = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobPaymentsRequest$inboundSchema = objectType({
    uuid: stringType(),
    JobPayment: JobPaymentInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      JobPayment: "jobPayment"
    });
  });
  UpdateJobPaymentsRequest$outboundSchema = objectType({
    uuid: stringType(),
    jobPayment: JobPaymentInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      jobPayment: "JobPayment"
    });
  });
  ((UpdateJobPaymentsRequest$) => {
    UpdateJobPaymentsRequest$.inboundSchema = UpdateJobPaymentsRequest$inboundSchema;
    UpdateJobPaymentsRequest$.outboundSchema = UpdateJobPaymentsRequest$outboundSchema;
  })(UpdateJobPaymentsRequest$ ||= {});
  UpdateJobPaymentsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobPaymentsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobPaymentsResponse$) => {
    UpdateJobPaymentsResponse$.inboundSchema = UpdateJobPaymentsResponse$inboundSchema;
    UpdateJobPaymentsResponse$.outboundSchema = UpdateJobPaymentsResponse$outboundSchema;
  })(UpdateJobPaymentsResponse$ ||= {});
});

// src/models/operations/updatejobqueues.ts
var UpdateJobQueuesRequest$inboundSchema, UpdateJobQueuesRequest$outboundSchema, UpdateJobQueuesRequest$, UpdateJobQueuesResponse$inboundSchema, UpdateJobQueuesResponse$outboundSchema, UpdateJobQueuesResponse$;
var init_updatejobqueues = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobQueuesRequest$inboundSchema = objectType({
    uuid: stringType(),
    Queue: QueueInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Queue: "queue"
    });
  });
  UpdateJobQueuesRequest$outboundSchema = objectType({
    uuid: stringType(),
    queue: QueueInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      queue: "Queue"
    });
  });
  ((UpdateJobQueuesRequest$) => {
    UpdateJobQueuesRequest$.inboundSchema = UpdateJobQueuesRequest$inboundSchema;
    UpdateJobQueuesRequest$.outboundSchema = UpdateJobQueuesRequest$outboundSchema;
  })(UpdateJobQueuesRequest$ ||= {});
  UpdateJobQueuesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobQueuesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobQueuesResponse$) => {
    UpdateJobQueuesResponse$.inboundSchema = UpdateJobQueuesResponse$inboundSchema;
    UpdateJobQueuesResponse$.outboundSchema = UpdateJobQueuesResponse$outboundSchema;
  })(UpdateJobQueuesResponse$ ||= {});
});

// src/models/operations/updatejobs.ts
var UpdateJobsRequest$inboundSchema, UpdateJobsRequest$outboundSchema, UpdateJobsRequest$, UpdateJobsResponse$inboundSchema, UpdateJobsResponse$outboundSchema, UpdateJobsResponse$;
var init_updatejobs = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateJobsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Job: JobInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Job: "job"
    });
  });
  UpdateJobsRequest$outboundSchema = objectType({
    uuid: stringType(),
    job: JobInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      job: "Job"
    });
  });
  ((UpdateJobsRequest$) => {
    UpdateJobsRequest$.inboundSchema = UpdateJobsRequest$inboundSchema;
    UpdateJobsRequest$.outboundSchema = UpdateJobsRequest$outboundSchema;
  })(UpdateJobsRequest$ ||= {});
  UpdateJobsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateJobsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateJobsResponse$) => {
    UpdateJobsResponse$.inboundSchema = UpdateJobsResponse$inboundSchema;
    UpdateJobsResponse$.outboundSchema = UpdateJobsResponse$outboundSchema;
  })(UpdateJobsResponse$ ||= {});
});

// src/models/operations/updateknowledgearticles.ts
var UpdateKnowledgeArticlesRequest$inboundSchema, UpdateKnowledgeArticlesRequest$outboundSchema, UpdateKnowledgeArticlesRequest$, UpdateKnowledgeArticlesResponse$inboundSchema, UpdateKnowledgeArticlesResponse$outboundSchema, UpdateKnowledgeArticlesResponse$;
var init_updateknowledgearticles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateKnowledgeArticlesRequest$inboundSchema = objectType({
    uuid: stringType(),
    KnowledgeArticle: KnowledgeArticleInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      KnowledgeArticle: "knowledgeArticle"
    });
  });
  UpdateKnowledgeArticlesRequest$outboundSchema = objectType({
    uuid: stringType(),
    knowledgeArticle: KnowledgeArticleInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      knowledgeArticle: "KnowledgeArticle"
    });
  });
  ((UpdateKnowledgeArticlesRequest$) => {
    UpdateKnowledgeArticlesRequest$.inboundSchema = UpdateKnowledgeArticlesRequest$inboundSchema;
    UpdateKnowledgeArticlesRequest$.outboundSchema = UpdateKnowledgeArticlesRequest$outboundSchema;
  })(UpdateKnowledgeArticlesRequest$ ||= {});
  UpdateKnowledgeArticlesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateKnowledgeArticlesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateKnowledgeArticlesResponse$) => {
    UpdateKnowledgeArticlesResponse$.inboundSchema = UpdateKnowledgeArticlesResponse$inboundSchema;
    UpdateKnowledgeArticlesResponse$.outboundSchema = UpdateKnowledgeArticlesResponse$outboundSchema;
  })(UpdateKnowledgeArticlesResponse$ ||= {});
});

// src/models/operations/updatelocations.ts
var UpdateLocationsRequest$inboundSchema, UpdateLocationsRequest$outboundSchema, UpdateLocationsRequest$, UpdateLocationsResponse$inboundSchema, UpdateLocationsResponse$outboundSchema, UpdateLocationsResponse$;
var init_updatelocations = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateLocationsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Location: LocationInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Location: "location"
    });
  });
  UpdateLocationsRequest$outboundSchema = objectType({
    uuid: stringType(),
    location: LocationInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      location: "Location"
    });
  });
  ((UpdateLocationsRequest$) => {
    UpdateLocationsRequest$.inboundSchema = UpdateLocationsRequest$inboundSchema;
    UpdateLocationsRequest$.outboundSchema = UpdateLocationsRequest$outboundSchema;
  })(UpdateLocationsRequest$ ||= {});
  UpdateLocationsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateLocationsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateLocationsResponse$) => {
    UpdateLocationsResponse$.inboundSchema = UpdateLocationsResponse$inboundSchema;
    UpdateLocationsResponse$.outboundSchema = UpdateLocationsResponse$outboundSchema;
  })(UpdateLocationsResponse$ ||= {});
});

// src/models/operations/updatematerials.ts
var UpdateMaterialsRequest$inboundSchema, UpdateMaterialsRequest$outboundSchema, UpdateMaterialsRequest$, UpdateMaterialsResponse$inboundSchema, UpdateMaterialsResponse$outboundSchema, UpdateMaterialsResponse$;
var init_updatematerials = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateMaterialsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Material: MaterialInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Material: "material"
    });
  });
  UpdateMaterialsRequest$outboundSchema = objectType({
    uuid: stringType(),
    material: MaterialInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      material: "Material"
    });
  });
  ((UpdateMaterialsRequest$) => {
    UpdateMaterialsRequest$.inboundSchema = UpdateMaterialsRequest$inboundSchema;
    UpdateMaterialsRequest$.outboundSchema = UpdateMaterialsRequest$outboundSchema;
  })(UpdateMaterialsRequest$ ||= {});
  UpdateMaterialsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateMaterialsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateMaterialsResponse$) => {
    UpdateMaterialsResponse$.inboundSchema = UpdateMaterialsResponse$inboundSchema;
    UpdateMaterialsResponse$.outboundSchema = UpdateMaterialsResponse$outboundSchema;
  })(UpdateMaterialsResponse$ ||= {});
});

// src/models/operations/updatenotes.ts
var UpdateNotesRequest$inboundSchema, UpdateNotesRequest$outboundSchema, UpdateNotesRequest$, UpdateNotesResponse$inboundSchema, UpdateNotesResponse$outboundSchema, UpdateNotesResponse$;
var init_updatenotes = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateNotesRequest$inboundSchema = objectType({
    uuid: stringType(),
    Note: NoteInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Note: "note"
    });
  });
  UpdateNotesRequest$outboundSchema = objectType({
    uuid: stringType(),
    note: NoteInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      note: "Note"
    });
  });
  ((UpdateNotesRequest$) => {
    UpdateNotesRequest$.inboundSchema = UpdateNotesRequest$inboundSchema;
    UpdateNotesRequest$.outboundSchema = UpdateNotesRequest$outboundSchema;
  })(UpdateNotesRequest$ ||= {});
  UpdateNotesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateNotesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateNotesResponse$) => {
    UpdateNotesResponse$.inboundSchema = UpdateNotesResponse$inboundSchema;
    UpdateNotesResponse$.outboundSchema = UpdateNotesResponse$outboundSchema;
  })(UpdateNotesResponse$ ||= {});
});

// src/models/operations/updatesecurityroles.ts
var UpdateSecurityRolesRequest$inboundSchema, UpdateSecurityRolesRequest$outboundSchema, UpdateSecurityRolesRequest$, UpdateSecurityRolesResponse$inboundSchema, UpdateSecurityRolesResponse$outboundSchema, UpdateSecurityRolesResponse$;
var init_updatesecurityroles = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateSecurityRolesRequest$inboundSchema = objectType({
    uuid: stringType(),
    SecurityRole: SecurityRoleInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      SecurityRole: "securityRole"
    });
  });
  UpdateSecurityRolesRequest$outboundSchema = objectType({
    uuid: stringType(),
    securityRole: SecurityRoleInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      securityRole: "SecurityRole"
    });
  });
  ((UpdateSecurityRolesRequest$) => {
    UpdateSecurityRolesRequest$.inboundSchema = UpdateSecurityRolesRequest$inboundSchema;
    UpdateSecurityRolesRequest$.outboundSchema = UpdateSecurityRolesRequest$outboundSchema;
  })(UpdateSecurityRolesRequest$ ||= {});
  UpdateSecurityRolesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateSecurityRolesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateSecurityRolesResponse$) => {
    UpdateSecurityRolesResponse$.inboundSchema = UpdateSecurityRolesResponse$inboundSchema;
    UpdateSecurityRolesResponse$.outboundSchema = UpdateSecurityRolesResponse$outboundSchema;
  })(UpdateSecurityRolesResponse$ ||= {});
});

// src/models/operations/updatesmstemplates.ts
var UpdateSMSTemplatesRequest$inboundSchema, UpdateSMSTemplatesRequest$outboundSchema, UpdateSMSTemplatesRequest$, UpdateSMSTemplatesResponse$inboundSchema, UpdateSMSTemplatesResponse$outboundSchema, UpdateSMSTemplatesResponse$;
var init_updatesmstemplates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateSMSTemplatesRequest$inboundSchema = objectType({
    uuid: stringType(),
    SmsTemplate: SmsTemplateInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      SmsTemplate: "smsTemplate"
    });
  });
  UpdateSMSTemplatesRequest$outboundSchema = objectType({
    uuid: stringType(),
    smsTemplate: SmsTemplateInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      smsTemplate: "SmsTemplate"
    });
  });
  ((UpdateSMSTemplatesRequest$) => {
    UpdateSMSTemplatesRequest$.inboundSchema = UpdateSMSTemplatesRequest$inboundSchema;
    UpdateSMSTemplatesRequest$.outboundSchema = UpdateSMSTemplatesRequest$outboundSchema;
  })(UpdateSMSTemplatesRequest$ ||= {});
  UpdateSMSTemplatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateSMSTemplatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateSMSTemplatesResponse$) => {
    UpdateSMSTemplatesResponse$.inboundSchema = UpdateSMSTemplatesResponse$inboundSchema;
    UpdateSMSTemplatesResponse$.outboundSchema = UpdateSMSTemplatesResponse$outboundSchema;
  })(UpdateSMSTemplatesResponse$ ||= {});
});

// src/models/operations/updatestaffmembers.ts
var UpdateStaffMembersRequest$inboundSchema, UpdateStaffMembersRequest$outboundSchema, UpdateStaffMembersRequest$, UpdateStaffMembersResponse$inboundSchema, UpdateStaffMembersResponse$outboundSchema, UpdateStaffMembersResponse$;
var init_updatestaffmembers = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateStaffMembersRequest$inboundSchema = objectType({
    uuid: stringType(),
    Staff: StaffInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Staff: "staff"
    });
  });
  UpdateStaffMembersRequest$outboundSchema = objectType({
    uuid: stringType(),
    staff: StaffInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      staff: "Staff"
    });
  });
  ((UpdateStaffMembersRequest$) => {
    UpdateStaffMembersRequest$.inboundSchema = UpdateStaffMembersRequest$inboundSchema;
    UpdateStaffMembersRequest$.outboundSchema = UpdateStaffMembersRequest$outboundSchema;
  })(UpdateStaffMembersRequest$ ||= {});
  UpdateStaffMembersResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateStaffMembersResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateStaffMembersResponse$) => {
    UpdateStaffMembersResponse$.inboundSchema = UpdateStaffMembersResponse$inboundSchema;
    UpdateStaffMembersResponse$.outboundSchema = UpdateStaffMembersResponse$outboundSchema;
  })(UpdateStaffMembersResponse$ ||= {});
});

// src/models/operations/updatestaffmessages.ts
var UpdateStaffMessagesRequest$inboundSchema, UpdateStaffMessagesRequest$outboundSchema, UpdateStaffMessagesRequest$, UpdateStaffMessagesResponse$inboundSchema, UpdateStaffMessagesResponse$outboundSchema, UpdateStaffMessagesResponse$;
var init_updatestaffmessages = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateStaffMessagesRequest$inboundSchema = objectType({
    uuid: stringType(),
    StaffMessage: StaffMessageInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      StaffMessage: "staffMessage"
    });
  });
  UpdateStaffMessagesRequest$outboundSchema = objectType({
    uuid: stringType(),
    staffMessage: StaffMessageInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      staffMessage: "StaffMessage"
    });
  });
  ((UpdateStaffMessagesRequest$) => {
    UpdateStaffMessagesRequest$.inboundSchema = UpdateStaffMessagesRequest$inboundSchema;
    UpdateStaffMessagesRequest$.outboundSchema = UpdateStaffMessagesRequest$outboundSchema;
  })(UpdateStaffMessagesRequest$ ||= {});
  UpdateStaffMessagesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateStaffMessagesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateStaffMessagesResponse$) => {
    UpdateStaffMessagesResponse$.inboundSchema = UpdateStaffMessagesResponse$inboundSchema;
    UpdateStaffMessagesResponse$.outboundSchema = UpdateStaffMessagesResponse$outboundSchema;
  })(UpdateStaffMessagesResponse$ ||= {});
});

// src/models/operations/updatetasks.ts
var UpdateTasksRequest$inboundSchema, UpdateTasksRequest$outboundSchema, UpdateTasksRequest$, UpdateTasksResponse$inboundSchema, UpdateTasksResponse$outboundSchema, UpdateTasksResponse$;
var init_updatetasks = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateTasksRequest$inboundSchema = objectType({
    uuid: stringType(),
    Task: TaskInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Task: "task"
    });
  });
  UpdateTasksRequest$outboundSchema = objectType({
    uuid: stringType(),
    task: TaskInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      task: "Task"
    });
  });
  ((UpdateTasksRequest$) => {
    UpdateTasksRequest$.inboundSchema = UpdateTasksRequest$inboundSchema;
    UpdateTasksRequest$.outboundSchema = UpdateTasksRequest$outboundSchema;
  })(UpdateTasksRequest$ ||= {});
  UpdateTasksResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateTasksResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateTasksResponse$) => {
    UpdateTasksResponse$.inboundSchema = UpdateTasksResponse$inboundSchema;
    UpdateTasksResponse$.outboundSchema = UpdateTasksResponse$outboundSchema;
  })(UpdateTasksResponse$ ||= {});
});

// src/models/operations/updatetaxrates.ts
var UpdateTaxRatesRequest$inboundSchema, UpdateTaxRatesRequest$outboundSchema, UpdateTaxRatesRequest$, UpdateTaxRatesResponse$inboundSchema, UpdateTaxRatesResponse$outboundSchema, UpdateTaxRatesResponse$;
var init_updatetaxrates = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateTaxRatesRequest$inboundSchema = objectType({
    uuid: stringType(),
    TaxRate: TaxRateInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      TaxRate: "taxRate"
    });
  });
  UpdateTaxRatesRequest$outboundSchema = objectType({
    uuid: stringType(),
    taxRate: TaxRateInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      taxRate: "TaxRate"
    });
  });
  ((UpdateTaxRatesRequest$) => {
    UpdateTaxRatesRequest$.inboundSchema = UpdateTaxRatesRequest$inboundSchema;
    UpdateTaxRatesRequest$.outboundSchema = UpdateTaxRatesRequest$outboundSchema;
  })(UpdateTaxRatesRequest$ ||= {});
  UpdateTaxRatesResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateTaxRatesResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateTaxRatesResponse$) => {
    UpdateTaxRatesResponse$.inboundSchema = UpdateTaxRatesResponse$inboundSchema;
    UpdateTaxRatesResponse$.outboundSchema = UpdateTaxRatesResponse$outboundSchema;
  })(UpdateTaxRatesResponse$ ||= {});
});

// src/models/operations/updatevendors.ts
var UpdateVendorsRequest$inboundSchema, UpdateVendorsRequest$outboundSchema, UpdateVendorsRequest$, UpdateVendorsResponse$inboundSchema, UpdateVendorsResponse$outboundSchema, UpdateVendorsResponse$;
var init_updatevendors = __esm(() => {
  init_lib();
  init_primitives();
  init_components();
  UpdateVendorsRequest$inboundSchema = objectType({
    uuid: stringType(),
    Vendor: VendorInput$inboundSchema
  }).transform((v2) => {
    return remap(v2, {
      Vendor: "vendor"
    });
  });
  UpdateVendorsRequest$outboundSchema = objectType({
    uuid: stringType(),
    vendor: VendorInput$outboundSchema
  }).transform((v2) => {
    return remap(v2, {
      vendor: "Vendor"
    });
  });
  ((UpdateVendorsRequest$) => {
    UpdateVendorsRequest$.inboundSchema = UpdateVendorsRequest$inboundSchema;
    UpdateVendorsRequest$.outboundSchema = UpdateVendorsRequest$outboundSchema;
  })(UpdateVendorsRequest$ ||= {});
  UpdateVendorsResponse$inboundSchema = unionType([Result$inboundSchema, ErrorT$inboundSchema]);
  UpdateVendorsResponse$outboundSchema = unionType([
    Result$outboundSchema,
    ErrorT$outboundSchema
  ]);
  ((UpdateVendorsResponse$) => {
    UpdateVendorsResponse$.inboundSchema = UpdateVendorsResponse$inboundSchema;
    UpdateVendorsResponse$.outboundSchema = UpdateVendorsResponse$outboundSchema;
  })(UpdateVendorsResponse$ ||= {});
});

// src/models/operations/index.ts
var init_operations = __esm(() => {
  init_createallocationwindows();
  init_createassettypefields();
  init_createassettypes();
  init_createattachments();
  init_createbadges();
  init_createbundles();
  init_createcategories();
  init_createclients();
  init_createcompanycontacts();
  init_createemailtemplates();
  init_createfeedback();
  init_createformfields();
  init_createformresponses();
  init_createforms();
  init_createjobactivities();
  init_createjoballocations();
  init_createjobchecklists();
  init_createjobcontacts();
  init_createjobmaterialbundles();
  init_createjobmaterials();
  init_createjobpayments();
  init_createjobqueues();
  init_createjobs();
  init_createknowledgearticles();
  init_createlocations();
  init_creatematerials();
  init_createnotes();
  init_createsecurityroles();
  init_createsmstemplates();
  init_createstaffmembers();
  init_createstaffmessages();
  init_createtasks();
  init_createtaxrates();
  init_deleteallocationwindows();
  init_deleteassets();
  init_deleteassettypefields();
  init_deleteassettypes();
  init_deleteattachments();
  init_deletebadges();
  init_deletebundles();
  init_deletecategories();
  init_deleteclients();
  init_deletecompanycontacts();
  init_deleteemailtemplates();
  init_deletefeedback();
  init_deleteformfields();
  init_deleteformresponses();
  init_deleteforms();
  init_deletejobactivities();
  init_deletejoballocations();
  init_deletejobchecklists();
  init_deletejobcontacts();
  init_deletejobmaterialbundles();
  init_deletejobmaterials();
  init_deletejobpayments();
  init_deletejobqueues();
  init_deletejobs();
  init_deleteknowledgearticles();
  init_deletelocations();
  init_deletematerials();
  init_deletenotes();
  init_deletesecurityroles();
  init_deletesmstemplates();
  init_deletestaffmembers();
  init_deletestaffmessages();
  init_deletetasks();
  init_deletetaxrates();
  init_getallocationwindows();
  init_getassets();
  init_getassettypefields();
  init_getassettypes();
  init_getattachments();
  init_getbadges();
  init_getbundles();
  init_getcategories();
  init_getclients();
  init_getcompanycontacts();
  init_getemailtemplates();
  init_getfeedback();
  init_getformfields();
  init_getformresponses();
  init_getforms();
  init_getjobactivities();
  init_getjoballocations();
  init_getjobchecklists();
  init_getjobcontacts();
  init_getjobmaterialbundles();
  init_getjobmaterials();
  init_getjobpayments();
  init_getjobqueues();
  init_getjobs();
  init_getknowledgearticles();
  init_getlocations();
  init_getmaterials();
  init_getnotes();
  init_getsecurityroles();
  init_getsmstemplates();
  init_getstaffmembers();
  init_getstaffmessages();
  init_gettasks();
  init_gettaxrates();
  init_getvendors();
  init_listallocationwindows();
  init_listassets();
  init_listassettypefields();
  init_listassettypes();
  init_listattachments();
  init_listbadges();
  init_listbundles();
  init_listcategories();
  init_listclients();
  init_listcompanycontacts();
  init_listemailtemplates();
  init_listfeedback();
  init_listformfields();
  init_listformresponses();
  init_listforms();
  init_listjobactivities();
  init_listjoballocations();
  init_listjobchecklists();
  init_listjobcontacts();
  init_listjobmaterialbundles();
  init_listjobmaterials();
  init_listjobpayments();
  init_listjobqueues();
  init_listjobs();
  init_listknowledgearticles();
  init_listlocations();
  init_listmaterials();
  init_listnotes();
  init_listsecurityroles();
  init_listsmstemplates();
  init_liststaffmembers();
  init_liststaffmessages();
  init_listtasks();
  init_listtaxrates();
  init_listvendors();
  init_updateallocationwindows();
  init_updateassets();
  init_updateassettypefields();
  init_updateassettypes();
  init_updateattachments();
  init_updatebadges();
  init_updatebundles();
  init_updatecategories();
  init_updateclients();
  init_updatecompanycontacts();
  init_updateemailtemplates();
  init_updatefeedback();
  init_updateformfields();
  init_updateformresponses();
  init_updateforms();
  init_updatejobactivities();
  init_updatejoballocations();
  init_updatejobchecklists();
  init_updatejobcontacts();
  init_updatejobmaterialbundles();
  init_updatejobmaterials();
  init_updatejobpayments();
  init_updatejobqueues();
  init_updatejobs();
  init_updateknowledgearticles();
  init_updatelocations();
  init_updatematerials();
  init_updatenotes();
  init_updatesecurityroles();
  init_updatesmstemplates();
  init_updatestaffmembers();
  init_updatestaffmessages();
  init_updatetasks();
  init_updatetaxrates();
  init_updatevendors();
});

// src/types/async.ts
var APIPromise;
var init_async = __esm(() => {
  APIPromise = class APIPromise {
    #promise;
    #unwrapped;
    [Symbol.toStringTag] = "APIPromise";
    constructor(p) {
      this.#promise = p instanceof Promise ? p : Promise.resolve(p);
      this.#unwrapped = p instanceof Promise ? this.#promise.then(([value]) => value) : Promise.resolve(p[0]);
    }
    then(onfulfilled, onrejected) {
      return this.#promise.then(onfulfilled ? ([value]) => onfulfilled(value) : undefined, onrejected);
    }
    catch(onrejected) {
      return this.#unwrapped.catch(onrejected);
    }
    finally(onfinally) {
      return this.#unwrapped.finally(onfinally);
    }
    $inspect() {
      return this.#promise;
    }
  };
});

// src/funcs/allocationWindowsCreateAllocationWindows.ts
function allocationWindowsCreateAllocationWindows(client, request, options) {
  return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
  const parsed = safeParse(request, (value) => AllocationWindowInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/allocationwindow.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createAllocationWindows",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateAllocationWindowsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateAllocationWindowsResponse$inboundSchema, { key: "Result" }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_allocationWindowsCreateAllocationWindows = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/allocationWindowsCreateAllocationWindows.ts
var args, tool$allocationWindowsCreateAllocationWindows;
var init_allocationWindowsCreateAllocationWindows2 = __esm(() => {
  init_allocationWindowsCreateAllocationWindows();
  init_components();
  init_tools();
  args = {
    request: AllocationWindowInput$inboundSchema
  };
  tool$allocationWindowsCreateAllocationWindows = {
    name: "allocation-windows-create-allocation-windows",
    description: `Create a new Allocation Window


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args,
    tool: async (client, args2, ctx) => {
      const [result2, apiCall] = await allocationWindowsCreateAllocationWindows(client, args2.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/allocationWindowsDeleteAllocationWindows.ts
function allocationWindowsDeleteAllocationWindows(client, request, options) {
  return new APIPromise($do2(client, request, options));
}
async function $do2(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteAllocationWindowsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/allocationwindow/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteAllocationWindows",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteAllocationWindowsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteAllocationWindowsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_allocationWindowsDeleteAllocationWindows = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/allocationWindowsDeleteAllocationWindows.ts
var args2, tool$allocationWindowsDeleteAllocationWindows;
var init_allocationWindowsDeleteAllocationWindows2 = __esm(() => {
  init_allocationWindowsDeleteAllocationWindows();
  init_operations();
  init_tools();
  args2 = {
    request: DeleteAllocationWindowsRequest$inboundSchema
  };
  tool$allocationWindowsDeleteAllocationWindows = {
    name: "allocation-windows-delete-allocation-windows",
    description: `Delete an Allocation Window


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args2,
    tool: async (client, args3, ctx) => {
      const [result2, apiCall] = await allocationWindowsDeleteAllocationWindows(client, args3.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/allocationWindowsGetAllocationWindows.ts
function allocationWindowsGetAllocationWindows(client, request, options) {
  return new APIPromise($do3(client, request, options));
}
async function $do3(client, request, options) {
  const parsed = safeParse(request, (value) => GetAllocationWindowsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/allocationwindow/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getAllocationWindows",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetAllocationWindowsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetAllocationWindowsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_allocationWindowsGetAllocationWindows = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/allocationWindowsGetAllocationWindows.ts
var args3, tool$allocationWindowsGetAllocationWindows;
var init_allocationWindowsGetAllocationWindows2 = __esm(() => {
  init_allocationWindowsGetAllocationWindows();
  init_operations();
  init_tools();
  args3 = {
    request: GetAllocationWindowsRequest$inboundSchema
  };
  tool$allocationWindowsGetAllocationWindows = {
    name: "allocation-windows-get-allocation-windows",
    description: `Retrieve an Allocation Window`,
    args: args3,
    tool: async (client, args4, ctx) => {
      const [result2, apiCall] = await allocationWindowsGetAllocationWindows(client, args4.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/allocationWindowsListAllocationWindows.ts
function allocationWindowsListAllocationWindows(client, options) {
  return new APIPromise($do4(client, options));
}
async function $do4(client, options) {
  const path = pathToFunc("/allocationwindow.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listAllocationWindows",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListAllocationWindowsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListAllocationWindowsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_allocationWindowsListAllocationWindows = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/allocationWindowsListAllocationWindows.ts
var tool$allocationWindowsListAllocationWindows;
var init_allocationWindowsListAllocationWindows2 = __esm(() => {
  init_allocationWindowsListAllocationWindows();
  init_tools();
  tool$allocationWindowsListAllocationWindows = {
    name: "allocation-windows-list-allocation-windows",
    description: `List all Allocation Windows


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await allocationWindowsListAllocationWindows(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/allocationWindowsUpdateAllocationWindows.ts
function allocationWindowsUpdateAllocationWindows(client, request, options) {
  return new APIPromise($do5(client, request, options));
}
async function $do5(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateAllocationWindowsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.AllocationWindow, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/allocationwindow/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateAllocationWindows",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateAllocationWindowsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateAllocationWindowsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_allocationWindowsUpdateAllocationWindows = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/allocationWindowsUpdateAllocationWindows.ts
var args4, tool$allocationWindowsUpdateAllocationWindows;
var init_allocationWindowsUpdateAllocationWindows2 = __esm(() => {
  init_allocationWindowsUpdateAllocationWindows();
  init_operations();
  init_tools();
  args4 = {
    request: UpdateAllocationWindowsRequest$inboundSchema
  };
  tool$allocationWindowsUpdateAllocationWindows = {
    name: "allocation-windows-update-allocation-windows",
    description: `Update an Allocation Window`,
    args: args4,
    tool: async (client, args5, ctx) => {
      const [result2, apiCall] = await allocationWindowsUpdateAllocationWindows(client, args5.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetsDeleteAssets.ts
function assetsDeleteAssets(client, request, options) {
  return new APIPromise($do6(client, request, options));
}
async function $do6(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteAssetsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/asset/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteAssets",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteAssetsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteAssetsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetsDeleteAssets = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetsDeleteAssets.ts
var args5, tool$assetsDeleteAssets;
var init_assetsDeleteAssets2 = __esm(() => {
  init_assetsDeleteAssets();
  init_operations();
  init_tools();
  args5 = {
    request: DeleteAssetsRequest$inboundSchema
  };
  tool$assetsDeleteAssets = {
    name: "assets-delete-assets",
    description: `Delete an Asset


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args5,
    tool: async (client, args6, ctx) => {
      const [result2, apiCall] = await assetsDeleteAssets(client, args6.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetsGetAssets.ts
function assetsGetAssets(client, request, options) {
  return new APIPromise($do7(client, request, options));
}
async function $do7(client, request, options) {
  const parsed = safeParse(request, (value) => GetAssetsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/asset/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getAssets",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetAssetsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetAssetsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetsGetAssets = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetsGetAssets.ts
var args6, tool$assetsGetAssets;
var init_assetsGetAssets2 = __esm(() => {
  init_assetsGetAssets();
  init_operations();
  init_tools();
  args6 = {
    request: GetAssetsRequest$inboundSchema
  };
  tool$assetsGetAssets = {
    name: "assets-get-assets",
    description: `Retrieve an Asset


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    args: args6,
    tool: async (client, args7, ctx) => {
      const [result2, apiCall] = await assetsGetAssets(client, args7.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetsListAssets.ts
function assetsListAssets(client, options) {
  return new APIPromise($do8(client, options));
}
async function $do8(client, options) {
  const path = pathToFunc("/asset.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listAssets",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListAssetsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListAssetsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetsListAssets = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetsListAssets.ts
var tool$assetsListAssets;
var init_assetsListAssets2 = __esm(() => {
  init_assetsListAssets();
  init_tools();
  tool$assetsListAssets = {
    name: "assets-list-assets",
    description: `List all Assets


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await assetsListAssets(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetsUpdateAssets.ts
function assetsUpdateAssets(client, request, options) {
  return new APIPromise($do9(client, request, options));
}
async function $do9(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateAssetsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Asset, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/asset/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateAssets",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateAssetsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateAssetsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetsUpdateAssets = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetsUpdateAssets.ts
var args7, tool$assetsUpdateAssets;
var init_assetsUpdateAssets2 = __esm(() => {
  init_assetsUpdateAssets();
  init_operations();
  init_tools();
  args7 = {
    request: UpdateAssetsRequest$inboundSchema
  };
  tool$assetsUpdateAssets = {
    name: "assets-update-assets",
    description: `Update an Asset`,
    args: args7,
    tool: async (client, args8, ctx) => {
      const [result2, apiCall] = await assetsUpdateAssets(client, args8.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypeFieldsCreateAssetTypeFields.ts
function assetTypeFieldsCreateAssetTypeFields(client, request, options) {
  return new APIPromise($do10(client, request, options));
}
async function $do10(client, request, options) {
  const parsed = safeParse(request, (value) => AssetTypeFieldInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/assettypefield.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createAssetTypeFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateAssetTypeFieldsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateAssetTypeFieldsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypeFieldsCreateAssetTypeFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypeFieldsCreateAssetTypeFields.ts
var args8, tool$assetTypeFieldsCreateAssetTypeFields;
var init_assetTypeFieldsCreateAssetTypeFields2 = __esm(() => {
  init_assetTypeFieldsCreateAssetTypeFields();
  init_components();
  init_tools();
  args8 = {
    request: AssetTypeFieldInput$inboundSchema
  };
  tool$assetTypeFieldsCreateAssetTypeFields = {
    name: "asset-type-fields-create-asset-type-fields",
    description: `Create a new Asset Type Field


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_assets**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args8,
    tool: async (client, args9, ctx) => {
      const [result2, apiCall] = await assetTypeFieldsCreateAssetTypeFields(client, args9.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypeFieldsDeleteAssetTypeFields.ts
function assetTypeFieldsDeleteAssetTypeFields(client, request, options) {
  return new APIPromise($do11(client, request, options));
}
async function $do11(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteAssetTypeFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettypefield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteAssetTypeFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteAssetTypeFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteAssetTypeFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypeFieldsDeleteAssetTypeFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypeFieldsDeleteAssetTypeFields.ts
var args9, tool$assetTypeFieldsDeleteAssetTypeFields;
var init_assetTypeFieldsDeleteAssetTypeFields2 = __esm(() => {
  init_assetTypeFieldsDeleteAssetTypeFields();
  init_operations();
  init_tools();
  args9 = {
    request: DeleteAssetTypeFieldsRequest$inboundSchema
  };
  tool$assetTypeFieldsDeleteAssetTypeFields = {
    name: "asset-type-fields-delete-asset-type-fields",
    description: `Delete an Asset Type Field


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args9,
    tool: async (client, args10, ctx) => {
      const [result2, apiCall] = await assetTypeFieldsDeleteAssetTypeFields(client, args10.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypeFieldsGetAssetTypeFields.ts
function assetTypeFieldsGetAssetTypeFields(client, request, options) {
  return new APIPromise($do12(client, request, options));
}
async function $do12(client, request, options) {
  const parsed = safeParse(request, (value) => GetAssetTypeFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettypefield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getAssetTypeFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetAssetTypeFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetAssetTypeFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypeFieldsGetAssetTypeFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypeFieldsGetAssetTypeFields.ts
var args10, tool$assetTypeFieldsGetAssetTypeFields;
var init_assetTypeFieldsGetAssetTypeFields2 = __esm(() => {
  init_assetTypeFieldsGetAssetTypeFields();
  init_operations();
  init_tools();
  args10 = {
    request: GetAssetTypeFieldsRequest$inboundSchema
  };
  tool$assetTypeFieldsGetAssetTypeFields = {
    name: "asset-type-fields-get-asset-type-fields",
    description: `Retrieve an Asset Type Field


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    args: args10,
    tool: async (client, args11, ctx) => {
      const [result2, apiCall] = await assetTypeFieldsGetAssetTypeFields(client, args11.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypeFieldsListAssetTypeFields.ts
function assetTypeFieldsListAssetTypeFields(client, options) {
  return new APIPromise($do13(client, options));
}
async function $do13(client, options) {
  const path = pathToFunc("/assettypefield.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listAssetTypeFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListAssetTypeFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListAssetTypeFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypeFieldsListAssetTypeFields = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypeFieldsListAssetTypeFields.ts
var tool$assetTypeFieldsListAssetTypeFields;
var init_assetTypeFieldsListAssetTypeFields2 = __esm(() => {
  init_assetTypeFieldsListAssetTypeFields();
  init_tools();
  tool$assetTypeFieldsListAssetTypeFields = {
    name: "asset-type-fields-list-asset-type-fields",
    description: `List all Asset Type Fields


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await assetTypeFieldsListAssetTypeFields(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypeFieldsUpdateAssetTypeFields.ts
function assetTypeFieldsUpdateAssetTypeFields(client, request, options) {
  return new APIPromise($do14(client, request, options));
}
async function $do14(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateAssetTypeFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.AssetTypeField, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettypefield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateAssetTypeFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateAssetTypeFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateAssetTypeFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypeFieldsUpdateAssetTypeFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypeFieldsUpdateAssetTypeFields.ts
var args11, tool$assetTypeFieldsUpdateAssetTypeFields;
var init_assetTypeFieldsUpdateAssetTypeFields2 = __esm(() => {
  init_assetTypeFieldsUpdateAssetTypeFields();
  init_operations();
  init_tools();
  args11 = {
    request: UpdateAssetTypeFieldsRequest$inboundSchema
  };
  tool$assetTypeFieldsUpdateAssetTypeFields = {
    name: "asset-type-fields-update-asset-type-fields",
    description: `Update an Asset Type Field`,
    args: args11,
    tool: async (client, args12, ctx) => {
      const [result2, apiCall] = await assetTypeFieldsUpdateAssetTypeFields(client, args12.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypesCreateAssetTypes.ts
function assetTypesCreateAssetTypes(client, request, options) {
  return new APIPromise($do15(client, request, options));
}
async function $do15(client, request, options) {
  const parsed = safeParse(request, (value) => AssetTypeInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/assettype.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createAssetTypes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateAssetTypesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateAssetTypesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypesCreateAssetTypes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypesCreateAssetTypes.ts
var args12, tool$assetTypesCreateAssetTypes;
var init_assetTypesCreateAssetTypes2 = __esm(() => {
  init_assetTypesCreateAssetTypes();
  init_components();
  init_tools();
  args12 = {
    request: AssetTypeInput$inboundSchema
  };
  tool$assetTypesCreateAssetTypes = {
    name: "asset-types-create-asset-types",
    description: `Create a new Asset Type


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_assets**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args12,
    tool: async (client, args13, ctx) => {
      const [result2, apiCall] = await assetTypesCreateAssetTypes(client, args13.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypesDeleteAssetTypes.ts
function assetTypesDeleteAssetTypes(client, request, options) {
  return new APIPromise($do16(client, request, options));
}
async function $do16(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteAssetTypesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettype/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteAssetTypes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteAssetTypesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteAssetTypesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypesDeleteAssetTypes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypesDeleteAssetTypes.ts
var args13, tool$assetTypesDeleteAssetTypes;
var init_assetTypesDeleteAssetTypes2 = __esm(() => {
  init_assetTypesDeleteAssetTypes();
  init_operations();
  init_tools();
  args13 = {
    request: DeleteAssetTypesRequest$inboundSchema
  };
  tool$assetTypesDeleteAssetTypes = {
    name: "asset-types-delete-asset-types",
    description: `Delete an Asset Type


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args13,
    tool: async (client, args14, ctx) => {
      const [result2, apiCall] = await assetTypesDeleteAssetTypes(client, args14.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypesGetAssetTypes.ts
function assetTypesGetAssetTypes(client, request, options) {
  return new APIPromise($do17(client, request, options));
}
async function $do17(client, request, options) {
  const parsed = safeParse(request, (value) => GetAssetTypesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettype/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getAssetTypes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetAssetTypesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetAssetTypesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypesGetAssetTypes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypesGetAssetTypes.ts
var args14, tool$assetTypesGetAssetTypes;
var init_assetTypesGetAssetTypes2 = __esm(() => {
  init_assetTypesGetAssetTypes();
  init_operations();
  init_tools();
  args14 = {
    request: GetAssetTypesRequest$inboundSchema
  };
  tool$assetTypesGetAssetTypes = {
    name: "asset-types-get-asset-types",
    description: `Retrieve an Asset Type


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    args: args14,
    tool: async (client, args15, ctx) => {
      const [result2, apiCall] = await assetTypesGetAssetTypes(client, args15.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypesListAssetTypes.ts
function assetTypesListAssetTypes(client, options) {
  return new APIPromise($do18(client, options));
}
async function $do18(client, options) {
  const path = pathToFunc("/assettype.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listAssetTypes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListAssetTypesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListAssetTypesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypesListAssetTypes = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypesListAssetTypes.ts
var tool$assetTypesListAssetTypes;
var init_assetTypesListAssetTypes2 = __esm(() => {
  init_assetTypesListAssetTypes();
  init_tools();
  tool$assetTypesListAssetTypes = {
    name: "asset-types-list-asset-types",
    description: `List all Asset Types


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_assets**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await assetTypesListAssetTypes(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/assetTypesUpdateAssetTypes.ts
function assetTypesUpdateAssetTypes(client, request, options) {
  return new APIPromise($do19(client, request, options));
}
async function $do19(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateAssetTypesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.AssetType, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/assettype/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateAssetTypes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateAssetTypesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateAssetTypesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_assetTypesUpdateAssetTypes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/assetTypesUpdateAssetTypes.ts
var args15, tool$assetTypesUpdateAssetTypes;
var init_assetTypesUpdateAssetTypes2 = __esm(() => {
  init_assetTypesUpdateAssetTypes();
  init_operations();
  init_tools();
  args15 = {
    request: UpdateAssetTypesRequest$inboundSchema
  };
  tool$assetTypesUpdateAssetTypes = {
    name: "asset-types-update-asset-types",
    description: `Update an Asset Type`,
    args: args15,
    tool: async (client, args16, ctx) => {
      const [result2, apiCall] = await assetTypesUpdateAssetTypes(client, args16.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/attachmentsCreateAttachments.ts
function attachmentsCreateAttachments(client, request, options) {
  return new APIPromise($do20(client, request, options));
}
async function $do20(client, request, options) {
  const parsed = safeParse(request, (value) => AttachmentInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/attachment.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createAttachments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateAttachmentsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateAttachmentsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_attachmentsCreateAttachments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/attachmentsCreateAttachments.ts
var args16, tool$attachmentsCreateAttachments;
var init_attachmentsCreateAttachments2 = __esm(() => {
  init_attachmentsCreateAttachments();
  init_components();
  init_tools();
  args16 = {
    request: AttachmentInput$inboundSchema
  };
  tool$attachmentsCreateAttachments = {
    name: "attachments-create-attachments",
    description: `Create a new Attachment


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args16,
    tool: async (client, args17, ctx) => {
      const [result2, apiCall] = await attachmentsCreateAttachments(client, args17.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/attachmentsDeleteAttachments.ts
function attachmentsDeleteAttachments(client, request, options) {
  return new APIPromise($do21(client, request, options));
}
async function $do21(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteAttachmentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/attachment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteAttachments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteAttachmentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteAttachmentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_attachmentsDeleteAttachments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/attachmentsDeleteAttachments.ts
var args17, tool$attachmentsDeleteAttachments;
var init_attachmentsDeleteAttachments2 = __esm(() => {
  init_attachmentsDeleteAttachments();
  init_operations();
  init_tools();
  args17 = {
    request: DeleteAttachmentsRequest$inboundSchema
  };
  tool$attachmentsDeleteAttachments = {
    name: "attachments-delete-attachments",
    description: `Delete an Attachment


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args17,
    tool: async (client, args18, ctx) => {
      const [result2, apiCall] = await attachmentsDeleteAttachments(client, args18.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/attachmentsGetAttachments.ts
function attachmentsGetAttachments(client, request, options) {
  return new APIPromise($do22(client, request, options));
}
async function $do22(client, request, options) {
  const parsed = safeParse(request, (value) => GetAttachmentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/attachment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getAttachments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetAttachmentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetAttachmentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_attachmentsGetAttachments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/attachmentsGetAttachments.ts
var args18, tool$attachmentsGetAttachments;
var init_attachmentsGetAttachments2 = __esm(() => {
  init_attachmentsGetAttachments();
  init_operations();
  init_tools();
  args18 = {
    request: GetAttachmentsRequest$inboundSchema
  };
  tool$attachmentsGetAttachments = {
    name: "attachments-get-attachments",
    description: `Retrieve an Attachment`,
    args: args18,
    tool: async (client, args19, ctx) => {
      const [result2, apiCall] = await attachmentsGetAttachments(client, args19.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/attachmentsListAttachments.ts
function attachmentsListAttachments(client, options) {
  return new APIPromise($do23(client, options));
}
async function $do23(client, options) {
  const path = pathToFunc("/attachment.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listAttachments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListAttachmentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListAttachmentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_attachmentsListAttachments = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/attachmentsListAttachments.ts
var tool$attachmentsListAttachments;
var init_attachmentsListAttachments2 = __esm(() => {
  init_attachmentsListAttachments();
  init_tools();
  tool$attachmentsListAttachments = {
    name: "attachments-list-attachments",
    description: `List all Attachments


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await attachmentsListAttachments(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/attachmentsUpdateAttachments.ts
function attachmentsUpdateAttachments(client, request, options) {
  return new APIPromise($do24(client, request, options));
}
async function $do24(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateAttachmentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Attachment, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/attachment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateAttachments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateAttachmentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateAttachmentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_attachmentsUpdateAttachments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/attachmentsUpdateAttachments.ts
var args19, tool$attachmentsUpdateAttachments;
var init_attachmentsUpdateAttachments2 = __esm(() => {
  init_attachmentsUpdateAttachments();
  init_operations();
  init_tools();
  args19 = {
    request: UpdateAttachmentsRequest$inboundSchema
  };
  tool$attachmentsUpdateAttachments = {
    name: "attachments-update-attachments",
    description: `Update an Attachment`,
    args: args19,
    tool: async (client, args20, ctx) => {
      const [result2, apiCall] = await attachmentsUpdateAttachments(client, args20.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/badgesCreateBadges.ts
function badgesCreateBadges(client, request, options) {
  return new APIPromise($do25(client, request, options));
}
async function $do25(client, request, options) {
  const parsed = safeParse(request, (value) => BadgeInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/badge.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createBadges",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateBadgesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateBadgesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_badgesCreateBadges = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/badgesCreateBadges.ts
var args20, tool$badgesCreateBadges;
var init_badgesCreateBadges2 = __esm(() => {
  init_badgesCreateBadges();
  init_components();
  init_tools();
  args20 = {
    request: BadgeInput$inboundSchema
  };
  tool$badgesCreateBadges = {
    name: "badges-create-badges",
    description: `Create a new Badge


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_badges**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args20,
    tool: async (client, args21, ctx) => {
      const [result2, apiCall] = await badgesCreateBadges(client, args21.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/badgesDeleteBadges.ts
function badgesDeleteBadges(client, request, options) {
  return new APIPromise($do26(client, request, options));
}
async function $do26(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteBadgesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/badge/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteBadges",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteBadgesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteBadgesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_badgesDeleteBadges = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/badgesDeleteBadges.ts
var args21, tool$badgesDeleteBadges;
var init_badgesDeleteBadges2 = __esm(() => {
  init_badgesDeleteBadges();
  init_operations();
  init_tools();
  args21 = {
    request: DeleteBadgesRequest$inboundSchema
  };
  tool$badgesDeleteBadges = {
    name: "badges-delete-badges",
    description: `Delete a Badge


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args21,
    tool: async (client, args22, ctx) => {
      const [result2, apiCall] = await badgesDeleteBadges(client, args22.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/badgesGetBadges.ts
function badgesGetBadges(client, request, options) {
  return new APIPromise($do27(client, request, options));
}
async function $do27(client, request, options) {
  const parsed = safeParse(request, (value) => GetBadgesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/badge/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getBadges",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetBadgesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetBadgesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_badgesGetBadges = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/badgesGetBadges.ts
var args22, tool$badgesGetBadges;
var init_badgesGetBadges2 = __esm(() => {
  init_badgesGetBadges();
  init_operations();
  init_tools();
  args22 = {
    request: GetBadgesRequest$inboundSchema
  };
  tool$badgesGetBadges = {
    name: "badges-get-badges",
    description: `Retrieve a Badge


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_badges**.

			`,
    args: args22,
    tool: async (client, args23, ctx) => {
      const [result2, apiCall] = await badgesGetBadges(client, args23.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/badgesListBadges.ts
function badgesListBadges(client, options) {
  return new APIPromise($do28(client, options));
}
async function $do28(client, options) {
  const path = pathToFunc("/badge.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listBadges",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListBadgesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListBadgesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_badgesListBadges = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/badgesListBadges.ts
var tool$badgesListBadges;
var init_badgesListBadges2 = __esm(() => {
  init_badgesListBadges();
  init_tools();
  tool$badgesListBadges = {
    name: "badges-list-badges",
    description: `List all Badges


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_badges**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await badgesListBadges(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/badgesUpdateBadges.ts
function badgesUpdateBadges(client, request, options) {
  return new APIPromise($do29(client, request, options));
}
async function $do29(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateBadgesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Badge, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/badge/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateBadges",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateBadgesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateBadgesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_badgesUpdateBadges = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/badgesUpdateBadges.ts
var args23, tool$badgesUpdateBadges;
var init_badgesUpdateBadges2 = __esm(() => {
  init_badgesUpdateBadges();
  init_operations();
  init_tools();
  args23 = {
    request: UpdateBadgesRequest$inboundSchema
  };
  tool$badgesUpdateBadges = {
    name: "badges-update-badges",
    description: `Update a Badge`,
    args: args23,
    tool: async (client, args24, ctx) => {
      const [result2, apiCall] = await badgesUpdateBadges(client, args24.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/bundlesCreateBundles.ts
function bundlesCreateBundles(client, request, options) {
  return new APIPromise($do30(client, request, options));
}
async function $do30(client, request, options) {
  const parsed = safeParse(request, (value) => MaterialBundleInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/materialbundle.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateBundlesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateBundlesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_bundlesCreateBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/bundlesCreateBundles.ts
var args24, tool$bundlesCreateBundles;
var init_bundlesCreateBundles2 = __esm(() => {
  init_bundlesCreateBundles();
  init_components();
  init_tools();
  args24 = {
    request: MaterialBundleInput$inboundSchema
  };
  tool$bundlesCreateBundles = {
    name: "bundles-create-bundles",
    description: `Create a new Bundle


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args24,
    tool: async (client, args25, ctx) => {
      const [result2, apiCall] = await bundlesCreateBundles(client, args25.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/bundlesDeleteBundles.ts
function bundlesDeleteBundles(client, request, options) {
  return new APIPromise($do31(client, request, options));
}
async function $do31(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/materialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_bundlesDeleteBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/bundlesDeleteBundles.ts
var args25, tool$bundlesDeleteBundles;
var init_bundlesDeleteBundles2 = __esm(() => {
  init_bundlesDeleteBundles();
  init_operations();
  init_tools();
  args25 = {
    request: DeleteBundlesRequest$inboundSchema
  };
  tool$bundlesDeleteBundles = {
    name: "bundles-delete-bundles",
    description: `Delete a Bundle


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args25,
    tool: async (client, args26, ctx) => {
      const [result2, apiCall] = await bundlesDeleteBundles(client, args26.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/bundlesGetBundles.ts
function bundlesGetBundles(client, request, options) {
  return new APIPromise($do32(client, request, options));
}
async function $do32(client, request, options) {
  const parsed = safeParse(request, (value) => GetBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/materialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_bundlesGetBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/bundlesGetBundles.ts
var args26, tool$bundlesGetBundles;
var init_bundlesGetBundles2 = __esm(() => {
  init_bundlesGetBundles();
  init_operations();
  init_tools();
  args26 = {
    request: GetBundlesRequest$inboundSchema
  };
  tool$bundlesGetBundles = {
    name: "bundles-get-bundles",
    description: `Retrieve a Bundle`,
    args: args26,
    tool: async (client, args27, ctx) => {
      const [result2, apiCall] = await bundlesGetBundles(client, args27.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/bundlesListBundles.ts
function bundlesListBundles(client, options) {
  return new APIPromise($do33(client, options));
}
async function $do33(client, options) {
  const path = pathToFunc("/materialbundle.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_bundlesListBundles = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/bundlesListBundles.ts
var tool$bundlesListBundles;
var init_bundlesListBundles2 = __esm(() => {
  init_bundlesListBundles();
  init_tools();
  tool$bundlesListBundles = {
    name: "bundles-list-bundles",
    description: `List all Bundles


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await bundlesListBundles(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/bundlesUpdateBundles.ts
function bundlesUpdateBundles(client, request, options) {
  return new APIPromise($do34(client, request, options));
}
async function $do34(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MaterialBundle, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/materialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_bundlesUpdateBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/bundlesUpdateBundles.ts
var args27, tool$bundlesUpdateBundles;
var init_bundlesUpdateBundles2 = __esm(() => {
  init_bundlesUpdateBundles();
  init_operations();
  init_tools();
  args27 = {
    request: UpdateBundlesRequest$inboundSchema
  };
  tool$bundlesUpdateBundles = {
    name: "bundles-update-bundles",
    description: `Update a Bundle`,
    args: args27,
    tool: async (client, args28, ctx) => {
      const [result2, apiCall] = await bundlesUpdateBundles(client, args28.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/categoriesCreateCategories.ts
function categoriesCreateCategories(client, request, options) {
  return new APIPromise($do35(client, request, options));
}
async function $do35(client, request, options) {
  const parsed = safeParse(request, (value) => CategoryInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/category.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createCategories",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateCategoriesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateCategoriesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_categoriesCreateCategories = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/categoriesCreateCategories.ts
var args28, tool$categoriesCreateCategories;
var init_categoriesCreateCategories2 = __esm(() => {
  init_categoriesCreateCategories();
  init_components();
  init_tools();
  args28 = {
    request: CategoryInput$inboundSchema
  };
  tool$categoriesCreateCategories = {
    name: "categories-create-categories",
    description: `Create a new Category


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_categories**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args28,
    tool: async (client, args29, ctx) => {
      const [result2, apiCall] = await categoriesCreateCategories(client, args29.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/categoriesDeleteCategories.ts
function categoriesDeleteCategories(client, request, options) {
  return new APIPromise($do36(client, request, options));
}
async function $do36(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteCategoriesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/category/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteCategories",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteCategoriesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteCategoriesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_categoriesDeleteCategories = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/categoriesDeleteCategories.ts
var args29, tool$categoriesDeleteCategories;
var init_categoriesDeleteCategories2 = __esm(() => {
  init_categoriesDeleteCategories();
  init_operations();
  init_tools();
  args29 = {
    request: DeleteCategoriesRequest$inboundSchema
  };
  tool$categoriesDeleteCategories = {
    name: "categories-delete-categories",
    description: `Delete a Category


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_categories**.

			`,
    args: args29,
    tool: async (client, args30, ctx) => {
      const [result2, apiCall] = await categoriesDeleteCategories(client, args30.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/categoriesGetCategories.ts
function categoriesGetCategories(client, request, options) {
  return new APIPromise($do37(client, request, options));
}
async function $do37(client, request, options) {
  const parsed = safeParse(request, (value) => GetCategoriesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/category/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getCategories",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetCategoriesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetCategoriesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_categoriesGetCategories = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/categoriesGetCategories.ts
var args30, tool$categoriesGetCategories;
var init_categoriesGetCategories2 = __esm(() => {
  init_categoriesGetCategories();
  init_operations();
  init_tools();
  args30 = {
    request: GetCategoriesRequest$inboundSchema
  };
  tool$categoriesGetCategories = {
    name: "categories-get-categories",
    description: `Retrieve a Category


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_categories**.

			`,
    args: args30,
    tool: async (client, args31, ctx) => {
      const [result2, apiCall] = await categoriesGetCategories(client, args31.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/categoriesListCategories.ts
function categoriesListCategories(client, options) {
  return new APIPromise($do38(client, options));
}
async function $do38(client, options) {
  const path = pathToFunc("/category.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listCategories",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListCategoriesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListCategoriesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_categoriesListCategories = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/categoriesListCategories.ts
var tool$categoriesListCategories;
var init_categoriesListCategories2 = __esm(() => {
  init_categoriesListCategories();
  init_tools();
  tool$categoriesListCategories = {
    name: "categories-list-categories",
    description: `List all Categories


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_categories**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await categoriesListCategories(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/categoriesUpdateCategories.ts
function categoriesUpdateCategories(client, request, options) {
  return new APIPromise($do39(client, request, options));
}
async function $do39(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateCategoriesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Category, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/category/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateCategories",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateCategoriesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateCategoriesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_categoriesUpdateCategories = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/categoriesUpdateCategories.ts
var args31, tool$categoriesUpdateCategories;
var init_categoriesUpdateCategories2 = __esm(() => {
  init_categoriesUpdateCategories();
  init_operations();
  init_tools();
  args31 = {
    request: UpdateCategoriesRequest$inboundSchema
  };
  tool$categoriesUpdateCategories = {
    name: "categories-update-categories",
    description: `Update a Category


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_categories**.

			`,
    args: args31,
    tool: async (client, args32, ctx) => {
      const [result2, apiCall] = await categoriesUpdateCategories(client, args32.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/clientsCreateClients.ts
function clientsCreateClients(client, request, options) {
  return new APIPromise($do40(client, request, options));
}
async function $do40(client, request, options) {
  const parsed = safeParse(request, (value) => CompanyInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/company.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createClients",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateClientsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateClientsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_clientsCreateClients = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/clientsCreateClients.ts
var args32, tool$clientsCreateClients;
var init_clientsCreateClients2 = __esm(() => {
  init_clientsCreateClients();
  init_components();
  init_tools();
  args32 = {
    request: CompanyInput$inboundSchema
  };
  tool$clientsCreateClients = {
    name: "clients-create-clients",
    description: `Create a new Client


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customers**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args32,
    tool: async (client, args33, ctx) => {
      const [result2, apiCall] = await clientsCreateClients(client, args33.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/clientsDeleteClients.ts
function clientsDeleteClients(client, request, options) {
  return new APIPromise($do41(client, request, options));
}
async function $do41(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteClientsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/company/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteClients",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteClientsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteClientsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_clientsDeleteClients = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/clientsDeleteClients.ts
var args33, tool$clientsDeleteClients;
var init_clientsDeleteClients2 = __esm(() => {
  init_clientsDeleteClients();
  init_operations();
  init_tools();
  args33 = {
    request: DeleteClientsRequest$inboundSchema
  };
  tool$clientsDeleteClients = {
    name: "clients-delete-clients",
    description: `Delete a Client


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customers**.

			`,
    args: args33,
    tool: async (client, args34, ctx) => {
      const [result2, apiCall] = await clientsDeleteClients(client, args34.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/clientsGetClients.ts
function clientsGetClients(client, request, options) {
  return new APIPromise($do42(client, request, options));
}
async function $do42(client, request, options) {
  const parsed = safeParse(request, (value) => GetClientsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/company/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getClients",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetClientsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetClientsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_clientsGetClients = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/clientsGetClients.ts
var args34, tool$clientsGetClients;
var init_clientsGetClients2 = __esm(() => {
  init_clientsGetClients();
  init_operations();
  init_tools();
  args34 = {
    request: GetClientsRequest$inboundSchema
  };
  tool$clientsGetClients = {
    name: "clients-get-clients",
    description: `Retrieve a Client


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_customers**.

			`,
    args: args34,
    tool: async (client, args35, ctx) => {
      const [result2, apiCall] = await clientsGetClients(client, args35.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/clientsListClients.ts
function clientsListClients(client, options) {
  return new APIPromise($do43(client, options));
}
async function $do43(client, options) {
  const path = pathToFunc("/company.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listClients",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListClientsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListClientsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_clientsListClients = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/clientsListClients.ts
var tool$clientsListClients;
var init_clientsListClients2 = __esm(() => {
  init_clientsListClients();
  init_tools();
  tool$clientsListClients = {
    name: "clients-list-clients",
    description: `List all Clients


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_customers**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await clientsListClients(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/clientsUpdateClients.ts
function clientsUpdateClients(client, request, options) {
  return new APIPromise($do44(client, request, options));
}
async function $do44(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateClientsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Company, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/company/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateClients",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateClientsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateClientsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_clientsUpdateClients = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/clientsUpdateClients.ts
var args35, tool$clientsUpdateClients;
var init_clientsUpdateClients2 = __esm(() => {
  init_clientsUpdateClients();
  init_operations();
  init_tools();
  args35 = {
    request: UpdateClientsRequest$inboundSchema
  };
  tool$clientsUpdateClients = {
    name: "clients-update-clients",
    description: `Update a Client


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customers**.

			`,
    args: args35,
    tool: async (client, args36, ctx) => {
      const [result2, apiCall] = await clientsUpdateClients(client, args36.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/companyContactsCreateCompanyContacts.ts
function companyContactsCreateCompanyContacts(client, request, options) {
  return new APIPromise($do45(client, request, options));
}
async function $do45(client, request, options) {
  const parsed = safeParse(request, (value) => CompanyContactInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/companycontact.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createCompanyContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateCompanyContactsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateCompanyContactsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_companyContactsCreateCompanyContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/companyContactsCreateCompanyContacts.ts
var args36, tool$companyContactsCreateCompanyContacts;
var init_companyContactsCreateCompanyContacts2 = __esm(() => {
  init_companyContactsCreateCompanyContacts();
  init_components();
  init_tools();
  args36 = {
    request: CompanyContactInput$inboundSchema
  };
  tool$companyContactsCreateCompanyContacts = {
    name: "company-contacts-create-company-contacts",
    description: `Create a new Company Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customer_contacts**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args36,
    tool: async (client, args37, ctx) => {
      const [result2, apiCall] = await companyContactsCreateCompanyContacts(client, args37.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/companyContactsDeleteCompanyContacts.ts
function companyContactsDeleteCompanyContacts(client, request, options) {
  return new APIPromise($do46(client, request, options));
}
async function $do46(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteCompanyContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/companycontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteCompanyContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteCompanyContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteCompanyContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_companyContactsDeleteCompanyContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/companyContactsDeleteCompanyContacts.ts
var args37, tool$companyContactsDeleteCompanyContacts;
var init_companyContactsDeleteCompanyContacts2 = __esm(() => {
  init_companyContactsDeleteCompanyContacts();
  init_operations();
  init_tools();
  args37 = {
    request: DeleteCompanyContactsRequest$inboundSchema
  };
  tool$companyContactsDeleteCompanyContacts = {
    name: "company-contacts-delete-company-contacts",
    description: `Delete a Company Contact


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customer_contacts**.

			`,
    args: args37,
    tool: async (client, args38, ctx) => {
      const [result2, apiCall] = await companyContactsDeleteCompanyContacts(client, args38.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/companyContactsGetCompanyContacts.ts
function companyContactsGetCompanyContacts(client, request, options) {
  return new APIPromise($do47(client, request, options));
}
async function $do47(client, request, options) {
  const parsed = safeParse(request, (value) => GetCompanyContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/companycontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getCompanyContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetCompanyContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetCompanyContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_companyContactsGetCompanyContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/companyContactsGetCompanyContacts.ts
var args38, tool$companyContactsGetCompanyContacts;
var init_companyContactsGetCompanyContacts2 = __esm(() => {
  init_companyContactsGetCompanyContacts();
  init_operations();
  init_tools();
  args38 = {
    request: GetCompanyContactsRequest$inboundSchema
  };
  tool$companyContactsGetCompanyContacts = {
    name: "company-contacts-get-company-contacts",
    description: `Retrieve a Company Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_customer_contacts**.

			`,
    args: args38,
    tool: async (client, args39, ctx) => {
      const [result2, apiCall] = await companyContactsGetCompanyContacts(client, args39.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/companyContactsListCompanyContacts.ts
function companyContactsListCompanyContacts(client, options) {
  return new APIPromise($do48(client, options));
}
async function $do48(client, options) {
  const path = pathToFunc("/companycontact.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listCompanyContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListCompanyContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListCompanyContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_companyContactsListCompanyContacts = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/companyContactsListCompanyContacts.ts
var tool$companyContactsListCompanyContacts;
var init_companyContactsListCompanyContacts2 = __esm(() => {
  init_companyContactsListCompanyContacts();
  init_tools();
  tool$companyContactsListCompanyContacts = {
    name: "company-contacts-list-company-contacts",
    description: `List all Company Contacts


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_customer_contacts**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await companyContactsListCompanyContacts(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/companyContactsUpdateCompanyContacts.ts
function companyContactsUpdateCompanyContacts(client, request, options) {
  return new APIPromise($do49(client, request, options));
}
async function $do49(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateCompanyContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CompanyContact, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/companycontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateCompanyContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateCompanyContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateCompanyContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_companyContactsUpdateCompanyContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/companyContactsUpdateCompanyContacts.ts
var args39, tool$companyContactsUpdateCompanyContacts;
var init_companyContactsUpdateCompanyContacts2 = __esm(() => {
  init_companyContactsUpdateCompanyContacts();
  init_operations();
  init_tools();
  args39 = {
    request: UpdateCompanyContactsRequest$inboundSchema
  };
  tool$companyContactsUpdateCompanyContacts = {
    name: "company-contacts-update-company-contacts",
    description: `Update a Company Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_customer_contacts**.

			`,
    args: args39,
    tool: async (client, args40, ctx) => {
      const [result2, apiCall] = await companyContactsUpdateCompanyContacts(client, args40.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/emailTemplatesCreateEmailTemplates.ts
function emailTemplatesCreateEmailTemplates(client, request, options) {
  return new APIPromise($do50(client, request, options));
}
async function $do50(client, request, options) {
  const parsed = safeParse(request, (value) => EmailTemplateInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/emailtemplate.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createEmailTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateEmailTemplatesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateEmailTemplatesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_emailTemplatesCreateEmailTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/emailTemplatesCreateEmailTemplates.ts
var args40, tool$emailTemplatesCreateEmailTemplates;
var init_emailTemplatesCreateEmailTemplates2 = __esm(() => {
  init_emailTemplatesCreateEmailTemplates();
  init_components();
  init_tools();
  args40 = {
    request: EmailTemplateInput$inboundSchema
  };
  tool$emailTemplatesCreateEmailTemplates = {
    name: "email-templates-create-email-templates",
    description: `Create a new Email Template


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args40,
    tool: async (client, args41, ctx) => {
      const [result2, apiCall] = await emailTemplatesCreateEmailTemplates(client, args41.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/emailTemplatesDeleteEmailTemplates.ts
function emailTemplatesDeleteEmailTemplates(client, request, options) {
  return new APIPromise($do51(client, request, options));
}
async function $do51(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteEmailTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/emailtemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteEmailTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteEmailTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteEmailTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_emailTemplatesDeleteEmailTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/emailTemplatesDeleteEmailTemplates.ts
var args41, tool$emailTemplatesDeleteEmailTemplates;
var init_emailTemplatesDeleteEmailTemplates2 = __esm(() => {
  init_emailTemplatesDeleteEmailTemplates();
  init_operations();
  init_tools();
  args41 = {
    request: DeleteEmailTemplatesRequest$inboundSchema
  };
  tool$emailTemplatesDeleteEmailTemplates = {
    name: "email-templates-delete-email-templates",
    description: `Delete an Email Template


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args41,
    tool: async (client, args42, ctx) => {
      const [result2, apiCall] = await emailTemplatesDeleteEmailTemplates(client, args42.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/emailTemplatesGetEmailTemplates.ts
function emailTemplatesGetEmailTemplates(client, request, options) {
  return new APIPromise($do52(client, request, options));
}
async function $do52(client, request, options) {
  const parsed = safeParse(request, (value) => GetEmailTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/emailtemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getEmailTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetEmailTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetEmailTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_emailTemplatesGetEmailTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/emailTemplatesGetEmailTemplates.ts
var args42, tool$emailTemplatesGetEmailTemplates;
var init_emailTemplatesGetEmailTemplates2 = __esm(() => {
  init_emailTemplatesGetEmailTemplates();
  init_operations();
  init_tools();
  args42 = {
    request: GetEmailTemplatesRequest$inboundSchema
  };
  tool$emailTemplatesGetEmailTemplates = {
    name: "email-templates-get-email-templates",
    description: `Retrieve an Email Template`,
    args: args42,
    tool: async (client, args43, ctx) => {
      const [result2, apiCall] = await emailTemplatesGetEmailTemplates(client, args43.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/emailTemplatesListEmailTemplates.ts
function emailTemplatesListEmailTemplates(client, options) {
  return new APIPromise($do53(client, options));
}
async function $do53(client, options) {
  const path = pathToFunc("/emailtemplate.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listEmailTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListEmailTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListEmailTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_emailTemplatesListEmailTemplates = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/emailTemplatesListEmailTemplates.ts
var tool$emailTemplatesListEmailTemplates;
var init_emailTemplatesListEmailTemplates2 = __esm(() => {
  init_emailTemplatesListEmailTemplates();
  init_tools();
  tool$emailTemplatesListEmailTemplates = {
    name: "email-templates-list-email-templates",
    description: `List all Email Templates


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await emailTemplatesListEmailTemplates(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/emailTemplatesUpdateEmailTemplates.ts
function emailTemplatesUpdateEmailTemplates(client, request, options) {
  return new APIPromise($do54(client, request, options));
}
async function $do54(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateEmailTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.EmailTemplate, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/emailtemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateEmailTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateEmailTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateEmailTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_emailTemplatesUpdateEmailTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/emailTemplatesUpdateEmailTemplates.ts
var args43, tool$emailTemplatesUpdateEmailTemplates;
var init_emailTemplatesUpdateEmailTemplates2 = __esm(() => {
  init_emailTemplatesUpdateEmailTemplates();
  init_operations();
  init_tools();
  args43 = {
    request: UpdateEmailTemplatesRequest$inboundSchema
  };
  tool$emailTemplatesUpdateEmailTemplates = {
    name: "email-templates-update-email-templates",
    description: `Update an Email Template`,
    args: args43,
    tool: async (client, args44, ctx) => {
      const [result2, apiCall] = await emailTemplatesUpdateEmailTemplates(client, args44.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/feedbackCreateFeedback.ts
function feedbackCreateFeedback(client, request, options) {
  return new APIPromise($do55(client, request, options));
}
async function $do55(client, request, options) {
  const parsed = safeParse(request, (value) => FeedbackInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/feedback.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createFeedback",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateFeedbackResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateFeedbackResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_feedbackCreateFeedback = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/feedbackCreateFeedback.ts
var args44, tool$feedbackCreateFeedback;
var init_feedbackCreateFeedback2 = __esm(() => {
  init_feedbackCreateFeedback();
  init_components();
  init_tools();
  args44 = {
    request: FeedbackInput$inboundSchema
  };
  tool$feedbackCreateFeedback = {
    name: "feedback-create-feedback",
    description: `Create a new Feedback


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args44,
    tool: async (client, args45, ctx) => {
      const [result2, apiCall] = await feedbackCreateFeedback(client, args45.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/feedbackDeleteFeedback.ts
function feedbackDeleteFeedback(client, request, options) {
  return new APIPromise($do56(client, request, options));
}
async function $do56(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteFeedbackRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/feedback/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteFeedback",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteFeedbackResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteFeedbackResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_feedbackDeleteFeedback = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/feedbackDeleteFeedback.ts
var args45, tool$feedbackDeleteFeedback;
var init_feedbackDeleteFeedback2 = __esm(() => {
  init_feedbackDeleteFeedback();
  init_operations();
  init_tools();
  args45 = {
    request: DeleteFeedbackRequest$inboundSchema
  };
  tool$feedbackDeleteFeedback = {
    name: "feedback-delete-feedback",
    description: `Delete a Feedback


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args45,
    tool: async (client, args46, ctx) => {
      const [result2, apiCall] = await feedbackDeleteFeedback(client, args46.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/feedbackGetFeedback.ts
function feedbackGetFeedback(client, request, options) {
  return new APIPromise($do57(client, request, options));
}
async function $do57(client, request, options) {
  const parsed = safeParse(request, (value) => GetFeedbackRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/feedback/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getFeedback",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetFeedbackResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetFeedbackResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_feedbackGetFeedback = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/feedbackGetFeedback.ts
var args46, tool$feedbackGetFeedback;
var init_feedbackGetFeedback2 = __esm(() => {
  init_feedbackGetFeedback();
  init_operations();
  init_tools();
  args46 = {
    request: GetFeedbackRequest$inboundSchema
  };
  tool$feedbackGetFeedback = {
    name: "feedback-get-feedback",
    description: `Retrieve a Feedback`,
    args: args46,
    tool: async (client, args47, ctx) => {
      const [result2, apiCall] = await feedbackGetFeedback(client, args47.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/feedbackListFeedback.ts
function feedbackListFeedback(client, options) {
  return new APIPromise($do58(client, options));
}
async function $do58(client, options) {
  const path = pathToFunc("/feedback.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listFeedback",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListFeedbackResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListFeedbackResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_feedbackListFeedback = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/feedbackListFeedback.ts
var tool$feedbackListFeedback;
var init_feedbackListFeedback2 = __esm(() => {
  init_feedbackListFeedback();
  init_tools();
  tool$feedbackListFeedback = {
    name: "feedback-list-feedback",
    description: `List all Feedback


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await feedbackListFeedback(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/feedbackUpdateFeedback.ts
function feedbackUpdateFeedback(client, request, options) {
  return new APIPromise($do59(client, request, options));
}
async function $do59(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateFeedbackRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Feedback, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/feedback/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateFeedback",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateFeedbackResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateFeedbackResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_feedbackUpdateFeedback = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/feedbackUpdateFeedback.ts
var args47, tool$feedbackUpdateFeedback;
var init_feedbackUpdateFeedback2 = __esm(() => {
  init_feedbackUpdateFeedback();
  init_operations();
  init_tools();
  args47 = {
    request: UpdateFeedbackRequest$inboundSchema
  };
  tool$feedbackUpdateFeedback = {
    name: "feedback-update-feedback",
    description: `Update a Feedback`,
    args: args47,
    tool: async (client, args48, ctx) => {
      const [result2, apiCall] = await feedbackUpdateFeedback(client, args48.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formFieldsCreateFormFields.ts
function formFieldsCreateFormFields(client, request, options) {
  return new APIPromise($do60(client, request, options));
}
async function $do60(client, request, options) {
  const parsed = safeParse(request, (value) => FormFieldInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/formfield.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createFormFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateFormFieldsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateFormFieldsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formFieldsCreateFormFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formFieldsCreateFormFields.ts
var args48, tool$formFieldsCreateFormFields;
var init_formFieldsCreateFormFields2 = __esm(() => {
  init_formFieldsCreateFormFields();
  init_components();
  init_tools();
  args48 = {
    request: FormFieldInput$inboundSchema
  };
  tool$formFieldsCreateFormFields = {
    name: "form-fields-create-form-fields",
    description: `Create a new Form Field


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args48,
    tool: async (client, args49, ctx) => {
      const [result2, apiCall] = await formFieldsCreateFormFields(client, args49.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formFieldsDeleteFormFields.ts
function formFieldsDeleteFormFields(client, request, options) {
  return new APIPromise($do61(client, request, options));
}
async function $do61(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteFormFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formfield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteFormFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteFormFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteFormFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formFieldsDeleteFormFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formFieldsDeleteFormFields.ts
var args49, tool$formFieldsDeleteFormFields;
var init_formFieldsDeleteFormFields2 = __esm(() => {
  init_formFieldsDeleteFormFields();
  init_operations();
  init_tools();
  args49 = {
    request: DeleteFormFieldsRequest$inboundSchema
  };
  tool$formFieldsDeleteFormFields = {
    name: "form-fields-delete-form-fields",
    description: `Delete a Form Field


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args49,
    tool: async (client, args50, ctx) => {
      const [result2, apiCall] = await formFieldsDeleteFormFields(client, args50.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formFieldsGetFormFields.ts
function formFieldsGetFormFields(client, request, options) {
  return new APIPromise($do62(client, request, options));
}
async function $do62(client, request, options) {
  const parsed = safeParse(request, (value) => GetFormFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formfield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getFormFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetFormFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetFormFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formFieldsGetFormFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formFieldsGetFormFields.ts
var args50, tool$formFieldsGetFormFields;
var init_formFieldsGetFormFields2 = __esm(() => {
  init_formFieldsGetFormFields();
  init_operations();
  init_tools();
  args50 = {
    request: GetFormFieldsRequest$inboundSchema
  };
  tool$formFieldsGetFormFields = {
    name: "form-fields-get-form-fields",
    description: `Retrieve a Form Field`,
    args: args50,
    tool: async (client, args51, ctx) => {
      const [result2, apiCall] = await formFieldsGetFormFields(client, args51.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formFieldsListFormFields.ts
function formFieldsListFormFields(client, options) {
  return new APIPromise($do63(client, options));
}
async function $do63(client, options) {
  const path = pathToFunc("/formfield.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listFormFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListFormFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListFormFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formFieldsListFormFields = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formFieldsListFormFields.ts
var tool$formFieldsListFormFields;
var init_formFieldsListFormFields2 = __esm(() => {
  init_formFieldsListFormFields();
  init_tools();
  tool$formFieldsListFormFields = {
    name: "form-fields-list-form-fields",
    description: `List all Form Fields


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await formFieldsListFormFields(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formFieldsUpdateFormFields.ts
function formFieldsUpdateFormFields(client, request, options) {
  return new APIPromise($do64(client, request, options));
}
async function $do64(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateFormFieldsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.FormField, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formfield/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateFormFields",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateFormFieldsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateFormFieldsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formFieldsUpdateFormFields = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formFieldsUpdateFormFields.ts
var args51, tool$formFieldsUpdateFormFields;
var init_formFieldsUpdateFormFields2 = __esm(() => {
  init_formFieldsUpdateFormFields();
  init_operations();
  init_tools();
  args51 = {
    request: UpdateFormFieldsRequest$inboundSchema
  };
  tool$formFieldsUpdateFormFields = {
    name: "form-fields-update-form-fields",
    description: `Update a Form Field`,
    args: args51,
    tool: async (client, args52, ctx) => {
      const [result2, apiCall] = await formFieldsUpdateFormFields(client, args52.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formResponsesCreateFormResponses.ts
function formResponsesCreateFormResponses(client, request, options) {
  return new APIPromise($do65(client, request, options));
}
async function $do65(client, request, options) {
  const parsed = safeParse(request, (value) => FormResponseInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/formresponse.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createFormResponses",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateFormResponsesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateFormResponsesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formResponsesCreateFormResponses = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formResponsesCreateFormResponses.ts
var args52, tool$formResponsesCreateFormResponses;
var init_formResponsesCreateFormResponses2 = __esm(() => {
  init_formResponsesCreateFormResponses();
  init_components();
  init_tools();
  args52 = {
    request: FormResponseInput$inboundSchema
  };
  tool$formResponsesCreateFormResponses = {
    name: "form-responses-create-form-responses",
    description: `Create a new Form Response


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args52,
    tool: async (client, args53, ctx) => {
      const [result2, apiCall] = await formResponsesCreateFormResponses(client, args53.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formResponsesDeleteFormResponses.ts
function formResponsesDeleteFormResponses(client, request, options) {
  return new APIPromise($do66(client, request, options));
}
async function $do66(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteFormResponsesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formresponse/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteFormResponses",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteFormResponsesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteFormResponsesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formResponsesDeleteFormResponses = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formResponsesDeleteFormResponses.ts
var args53, tool$formResponsesDeleteFormResponses;
var init_formResponsesDeleteFormResponses2 = __esm(() => {
  init_formResponsesDeleteFormResponses();
  init_operations();
  init_tools();
  args53 = {
    request: DeleteFormResponsesRequest$inboundSchema
  };
  tool$formResponsesDeleteFormResponses = {
    name: "form-responses-delete-form-responses",
    description: `Delete a Form Response


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args53,
    tool: async (client, args54, ctx) => {
      const [result2, apiCall] = await formResponsesDeleteFormResponses(client, args54.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formResponsesGetFormResponses.ts
function formResponsesGetFormResponses(client, request, options) {
  return new APIPromise($do67(client, request, options));
}
async function $do67(client, request, options) {
  const parsed = safeParse(request, (value) => GetFormResponsesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formresponse/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getFormResponses",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetFormResponsesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetFormResponsesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formResponsesGetFormResponses = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formResponsesGetFormResponses.ts
var args54, tool$formResponsesGetFormResponses;
var init_formResponsesGetFormResponses2 = __esm(() => {
  init_formResponsesGetFormResponses();
  init_operations();
  init_tools();
  args54 = {
    request: GetFormResponsesRequest$inboundSchema
  };
  tool$formResponsesGetFormResponses = {
    name: "form-responses-get-form-responses",
    description: `Retrieve a Form Response`,
    args: args54,
    tool: async (client, args55, ctx) => {
      const [result2, apiCall] = await formResponsesGetFormResponses(client, args55.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formResponsesListFormResponses.ts
function formResponsesListFormResponses(client, options) {
  return new APIPromise($do68(client, options));
}
async function $do68(client, options) {
  const path = pathToFunc("/formresponse.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listFormResponses",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListFormResponsesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListFormResponsesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formResponsesListFormResponses = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formResponsesListFormResponses.ts
var tool$formResponsesListFormResponses;
var init_formResponsesListFormResponses2 = __esm(() => {
  init_formResponsesListFormResponses();
  init_tools();
  tool$formResponsesListFormResponses = {
    name: "form-responses-list-form-responses",
    description: `List all Form Responses


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await formResponsesListFormResponses(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formResponsesUpdateFormResponses.ts
function formResponsesUpdateFormResponses(client, request, options) {
  return new APIPromise($do69(client, request, options));
}
async function $do69(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateFormResponsesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.FormResponse, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/formresponse/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateFormResponses",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateFormResponsesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateFormResponsesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formResponsesUpdateFormResponses = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formResponsesUpdateFormResponses.ts
var args55, tool$formResponsesUpdateFormResponses;
var init_formResponsesUpdateFormResponses2 = __esm(() => {
  init_formResponsesUpdateFormResponses();
  init_operations();
  init_tools();
  args55 = {
    request: UpdateFormResponsesRequest$inboundSchema
  };
  tool$formResponsesUpdateFormResponses = {
    name: "form-responses-update-form-responses",
    description: `Update a Form Response`,
    args: args55,
    tool: async (client, args56, ctx) => {
      const [result2, apiCall] = await formResponsesUpdateFormResponses(client, args56.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formsCreateForms.ts
function formsCreateForms(client, request, options) {
  return new APIPromise($do70(client, request, options));
}
async function $do70(client, request, options) {
  const parsed = safeParse(request, (value) => FormInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/form.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createForms",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateFormsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateFormsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formsCreateForms = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formsCreateForms.ts
var args56, tool$formsCreateForms;
var init_formsCreateForms2 = __esm(() => {
  init_formsCreateForms();
  init_components();
  init_tools();
  args56 = {
    request: FormInput$inboundSchema
  };
  tool$formsCreateForms = {
    name: "forms-create-forms",
    description: `Create a new Form


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args56,
    tool: async (client, args57, ctx) => {
      const [result2, apiCall] = await formsCreateForms(client, args57.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formsDeleteForms.ts
function formsDeleteForms(client, request, options) {
  return new APIPromise($do71(client, request, options));
}
async function $do71(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteFormsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/form/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteForms",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteFormsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteFormsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formsDeleteForms = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formsDeleteForms.ts
var args57, tool$formsDeleteForms;
var init_formsDeleteForms2 = __esm(() => {
  init_formsDeleteForms();
  init_operations();
  init_tools();
  args57 = {
    request: DeleteFormsRequest$inboundSchema
  };
  tool$formsDeleteForms = {
    name: "forms-delete-forms",
    description: `Delete a Form


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args57,
    tool: async (client, args58, ctx) => {
      const [result2, apiCall] = await formsDeleteForms(client, args58.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formsGetForms.ts
function formsGetForms(client, request, options) {
  return new APIPromise($do72(client, request, options));
}
async function $do72(client, request, options) {
  const parsed = safeParse(request, (value) => GetFormsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/form/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getForms",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetFormsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetFormsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formsGetForms = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formsGetForms.ts
var args58, tool$formsGetForms;
var init_formsGetForms2 = __esm(() => {
  init_formsGetForms();
  init_operations();
  init_tools();
  args58 = {
    request: GetFormsRequest$inboundSchema
  };
  tool$formsGetForms = {
    name: "forms-get-forms",
    description: `Retrieve a Form`,
    args: args58,
    tool: async (client, args59, ctx) => {
      const [result2, apiCall] = await formsGetForms(client, args59.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formsListForms.ts
function formsListForms(client, options) {
  return new APIPromise($do73(client, options));
}
async function $do73(client, options) {
  const path = pathToFunc("/form.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listForms",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListFormsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListFormsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formsListForms = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formsListForms.ts
var tool$formsListForms;
var init_formsListForms2 = __esm(() => {
  init_formsListForms();
  init_tools();
  tool$formsListForms = {
    name: "forms-list-forms",
    description: `List all Forms


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await formsListForms(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/formsUpdateForms.ts
function formsUpdateForms(client, request, options) {
  return new APIPromise($do74(client, request, options));
}
async function $do74(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateFormsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Form, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/form/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateForms",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateFormsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateFormsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_formsUpdateForms = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/formsUpdateForms.ts
var args59, tool$formsUpdateForms;
var init_formsUpdateForms2 = __esm(() => {
  init_formsUpdateForms();
  init_operations();
  init_tools();
  args59 = {
    request: UpdateFormsRequest$inboundSchema
  };
  tool$formsUpdateForms = {
    name: "forms-update-forms",
    description: `Update a Form`,
    args: args59,
    tool: async (client, args60, ctx) => {
      const [result2, apiCall] = await formsUpdateForms(client, args60.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobActivitiesCreateJobActivities.ts
function jobActivitiesCreateJobActivities(client, request, options) {
  return new APIPromise($do75(client, request, options));
}
async function $do75(client, request, options) {
  const parsed = safeParse(request, (value) => JobActivityInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobactivity.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobActivities",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobActivitiesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobActivitiesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobActivitiesCreateJobActivities = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobActivitiesCreateJobActivities.ts
var args60, tool$jobActivitiesCreateJobActivities;
var init_jobActivitiesCreateJobActivities2 = __esm(() => {
  init_jobActivitiesCreateJobActivities();
  init_components();
  init_tools();
  args60 = {
    request: JobActivityInput$inboundSchema
  };
  tool$jobActivitiesCreateJobActivities = {
    name: "job-activities-create-job-activities",
    description: `Create a new Job Activity


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_schedule**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args60,
    tool: async (client, args61, ctx) => {
      const [result2, apiCall] = await jobActivitiesCreateJobActivities(client, args61.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobActivitiesDeleteJobActivities.ts
function jobActivitiesDeleteJobActivities(client, request, options) {
  return new APIPromise($do76(client, request, options));
}
async function $do76(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobActivitiesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobactivity/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobActivities",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobActivitiesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobActivitiesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobActivitiesDeleteJobActivities = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobActivitiesDeleteJobActivities.ts
var args61, tool$jobActivitiesDeleteJobActivities;
var init_jobActivitiesDeleteJobActivities2 = __esm(() => {
  init_jobActivitiesDeleteJobActivities();
  init_operations();
  init_tools();
  args61 = {
    request: DeleteJobActivitiesRequest$inboundSchema
  };
  tool$jobActivitiesDeleteJobActivities = {
    name: "job-activities-delete-job-activities",
    description: `Delete a Job Activity


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_schedule**.

			`,
    args: args61,
    tool: async (client, args62, ctx) => {
      const [result2, apiCall] = await jobActivitiesDeleteJobActivities(client, args62.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobActivitiesGetJobActivities.ts
function jobActivitiesGetJobActivities(client, request, options) {
  return new APIPromise($do77(client, request, options));
}
async function $do77(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobActivitiesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobactivity/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobActivities",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobActivitiesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobActivitiesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobActivitiesGetJobActivities = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobActivitiesGetJobActivities.ts
var args62, tool$jobActivitiesGetJobActivities;
var init_jobActivitiesGetJobActivities2 = __esm(() => {
  init_jobActivitiesGetJobActivities();
  init_operations();
  init_tools();
  args62 = {
    request: GetJobActivitiesRequest$inboundSchema
  };
  tool$jobActivitiesGetJobActivities = {
    name: "job-activities-get-job-activities",
    description: `Retrieve a Job Activity


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_schedule**.

			`,
    args: args62,
    tool: async (client, args63, ctx) => {
      const [result2, apiCall] = await jobActivitiesGetJobActivities(client, args63.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobActivitiesListJobActivities.ts
function jobActivitiesListJobActivities(client, options) {
  return new APIPromise($do78(client, options));
}
async function $do78(client, options) {
  const path = pathToFunc("/jobactivity.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobActivities",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobActivitiesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobActivitiesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobActivitiesListJobActivities = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobActivitiesListJobActivities.ts
var tool$jobActivitiesListJobActivities;
var init_jobActivitiesListJobActivities2 = __esm(() => {
  init_jobActivitiesListJobActivities();
  init_tools();
  tool$jobActivitiesListJobActivities = {
    name: "job-activities-list-job-activities",
    description: `List all Job Activities


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_schedule**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobActivitiesListJobActivities(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobActivitiesUpdateJobActivities.ts
function jobActivitiesUpdateJobActivities(client, request, options) {
  return new APIPromise($do79(client, request, options));
}
async function $do79(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobActivitiesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobActivity, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobactivity/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobActivities",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobActivitiesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobActivitiesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobActivitiesUpdateJobActivities = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobActivitiesUpdateJobActivities.ts
var args63, tool$jobActivitiesUpdateJobActivities;
var init_jobActivitiesUpdateJobActivities2 = __esm(() => {
  init_jobActivitiesUpdateJobActivities();
  init_operations();
  init_tools();
  args63 = {
    request: UpdateJobActivitiesRequest$inboundSchema
  };
  tool$jobActivitiesUpdateJobActivities = {
    name: "job-activities-update-job-activities",
    description: `Update a Job Activity


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_schedule**.

			`,
    args: args63,
    tool: async (client, args64, ctx) => {
      const [result2, apiCall] = await jobActivitiesUpdateJobActivities(client, args64.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobAllocationsCreateJobAllocations.ts
function jobAllocationsCreateJobAllocations(client, request, options) {
  return new APIPromise($do80(client, request, options));
}
async function $do80(client, request, options) {
  const parsed = safeParse(request, (value) => JobAllocationInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/joballocation.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobAllocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobAllocationsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobAllocationsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobAllocationsCreateJobAllocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobAllocationsCreateJobAllocations.ts
var args64, tool$jobAllocationsCreateJobAllocations;
var init_jobAllocationsCreateJobAllocations2 = __esm(() => {
  init_jobAllocationsCreateJobAllocations();
  init_components();
  init_tools();
  args64 = {
    request: JobAllocationInput$inboundSchema
  };
  tool$jobAllocationsCreateJobAllocations = {
    name: "job-allocations-create-job-allocations",
    description: `Create a new Job Allocation


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_schedule**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args64,
    tool: async (client, args65, ctx) => {
      const [result2, apiCall] = await jobAllocationsCreateJobAllocations(client, args65.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobAllocationsDeleteJobAllocations.ts
function jobAllocationsDeleteJobAllocations(client, request, options) {
  return new APIPromise($do81(client, request, options));
}
async function $do81(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobAllocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/joballocation/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobAllocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobAllocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobAllocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobAllocationsDeleteJobAllocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobAllocationsDeleteJobAllocations.ts
var args65, tool$jobAllocationsDeleteJobAllocations;
var init_jobAllocationsDeleteJobAllocations2 = __esm(() => {
  init_jobAllocationsDeleteJobAllocations();
  init_operations();
  init_tools();
  args65 = {
    request: DeleteJobAllocationsRequest$inboundSchema
  };
  tool$jobAllocationsDeleteJobAllocations = {
    name: "job-allocations-delete-job-allocations",
    description: `Delete a Job Allocation


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args65,
    tool: async (client, args66, ctx) => {
      const [result2, apiCall] = await jobAllocationsDeleteJobAllocations(client, args66.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobAllocationsGetJobAllocations.ts
function jobAllocationsGetJobAllocations(client, request, options) {
  return new APIPromise($do82(client, request, options));
}
async function $do82(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobAllocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/joballocation/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobAllocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobAllocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobAllocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobAllocationsGetJobAllocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobAllocationsGetJobAllocations.ts
var args66, tool$jobAllocationsGetJobAllocations;
var init_jobAllocationsGetJobAllocations2 = __esm(() => {
  init_jobAllocationsGetJobAllocations();
  init_operations();
  init_tools();
  args66 = {
    request: GetJobAllocationsRequest$inboundSchema
  };
  tool$jobAllocationsGetJobAllocations = {
    name: "job-allocations-get-job-allocations",
    description: `Retrieve a Job Allocation


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_schedule**.

			`,
    args: args66,
    tool: async (client, args67, ctx) => {
      const [result2, apiCall] = await jobAllocationsGetJobAllocations(client, args67.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobAllocationsListJobAllocations.ts
function jobAllocationsListJobAllocations(client, options) {
  return new APIPromise($do83(client, options));
}
async function $do83(client, options) {
  const path = pathToFunc("/joballocation.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobAllocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobAllocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobAllocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobAllocationsListJobAllocations = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobAllocationsListJobAllocations.ts
var tool$jobAllocationsListJobAllocations;
var init_jobAllocationsListJobAllocations2 = __esm(() => {
  init_jobAllocationsListJobAllocations();
  init_tools();
  tool$jobAllocationsListJobAllocations = {
    name: "job-allocations-list-job-allocations",
    description: `List all Job Allocations


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_schedule**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobAllocationsListJobAllocations(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobAllocationsUpdateJobAllocations.ts
function jobAllocationsUpdateJobAllocations(client, request, options) {
  return new APIPromise($do84(client, request, options));
}
async function $do84(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobAllocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobAllocation, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/joballocation/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobAllocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobAllocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobAllocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobAllocationsUpdateJobAllocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobAllocationsUpdateJobAllocations.ts
var args67, tool$jobAllocationsUpdateJobAllocations;
var init_jobAllocationsUpdateJobAllocations2 = __esm(() => {
  init_jobAllocationsUpdateJobAllocations();
  init_operations();
  init_tools();
  args67 = {
    request: UpdateJobAllocationsRequest$inboundSchema
  };
  tool$jobAllocationsUpdateJobAllocations = {
    name: "job-allocations-update-job-allocations",
    description: `Update a Job Allocation`,
    args: args67,
    tool: async (client, args68, ctx) => {
      const [result2, apiCall] = await jobAllocationsUpdateJobAllocations(client, args68.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobChecklistsCreateJobChecklists.ts
function jobChecklistsCreateJobChecklists(client, request, options) {
  return new APIPromise($do85(client, request, options));
}
async function $do85(client, request, options) {
  const parsed = safeParse(request, (value) => JobChecklistInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobchecklist.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobChecklists",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobChecklistsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobChecklistsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobChecklistsCreateJobChecklists = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobChecklistsCreateJobChecklists.ts
var args68, tool$jobChecklistsCreateJobChecklists;
var init_jobChecklistsCreateJobChecklists2 = __esm(() => {
  init_jobChecklistsCreateJobChecklists();
  init_components();
  init_tools();
  args68 = {
    request: JobChecklistInput$inboundSchema
  };
  tool$jobChecklistsCreateJobChecklists = {
    name: "job-checklists-create-job-checklists",
    description: `Create a new Job Checklist


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args68,
    tool: async (client, args69, ctx) => {
      const [result2, apiCall] = await jobChecklistsCreateJobChecklists(client, args69.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobChecklistsDeleteJobChecklists.ts
function jobChecklistsDeleteJobChecklists(client, request, options) {
  return new APIPromise($do86(client, request, options));
}
async function $do86(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobChecklistsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobchecklist/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobChecklists",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobChecklistsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobChecklistsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobChecklistsDeleteJobChecklists = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobChecklistsDeleteJobChecklists.ts
var args69, tool$jobChecklistsDeleteJobChecklists;
var init_jobChecklistsDeleteJobChecklists2 = __esm(() => {
  init_jobChecklistsDeleteJobChecklists();
  init_operations();
  init_tools();
  args69 = {
    request: DeleteJobChecklistsRequest$inboundSchema
  };
  tool$jobChecklistsDeleteJobChecklists = {
    name: "job-checklists-delete-job-checklists",
    description: `Delete a Job Checklist


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args69,
    tool: async (client, args70, ctx) => {
      const [result2, apiCall] = await jobChecklistsDeleteJobChecklists(client, args70.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobChecklistsGetJobChecklists.ts
function jobChecklistsGetJobChecklists(client, request, options) {
  return new APIPromise($do87(client, request, options));
}
async function $do87(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobChecklistsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobchecklist/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobChecklists",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobChecklistsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobChecklistsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobChecklistsGetJobChecklists = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobChecklistsGetJobChecklists.ts
var args70, tool$jobChecklistsGetJobChecklists;
var init_jobChecklistsGetJobChecklists2 = __esm(() => {
  init_jobChecklistsGetJobChecklists();
  init_operations();
  init_tools();
  args70 = {
    request: GetJobChecklistsRequest$inboundSchema
  };
  tool$jobChecklistsGetJobChecklists = {
    name: "job-checklists-get-job-checklists",
    description: `Retrieve a Job Checklist`,
    args: args70,
    tool: async (client, args71, ctx) => {
      const [result2, apiCall] = await jobChecklistsGetJobChecklists(client, args71.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobChecklistsListJobChecklists.ts
function jobChecklistsListJobChecklists(client, options) {
  return new APIPromise($do88(client, options));
}
async function $do88(client, options) {
  const path = pathToFunc("/jobchecklist.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobChecklists",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobChecklistsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobChecklistsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobChecklistsListJobChecklists = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobChecklistsListJobChecklists.ts
var tool$jobChecklistsListJobChecklists;
var init_jobChecklistsListJobChecklists2 = __esm(() => {
  init_jobChecklistsListJobChecklists();
  init_tools();
  tool$jobChecklistsListJobChecklists = {
    name: "job-checklists-list-job-checklists",
    description: `List all Job Checklists


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobChecklistsListJobChecklists(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobChecklistsUpdateJobChecklists.ts
function jobChecklistsUpdateJobChecklists(client, request, options) {
  return new APIPromise($do89(client, request, options));
}
async function $do89(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobChecklistsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobChecklist, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobchecklist/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobChecklists",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobChecklistsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobChecklistsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobChecklistsUpdateJobChecklists = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobChecklistsUpdateJobChecklists.ts
var args71, tool$jobChecklistsUpdateJobChecklists;
var init_jobChecklistsUpdateJobChecklists2 = __esm(() => {
  init_jobChecklistsUpdateJobChecklists();
  init_operations();
  init_tools();
  args71 = {
    request: UpdateJobChecklistsRequest$inboundSchema
  };
  tool$jobChecklistsUpdateJobChecklists = {
    name: "job-checklists-update-job-checklists",
    description: `Update a Job Checklist`,
    args: args71,
    tool: async (client, args72, ctx) => {
      const [result2, apiCall] = await jobChecklistsUpdateJobChecklists(client, args72.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobContactsCreateJobContacts.ts
function jobContactsCreateJobContacts(client, request, options) {
  return new APIPromise($do90(client, request, options));
}
async function $do90(client, request, options) {
  const parsed = safeParse(request, (value) => JobContactInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobcontact.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobContactsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobContactsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobContactsCreateJobContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobContactsCreateJobContacts.ts
var args72, tool$jobContactsCreateJobContacts;
var init_jobContactsCreateJobContacts2 = __esm(() => {
  init_jobContactsCreateJobContacts();
  init_components();
  init_tools();
  args72 = {
    request: JobContactInput$inboundSchema
  };
  tool$jobContactsCreateJobContacts = {
    name: "job-contacts-create-job-contacts",
    description: `Create a new Job Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_contacts**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args72,
    tool: async (client, args73, ctx) => {
      const [result2, apiCall] = await jobContactsCreateJobContacts(client, args73.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobContactsDeleteJobContacts.ts
function jobContactsDeleteJobContacts(client, request, options) {
  return new APIPromise($do91(client, request, options));
}
async function $do91(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobcontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobContactsDeleteJobContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobContactsDeleteJobContacts.ts
var args73, tool$jobContactsDeleteJobContacts;
var init_jobContactsDeleteJobContacts2 = __esm(() => {
  init_jobContactsDeleteJobContacts();
  init_operations();
  init_tools();
  args73 = {
    request: DeleteJobContactsRequest$inboundSchema
  };
  tool$jobContactsDeleteJobContacts = {
    name: "job-contacts-delete-job-contacts",
    description: `Delete a Job Contact


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_contacts**.

			`,
    args: args73,
    tool: async (client, args74, ctx) => {
      const [result2, apiCall] = await jobContactsDeleteJobContacts(client, args74.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobContactsGetJobContacts.ts
function jobContactsGetJobContacts(client, request, options) {
  return new APIPromise($do92(client, request, options));
}
async function $do92(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobcontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobContactsGetJobContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobContactsGetJobContacts.ts
var args74, tool$jobContactsGetJobContacts;
var init_jobContactsGetJobContacts2 = __esm(() => {
  init_jobContactsGetJobContacts();
  init_operations();
  init_tools();
  args74 = {
    request: GetJobContactsRequest$inboundSchema
  };
  tool$jobContactsGetJobContacts = {
    name: "job-contacts-get-job-contacts",
    description: `Retrieve a Job Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_contacts**.

			`,
    args: args74,
    tool: async (client, args75, ctx) => {
      const [result2, apiCall] = await jobContactsGetJobContacts(client, args75.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobContactsListJobContacts.ts
function jobContactsListJobContacts(client, options) {
  return new APIPromise($do93(client, options));
}
async function $do93(client, options) {
  const path = pathToFunc("/jobcontact.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobContactsListJobContacts = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobContactsListJobContacts.ts
var tool$jobContactsListJobContacts;
var init_jobContactsListJobContacts2 = __esm(() => {
  init_jobContactsListJobContacts();
  init_tools();
  tool$jobContactsListJobContacts = {
    name: "job-contacts-list-job-contacts",
    description: `List all Job Contacts


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_contacts**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobContactsListJobContacts(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobContactsUpdateJobContacts.ts
function jobContactsUpdateJobContacts(client, request, options) {
  return new APIPromise($do94(client, request, options));
}
async function $do94(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobContactsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobContact, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobcontact/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobContacts",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobContactsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobContactsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobContactsUpdateJobContacts = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobContactsUpdateJobContacts.ts
var args75, tool$jobContactsUpdateJobContacts;
var init_jobContactsUpdateJobContacts2 = __esm(() => {
  init_jobContactsUpdateJobContacts();
  init_operations();
  init_tools();
  args75 = {
    request: UpdateJobContactsRequest$inboundSchema
  };
  tool$jobContactsUpdateJobContacts = {
    name: "job-contacts-update-job-contacts",
    description: `Update a Job Contact


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_contacts**.

			`,
    args: args75,
    tool: async (client, args76, ctx) => {
      const [result2, apiCall] = await jobContactsUpdateJobContacts(client, args76.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialBundlesCreateJobMaterialBundles.ts
function jobMaterialBundlesCreateJobMaterialBundles(client, request, options) {
  return new APIPromise($do95(client, request, options));
}
async function $do95(client, request, options) {
  const parsed = safeParse(request, (value) => JobMaterialBundleInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobmaterialbundle.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobMaterialBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobMaterialBundlesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobMaterialBundlesResponse$inboundSchema, { key: "Result" }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialBundlesCreateJobMaterialBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialBundlesCreateJobMaterialBundles.ts
var args76, tool$jobMaterialBundlesCreateJobMaterialBundles;
var init_jobMaterialBundlesCreateJobMaterialBundles2 = __esm(() => {
  init_jobMaterialBundlesCreateJobMaterialBundles();
  init_components();
  init_tools();
  args76 = {
    request: JobMaterialBundleInput$inboundSchema
  };
  tool$jobMaterialBundlesCreateJobMaterialBundles = {
    name: "job-material-bundles-create-job-material-bundles",
    description: `Create a new Job Material Bundle


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args76,
    tool: async (client, args77, ctx) => {
      const [result2, apiCall] = await jobMaterialBundlesCreateJobMaterialBundles(client, args77.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialBundlesDeleteJobMaterialBundles.ts
function jobMaterialBundlesDeleteJobMaterialBundles(client, request, options) {
  return new APIPromise($do96(client, request, options));
}
async function $do96(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobMaterialBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobMaterialBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobMaterialBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobMaterialBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialBundlesDeleteJobMaterialBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialBundlesDeleteJobMaterialBundles.ts
var args77, tool$jobMaterialBundlesDeleteJobMaterialBundles;
var init_jobMaterialBundlesDeleteJobMaterialBundles2 = __esm(() => {
  init_jobMaterialBundlesDeleteJobMaterialBundles();
  init_operations();
  init_tools();
  args77 = {
    request: DeleteJobMaterialBundlesRequest$inboundSchema
  };
  tool$jobMaterialBundlesDeleteJobMaterialBundles = {
    name: "job-material-bundles-delete-job-material-bundles",
    description: `Delete a Job Material Bundle


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args77,
    tool: async (client, args78, ctx) => {
      const [result2, apiCall] = await jobMaterialBundlesDeleteJobMaterialBundles(client, args78.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialBundlesGetJobMaterialBundles.ts
function jobMaterialBundlesGetJobMaterialBundles(client, request, options) {
  return new APIPromise($do97(client, request, options));
}
async function $do97(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobMaterialBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobMaterialBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobMaterialBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobMaterialBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialBundlesGetJobMaterialBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialBundlesGetJobMaterialBundles.ts
var args78, tool$jobMaterialBundlesGetJobMaterialBundles;
var init_jobMaterialBundlesGetJobMaterialBundles2 = __esm(() => {
  init_jobMaterialBundlesGetJobMaterialBundles();
  init_operations();
  init_tools();
  args78 = {
    request: GetJobMaterialBundlesRequest$inboundSchema
  };
  tool$jobMaterialBundlesGetJobMaterialBundles = {
    name: "job-material-bundles-get-job-material-bundles",
    description: `Retrieve a Job Material Bundle`,
    args: args78,
    tool: async (client, args79, ctx) => {
      const [result2, apiCall] = await jobMaterialBundlesGetJobMaterialBundles(client, args79.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialBundlesListJobMaterialBundles.ts
function jobMaterialBundlesListJobMaterialBundles(client, options) {
  return new APIPromise($do98(client, options));
}
async function $do98(client, options) {
  const path = pathToFunc("/jobmaterialbundle.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobMaterialBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobMaterialBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobMaterialBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialBundlesListJobMaterialBundles = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialBundlesListJobMaterialBundles.ts
var tool$jobMaterialBundlesListJobMaterialBundles;
var init_jobMaterialBundlesListJobMaterialBundles2 = __esm(() => {
  init_jobMaterialBundlesListJobMaterialBundles();
  init_tools();
  tool$jobMaterialBundlesListJobMaterialBundles = {
    name: "job-material-bundles-list-job-material-bundles",
    description: `List all Job Material Bundles


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobMaterialBundlesListJobMaterialBundles(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialBundlesUpdateJobMaterialBundles.ts
function jobMaterialBundlesUpdateJobMaterialBundles(client, request, options) {
  return new APIPromise($do99(client, request, options));
}
async function $do99(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobMaterialBundlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobMaterialBundle, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterialbundle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobMaterialBundles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobMaterialBundlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobMaterialBundlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialBundlesUpdateJobMaterialBundles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialBundlesUpdateJobMaterialBundles.ts
var args79, tool$jobMaterialBundlesUpdateJobMaterialBundles;
var init_jobMaterialBundlesUpdateJobMaterialBundles2 = __esm(() => {
  init_jobMaterialBundlesUpdateJobMaterialBundles();
  init_operations();
  init_tools();
  args79 = {
    request: UpdateJobMaterialBundlesRequest$inboundSchema
  };
  tool$jobMaterialBundlesUpdateJobMaterialBundles = {
    name: "job-material-bundles-update-job-material-bundles",
    description: `Update a Job Material Bundle`,
    args: args79,
    tool: async (client, args80, ctx) => {
      const [result2, apiCall] = await jobMaterialBundlesUpdateJobMaterialBundles(client, args80.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialsCreateJobMaterials.ts
function jobMaterialsCreateJobMaterials(client, request, options) {
  return new APIPromise($do100(client, request, options));
}
async function $do100(client, request, options) {
  const parsed = safeParse(request, (value) => JobMaterialInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobmaterial.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobMaterialsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobMaterialsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialsCreateJobMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialsCreateJobMaterials.ts
var args80, tool$jobMaterialsCreateJobMaterials;
var init_jobMaterialsCreateJobMaterials2 = __esm(() => {
  init_jobMaterialsCreateJobMaterials();
  init_components();
  init_tools();
  args80 = {
    request: JobMaterialInput$inboundSchema
  };
  tool$jobMaterialsCreateJobMaterials = {
    name: "job-materials-create-job-materials",
    description: `Create a new Job Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_materials**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args80,
    tool: async (client, args81, ctx) => {
      const [result2, apiCall] = await jobMaterialsCreateJobMaterials(client, args81.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialsDeleteJobMaterials.ts
function jobMaterialsDeleteJobMaterials(client, request, options) {
  return new APIPromise($do101(client, request, options));
}
async function $do101(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterial/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialsDeleteJobMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialsDeleteJobMaterials.ts
var args81, tool$jobMaterialsDeleteJobMaterials;
var init_jobMaterialsDeleteJobMaterials2 = __esm(() => {
  init_jobMaterialsDeleteJobMaterials();
  init_operations();
  init_tools();
  args81 = {
    request: DeleteJobMaterialsRequest$inboundSchema
  };
  tool$jobMaterialsDeleteJobMaterials = {
    name: "job-materials-delete-job-materials",
    description: `Delete a Job Material


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_materials**.

			`,
    args: args81,
    tool: async (client, args82, ctx) => {
      const [result2, apiCall] = await jobMaterialsDeleteJobMaterials(client, args82.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialsGetJobMaterials.ts
function jobMaterialsGetJobMaterials(client, request, options) {
  return new APIPromise($do102(client, request, options));
}
async function $do102(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterial/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialsGetJobMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialsGetJobMaterials.ts
var args82, tool$jobMaterialsGetJobMaterials;
var init_jobMaterialsGetJobMaterials2 = __esm(() => {
  init_jobMaterialsGetJobMaterials();
  init_operations();
  init_tools();
  args82 = {
    request: GetJobMaterialsRequest$inboundSchema
  };
  tool$jobMaterialsGetJobMaterials = {
    name: "job-materials-get-job-materials",
    description: `Retrieve a Job Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_materials**.

			`,
    args: args82,
    tool: async (client, args83, ctx) => {
      const [result2, apiCall] = await jobMaterialsGetJobMaterials(client, args83.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialsListJobMaterials.ts
function jobMaterialsListJobMaterials(client, options) {
  return new APIPromise($do103(client, options));
}
async function $do103(client, options) {
  const path = pathToFunc("/jobmaterial.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialsListJobMaterials = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialsListJobMaterials.ts
var tool$jobMaterialsListJobMaterials;
var init_jobMaterialsListJobMaterials2 = __esm(() => {
  init_jobMaterialsListJobMaterials();
  init_tools();
  tool$jobMaterialsListJobMaterials = {
    name: "job-materials-list-job-materials",
    description: `List all Job Materials


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_materials**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobMaterialsListJobMaterials(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobMaterialsUpdateJobMaterials.ts
function jobMaterialsUpdateJobMaterials(client, request, options) {
  return new APIPromise($do104(client, request, options));
}
async function $do104(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobMaterial, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobmaterial/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobMaterialsUpdateJobMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobMaterialsUpdateJobMaterials.ts
var args83, tool$jobMaterialsUpdateJobMaterials;
var init_jobMaterialsUpdateJobMaterials2 = __esm(() => {
  init_jobMaterialsUpdateJobMaterials();
  init_operations();
  init_tools();
  args83 = {
    request: UpdateJobMaterialsRequest$inboundSchema
  };
  tool$jobMaterialsUpdateJobMaterials = {
    name: "job-materials-update-job-materials",
    description: `Update a Job Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_materials**.

			`,
    args: args83,
    tool: async (client, args84, ctx) => {
      const [result2, apiCall] = await jobMaterialsUpdateJobMaterials(client, args84.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobPaymentsCreateJobPayments.ts
function jobPaymentsCreateJobPayments(client, request, options) {
  return new APIPromise($do105(client, request, options));
}
async function $do105(client, request, options) {
  const parsed = safeParse(request, (value) => JobPaymentInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/jobpayment.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobPayments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobPaymentsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobPaymentsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobPaymentsCreateJobPayments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobPaymentsCreateJobPayments.ts
var args84, tool$jobPaymentsCreateJobPayments;
var init_jobPaymentsCreateJobPayments2 = __esm(() => {
  init_jobPaymentsCreateJobPayments();
  init_components();
  init_tools();
  args84 = {
    request: JobPaymentInput$inboundSchema
  };
  tool$jobPaymentsCreateJobPayments = {
    name: "job-payments-create-job-payments",
    description: `Create a new Job Payment


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args84,
    tool: async (client, args85, ctx) => {
      const [result2, apiCall] = await jobPaymentsCreateJobPayments(client, args85.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobPaymentsDeleteJobPayments.ts
function jobPaymentsDeleteJobPayments(client, request, options) {
  return new APIPromise($do106(client, request, options));
}
async function $do106(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobPaymentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobpayment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobPayments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobPaymentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobPaymentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobPaymentsDeleteJobPayments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobPaymentsDeleteJobPayments.ts
var args85, tool$jobPaymentsDeleteJobPayments;
var init_jobPaymentsDeleteJobPayments2 = __esm(() => {
  init_jobPaymentsDeleteJobPayments();
  init_operations();
  init_tools();
  args85 = {
    request: DeleteJobPaymentsRequest$inboundSchema
  };
  tool$jobPaymentsDeleteJobPayments = {
    name: "job-payments-delete-job-payments",
    description: `Delete a Job Payment


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args85,
    tool: async (client, args86, ctx) => {
      const [result2, apiCall] = await jobPaymentsDeleteJobPayments(client, args86.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobPaymentsGetJobPayments.ts
function jobPaymentsGetJobPayments(client, request, options) {
  return new APIPromise($do107(client, request, options));
}
async function $do107(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobPaymentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobpayment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobPayments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobPaymentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobPaymentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobPaymentsGetJobPayments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobPaymentsGetJobPayments.ts
var args86, tool$jobPaymentsGetJobPayments;
var init_jobPaymentsGetJobPayments2 = __esm(() => {
  init_jobPaymentsGetJobPayments();
  init_operations();
  init_tools();
  args86 = {
    request: GetJobPaymentsRequest$inboundSchema
  };
  tool$jobPaymentsGetJobPayments = {
    name: "job-payments-get-job-payments",
    description: `Retrieve a Job Payment`,
    args: args86,
    tool: async (client, args87, ctx) => {
      const [result2, apiCall] = await jobPaymentsGetJobPayments(client, args87.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobPaymentsListJobPayments.ts
function jobPaymentsListJobPayments(client, options) {
  return new APIPromise($do108(client, options));
}
async function $do108(client, options) {
  const path = pathToFunc("/jobpayment.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobPayments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobPaymentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobPaymentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobPaymentsListJobPayments = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobPaymentsListJobPayments.ts
var tool$jobPaymentsListJobPayments;
var init_jobPaymentsListJobPayments2 = __esm(() => {
  init_jobPaymentsListJobPayments();
  init_tools();
  tool$jobPaymentsListJobPayments = {
    name: "job-payments-list-job-payments",
    description: `List all Job Payments


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobPaymentsListJobPayments(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobPaymentsUpdateJobPayments.ts
function jobPaymentsUpdateJobPayments(client, request, options) {
  return new APIPromise($do109(client, request, options));
}
async function $do109(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobPaymentsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.JobPayment, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/jobpayment/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobPayments",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobPaymentsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobPaymentsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobPaymentsUpdateJobPayments = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobPaymentsUpdateJobPayments.ts
var args87, tool$jobPaymentsUpdateJobPayments;
var init_jobPaymentsUpdateJobPayments2 = __esm(() => {
  init_jobPaymentsUpdateJobPayments();
  init_operations();
  init_tools();
  args87 = {
    request: UpdateJobPaymentsRequest$inboundSchema
  };
  tool$jobPaymentsUpdateJobPayments = {
    name: "job-payments-update-job-payments",
    description: `Update a Job Payment`,
    args: args87,
    tool: async (client, args88, ctx) => {
      const [result2, apiCall] = await jobPaymentsUpdateJobPayments(client, args88.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobQueuesCreateJobQueues.ts
function jobQueuesCreateJobQueues(client, request, options) {
  return new APIPromise($do110(client, request, options));
}
async function $do110(client, request, options) {
  const parsed = safeParse(request, (value) => QueueInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/queue.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobQueues",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobQueuesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobQueuesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobQueuesCreateJobQueues = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobQueuesCreateJobQueues.ts
var args88, tool$jobQueuesCreateJobQueues;
var init_jobQueuesCreateJobQueues2 = __esm(() => {
  init_jobQueuesCreateJobQueues();
  init_components();
  init_tools();
  args88 = {
    request: QueueInput$inboundSchema
  };
  tool$jobQueuesCreateJobQueues = {
    name: "job-queues-create-job-queues",
    description: `Create a new Job Queue


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_queues**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args88,
    tool: async (client, args89, ctx) => {
      const [result2, apiCall] = await jobQueuesCreateJobQueues(client, args89.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobQueuesDeleteJobQueues.ts
function jobQueuesDeleteJobQueues(client, request, options) {
  return new APIPromise($do111(client, request, options));
}
async function $do111(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobQueuesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/queue/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobQueues",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobQueuesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobQueuesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobQueuesDeleteJobQueues = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobQueuesDeleteJobQueues.ts
var args89, tool$jobQueuesDeleteJobQueues;
var init_jobQueuesDeleteJobQueues2 = __esm(() => {
  init_jobQueuesDeleteJobQueues();
  init_operations();
  init_tools();
  args89 = {
    request: DeleteJobQueuesRequest$inboundSchema
  };
  tool$jobQueuesDeleteJobQueues = {
    name: "job-queues-delete-job-queues",
    description: `Delete a Job Queue


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_queues**.

			`,
    args: args89,
    tool: async (client, args90, ctx) => {
      const [result2, apiCall] = await jobQueuesDeleteJobQueues(client, args90.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobQueuesGetJobQueues.ts
function jobQueuesGetJobQueues(client, request, options) {
  return new APIPromise($do112(client, request, options));
}
async function $do112(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobQueuesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/queue/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobQueues",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobQueuesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobQueuesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobQueuesGetJobQueues = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobQueuesGetJobQueues.ts
var args90, tool$jobQueuesGetJobQueues;
var init_jobQueuesGetJobQueues2 = __esm(() => {
  init_jobQueuesGetJobQueues();
  init_operations();
  init_tools();
  args90 = {
    request: GetJobQueuesRequest$inboundSchema
  };
  tool$jobQueuesGetJobQueues = {
    name: "job-queues-get-job-queues",
    description: `Retrieve a Job Queue


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_queues**.

			`,
    args: args90,
    tool: async (client, args91, ctx) => {
      const [result2, apiCall] = await jobQueuesGetJobQueues(client, args91.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobQueuesListJobQueues.ts
function jobQueuesListJobQueues(client, options) {
  return new APIPromise($do113(client, options));
}
async function $do113(client, options) {
  const path = pathToFunc("/queue.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobQueues",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobQueuesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobQueuesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobQueuesListJobQueues = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobQueuesListJobQueues.ts
var tool$jobQueuesListJobQueues;
var init_jobQueuesListJobQueues2 = __esm(() => {
  init_jobQueuesListJobQueues();
  init_tools();
  tool$jobQueuesListJobQueues = {
    name: "job-queues-list-job-queues",
    description: `List all Job Queues


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_job_queues**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobQueuesListJobQueues(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobQueuesUpdateJobQueues.ts
function jobQueuesUpdateJobQueues(client, request, options) {
  return new APIPromise($do114(client, request, options));
}
async function $do114(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobQueuesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Queue, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/queue/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobQueues",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobQueuesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobQueuesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobQueuesUpdateJobQueues = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobQueuesUpdateJobQueues.ts
var args91, tool$jobQueuesUpdateJobQueues;
var init_jobQueuesUpdateJobQueues2 = __esm(() => {
  init_jobQueuesUpdateJobQueues();
  init_operations();
  init_tools();
  args91 = {
    request: UpdateJobQueuesRequest$inboundSchema
  };
  tool$jobQueuesUpdateJobQueues = {
    name: "job-queues-update-job-queues",
    description: `Update a Job Queue


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_job_queues**.

			`,
    args: args91,
    tool: async (client, args92, ctx) => {
      const [result2, apiCall] = await jobQueuesUpdateJobQueues(client, args92.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobsCreateJobs.ts
function jobsCreateJobs(client, request, options) {
  return new APIPromise($do115(client, request, options));
}
async function $do115(client, request, options) {
  const parsed = safeParse(request, (value) => JobInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/job.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createJobs",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateJobsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateJobsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobsCreateJobs = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobsCreateJobs.ts
var args92, tool$jobsCreateJobs;
var init_jobsCreateJobs2 = __esm(() => {
  init_jobsCreateJobs();
  init_components();
  init_tools();
  args92 = {
    request: JobInput$inboundSchema
  };
  tool$jobsCreateJobs = {
    name: "jobs-create-jobs",
    description: `Create a new Job


			
#### OAuth Scope
This endpoint requires the following OAuth scope **create_jobs**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args92,
    tool: async (client, args93, ctx) => {
      const [result2, apiCall] = await jobsCreateJobs(client, args93.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobsDeleteJobs.ts
function jobsDeleteJobs(client, request, options) {
  return new APIPromise($do116(client, request, options));
}
async function $do116(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteJobsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/job/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteJobs",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteJobsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteJobsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobsDeleteJobs = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobsDeleteJobs.ts
var args93, tool$jobsDeleteJobs;
var init_jobsDeleteJobs2 = __esm(() => {
  init_jobsDeleteJobs();
  init_operations();
  init_tools();
  args93 = {
    request: DeleteJobsRequest$inboundSchema
  };
  tool$jobsDeleteJobs = {
    name: "jobs-delete-jobs",
    description: `Delete a Job


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_jobs**.

			`,
    args: args93,
    tool: async (client, args94, ctx) => {
      const [result2, apiCall] = await jobsDeleteJobs(client, args94.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobsGetJobs.ts
function jobsGetJobs(client, request, options) {
  return new APIPromise($do117(client, request, options));
}
async function $do117(client, request, options) {
  const parsed = safeParse(request, (value) => GetJobsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/job/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getJobs",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetJobsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetJobsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobsGetJobs = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobsGetJobs.ts
var args94, tool$jobsGetJobs;
var init_jobsGetJobs2 = __esm(() => {
  init_jobsGetJobs();
  init_operations();
  init_tools();
  args94 = {
    request: GetJobsRequest$inboundSchema
  };
  tool$jobsGetJobs = {
    name: "jobs-get-jobs",
    description: `Retrieve a Job


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_jobs**.

			`,
    args: args94,
    tool: async (client, args95, ctx) => {
      const [result2, apiCall] = await jobsGetJobs(client, args95.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobsListJobs.ts
function jobsListJobs(client, options) {
  return new APIPromise($do118(client, options));
}
async function $do118(client, options) {
  const path = pathToFunc("/job.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listJobs",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListJobsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListJobsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobsListJobs = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobsListJobs.ts
var tool$jobsListJobs;
var init_jobsListJobs2 = __esm(() => {
  init_jobsListJobs();
  init_tools();
  tool$jobsListJobs = {
    name: "jobs-list-jobs",
    description: `List all Jobs


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_jobs**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await jobsListJobs(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/jobsUpdateJobs.ts
function jobsUpdateJobs(client, request, options) {
  return new APIPromise($do119(client, request, options));
}
async function $do119(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateJobsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Job, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/job/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateJobs",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateJobsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateJobsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_jobsUpdateJobs = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/jobsUpdateJobs.ts
var args95, tool$jobsUpdateJobs;
var init_jobsUpdateJobs2 = __esm(() => {
  init_jobsUpdateJobs();
  init_operations();
  init_tools();
  args95 = {
    request: UpdateJobsRequest$inboundSchema
  };
  tool$jobsUpdateJobs = {
    name: "jobs-update-jobs",
    description: `Update a Job


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_jobs**.

			`,
    args: args95,
    tool: async (client, args96, ctx) => {
      const [result2, apiCall] = await jobsUpdateJobs(client, args96.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/knowledgeArticlesCreateKnowledgeArticles.ts
function knowledgeArticlesCreateKnowledgeArticles(client, request, options) {
  return new APIPromise($do120(client, request, options));
}
async function $do120(client, request, options) {
  const parsed = safeParse(request, (value) => KnowledgeArticleInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/knowledgearticle.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createKnowledgeArticles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateKnowledgeArticlesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateKnowledgeArticlesResponse$inboundSchema, { key: "Result" }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_knowledgeArticlesCreateKnowledgeArticles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/knowledgeArticlesCreateKnowledgeArticles.ts
var args96, tool$knowledgeArticlesCreateKnowledgeArticles;
var init_knowledgeArticlesCreateKnowledgeArticles2 = __esm(() => {
  init_knowledgeArticlesCreateKnowledgeArticles();
  init_components();
  init_tools();
  args96 = {
    request: KnowledgeArticleInput$inboundSchema
  };
  tool$knowledgeArticlesCreateKnowledgeArticles = {
    name: "knowledge-articles-create-knowledge-articles",
    description: `Create a new Knowledge Article


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_knowledge**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args96,
    tool: async (client, args97, ctx) => {
      const [result2, apiCall] = await knowledgeArticlesCreateKnowledgeArticles(client, args97.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/knowledgeArticlesDeleteKnowledgeArticles.ts
function knowledgeArticlesDeleteKnowledgeArticles(client, request, options) {
  return new APIPromise($do121(client, request, options));
}
async function $do121(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteKnowledgeArticlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/knowledgearticle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteKnowledgeArticles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteKnowledgeArticlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteKnowledgeArticlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_knowledgeArticlesDeleteKnowledgeArticles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/knowledgeArticlesDeleteKnowledgeArticles.ts
var args97, tool$knowledgeArticlesDeleteKnowledgeArticles;
var init_knowledgeArticlesDeleteKnowledgeArticles2 = __esm(() => {
  init_knowledgeArticlesDeleteKnowledgeArticles();
  init_operations();
  init_tools();
  args97 = {
    request: DeleteKnowledgeArticlesRequest$inboundSchema
  };
  tool$knowledgeArticlesDeleteKnowledgeArticles = {
    name: "knowledge-articles-delete-knowledge-articles",
    description: `Delete a Knowledge Article


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args97,
    tool: async (client, args98, ctx) => {
      const [result2, apiCall] = await knowledgeArticlesDeleteKnowledgeArticles(client, args98.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/knowledgeArticlesGetKnowledgeArticles.ts
function knowledgeArticlesGetKnowledgeArticles(client, request, options) {
  return new APIPromise($do122(client, request, options));
}
async function $do122(client, request, options) {
  const parsed = safeParse(request, (value) => GetKnowledgeArticlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/knowledgearticle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getKnowledgeArticles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetKnowledgeArticlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetKnowledgeArticlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_knowledgeArticlesGetKnowledgeArticles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/knowledgeArticlesGetKnowledgeArticles.ts
var args98, tool$knowledgeArticlesGetKnowledgeArticles;
var init_knowledgeArticlesGetKnowledgeArticles2 = __esm(() => {
  init_knowledgeArticlesGetKnowledgeArticles();
  init_operations();
  init_tools();
  args98 = {
    request: GetKnowledgeArticlesRequest$inboundSchema
  };
  tool$knowledgeArticlesGetKnowledgeArticles = {
    name: "knowledge-articles-get-knowledge-articles",
    description: `Retrieve a Knowledge Article


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_knowledge**.

			`,
    args: args98,
    tool: async (client, args99, ctx) => {
      const [result2, apiCall] = await knowledgeArticlesGetKnowledgeArticles(client, args99.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/knowledgeArticlesListKnowledgeArticles.ts
function knowledgeArticlesListKnowledgeArticles(client, options) {
  return new APIPromise($do123(client, options));
}
async function $do123(client, options) {
  const path = pathToFunc("/knowledgearticle.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listKnowledgeArticles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListKnowledgeArticlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListKnowledgeArticlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_knowledgeArticlesListKnowledgeArticles = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/knowledgeArticlesListKnowledgeArticles.ts
var tool$knowledgeArticlesListKnowledgeArticles;
var init_knowledgeArticlesListKnowledgeArticles2 = __esm(() => {
  init_knowledgeArticlesListKnowledgeArticles();
  init_tools();
  tool$knowledgeArticlesListKnowledgeArticles = {
    name: "knowledge-articles-list-knowledge-articles",
    description: `List all Knowledge Articles


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_knowledge**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await knowledgeArticlesListKnowledgeArticles(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/knowledgeArticlesUpdateKnowledgeArticles.ts
function knowledgeArticlesUpdateKnowledgeArticles(client, request, options) {
  return new APIPromise($do124(client, request, options));
}
async function $do124(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateKnowledgeArticlesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.KnowledgeArticle, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/knowledgearticle/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateKnowledgeArticles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateKnowledgeArticlesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateKnowledgeArticlesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_knowledgeArticlesUpdateKnowledgeArticles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/knowledgeArticlesUpdateKnowledgeArticles.ts
var args99, tool$knowledgeArticlesUpdateKnowledgeArticles;
var init_knowledgeArticlesUpdateKnowledgeArticles2 = __esm(() => {
  init_knowledgeArticlesUpdateKnowledgeArticles();
  init_operations();
  init_tools();
  args99 = {
    request: UpdateKnowledgeArticlesRequest$inboundSchema
  };
  tool$knowledgeArticlesUpdateKnowledgeArticles = {
    name: "knowledge-articles-update-knowledge-articles",
    description: `Update a Knowledge Article`,
    args: args99,
    tool: async (client, args100, ctx) => {
      const [result2, apiCall] = await knowledgeArticlesUpdateKnowledgeArticles(client, args100.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/locationsCreateLocations.ts
function locationsCreateLocations(client, request, options) {
  return new APIPromise($do125(client, request, options));
}
async function $do125(client, request, options) {
  const parsed = safeParse(request, (value) => LocationInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/location.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createLocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateLocationsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateLocationsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_locationsCreateLocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/locationsCreateLocations.ts
var args100, tool$locationsCreateLocations;
var init_locationsCreateLocations2 = __esm(() => {
  init_locationsCreateLocations();
  init_components();
  init_tools();
  args100 = {
    request: LocationInput$inboundSchema
  };
  tool$locationsCreateLocations = {
    name: "locations-create-locations",
    description: `Create a new Location


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_locations**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args100,
    tool: async (client, args101, ctx) => {
      const [result2, apiCall] = await locationsCreateLocations(client, args101.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/locationsDeleteLocations.ts
function locationsDeleteLocations(client, request, options) {
  return new APIPromise($do126(client, request, options));
}
async function $do126(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteLocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/location/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteLocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteLocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteLocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_locationsDeleteLocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/locationsDeleteLocations.ts
var args101, tool$locationsDeleteLocations;
var init_locationsDeleteLocations2 = __esm(() => {
  init_locationsDeleteLocations();
  init_operations();
  init_tools();
  args101 = {
    request: DeleteLocationsRequest$inboundSchema
  };
  tool$locationsDeleteLocations = {
    name: "locations-delete-locations",
    description: `Delete a Location


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_locations**.

			`,
    args: args101,
    tool: async (client, args102, ctx) => {
      const [result2, apiCall] = await locationsDeleteLocations(client, args102.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/locationsGetLocations.ts
function locationsGetLocations(client, request, options) {
  return new APIPromise($do127(client, request, options));
}
async function $do127(client, request, options) {
  const parsed = safeParse(request, (value) => GetLocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/location/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getLocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetLocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetLocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_locationsGetLocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/locationsGetLocations.ts
var args102, tool$locationsGetLocations;
var init_locationsGetLocations2 = __esm(() => {
  init_locationsGetLocations();
  init_operations();
  init_tools();
  args102 = {
    request: GetLocationsRequest$inboundSchema
  };
  tool$locationsGetLocations = {
    name: "locations-get-locations",
    description: `Retrieve a Location


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_locations**.

			`,
    args: args102,
    tool: async (client, args103, ctx) => {
      const [result2, apiCall] = await locationsGetLocations(client, args103.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/locationsListLocations.ts
function locationsListLocations(client, options) {
  return new APIPromise($do128(client, options));
}
async function $do128(client, options) {
  const path = pathToFunc("/location.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listLocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListLocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListLocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_locationsListLocations = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/locationsListLocations.ts
var tool$locationsListLocations;
var init_locationsListLocations2 = __esm(() => {
  init_locationsListLocations();
  init_tools();
  tool$locationsListLocations = {
    name: "locations-list-locations",
    description: `List all Locations


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_locations**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await locationsListLocations(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/locationsUpdateLocations.ts
function locationsUpdateLocations(client, request, options) {
  return new APIPromise($do129(client, request, options));
}
async function $do129(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateLocationsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Location, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/location/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateLocations",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateLocationsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateLocationsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_locationsUpdateLocations = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/locationsUpdateLocations.ts
var args103, tool$locationsUpdateLocations;
var init_locationsUpdateLocations2 = __esm(() => {
  init_locationsUpdateLocations();
  init_operations();
  init_tools();
  args103 = {
    request: UpdateLocationsRequest$inboundSchema
  };
  tool$locationsUpdateLocations = {
    name: "locations-update-locations",
    description: `Update a Location


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_locations**.

			`,
    args: args103,
    tool: async (client, args104, ctx) => {
      const [result2, apiCall] = await locationsUpdateLocations(client, args104.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/materialsCreateMaterials.ts
function materialsCreateMaterials(client, request, options) {
  return new APIPromise($do130(client, request, options));
}
async function $do130(client, request, options) {
  const parsed = safeParse(request, (value) => MaterialInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/material.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateMaterialsResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateMaterialsResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_materialsCreateMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/materialsCreateMaterials.ts
var args104, tool$materialsCreateMaterials;
var init_materialsCreateMaterials2 = __esm(() => {
  init_materialsCreateMaterials();
  init_components();
  init_tools();
  args104 = {
    request: MaterialInput$inboundSchema
  };
  tool$materialsCreateMaterials = {
    name: "materials-create-materials",
    description: `Create a new Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_inventory**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args104,
    tool: async (client, args105, ctx) => {
      const [result2, apiCall] = await materialsCreateMaterials(client, args105.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/materialsDeleteMaterials.ts
function materialsDeleteMaterials(client, request, options) {
  return new APIPromise($do131(client, request, options));
}
async function $do131(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/material/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_materialsDeleteMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/materialsDeleteMaterials.ts
var args105, tool$materialsDeleteMaterials;
var init_materialsDeleteMaterials2 = __esm(() => {
  init_materialsDeleteMaterials();
  init_operations();
  init_tools();
  args105 = {
    request: DeleteMaterialsRequest$inboundSchema
  };
  tool$materialsDeleteMaterials = {
    name: "materials-delete-materials",
    description: `Delete a Material


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_inventory**.

			`,
    args: args105,
    tool: async (client, args106, ctx) => {
      const [result2, apiCall] = await materialsDeleteMaterials(client, args106.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/materialsGetMaterials.ts
function materialsGetMaterials(client, request, options) {
  return new APIPromise($do132(client, request, options));
}
async function $do132(client, request, options) {
  const parsed = safeParse(request, (value) => GetMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/material/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_materialsGetMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/materialsGetMaterials.ts
var args106, tool$materialsGetMaterials;
var init_materialsGetMaterials2 = __esm(() => {
  init_materialsGetMaterials();
  init_operations();
  init_tools();
  args106 = {
    request: GetMaterialsRequest$inboundSchema
  };
  tool$materialsGetMaterials = {
    name: "materials-get-materials",
    description: `Retrieve a Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_inventory**.

			`,
    args: args106,
    tool: async (client, args107, ctx) => {
      const [result2, apiCall] = await materialsGetMaterials(client, args107.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/materialsListMaterials.ts
function materialsListMaterials(client, options) {
  return new APIPromise($do133(client, options));
}
async function $do133(client, options) {
  const path = pathToFunc("/material.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_materialsListMaterials = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/materialsListMaterials.ts
var tool$materialsListMaterials;
var init_materialsListMaterials2 = __esm(() => {
  init_materialsListMaterials();
  init_tools();
  tool$materialsListMaterials = {
    name: "materials-list-materials",
    description: `List all Materials


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_inventory**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await materialsListMaterials(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/materialsUpdateMaterials.ts
function materialsUpdateMaterials(client, request, options) {
  return new APIPromise($do134(client, request, options));
}
async function $do134(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateMaterialsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Material, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/material/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateMaterials",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateMaterialsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateMaterialsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_materialsUpdateMaterials = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/materialsUpdateMaterials.ts
var args107, tool$materialsUpdateMaterials;
var init_materialsUpdateMaterials2 = __esm(() => {
  init_materialsUpdateMaterials();
  init_operations();
  init_tools();
  args107 = {
    request: UpdateMaterialsRequest$inboundSchema
  };
  tool$materialsUpdateMaterials = {
    name: "materials-update-materials",
    description: `Update a Material


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_inventory**.

			`,
    args: args107,
    tool: async (client, args108, ctx) => {
      const [result2, apiCall] = await materialsUpdateMaterials(client, args108.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/notesCreateNotes.ts
function notesCreateNotes(client, request, options) {
  return new APIPromise($do135(client, request, options));
}
async function $do135(client, request, options) {
  const parsed = safeParse(request, (value) => NoteInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/note.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createNotes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateNotesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateNotesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_notesCreateNotes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/notesCreateNotes.ts
var args108, tool$notesCreateNotes;
var init_notesCreateNotes2 = __esm(() => {
  init_notesCreateNotes();
  init_components();
  init_tools();
  args108 = {
    request: NoteInput$inboundSchema
  };
  tool$notesCreateNotes = {
    name: "notes-create-notes",
    description: `Create a new Note


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args108,
    tool: async (client, args109, ctx) => {
      const [result2, apiCall] = await notesCreateNotes(client, args109.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/notesDeleteNotes.ts
function notesDeleteNotes(client, request, options) {
  return new APIPromise($do136(client, request, options));
}
async function $do136(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteNotesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/note/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteNotes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteNotesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteNotesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_notesDeleteNotes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/notesDeleteNotes.ts
var args109, tool$notesDeleteNotes;
var init_notesDeleteNotes2 = __esm(() => {
  init_notesDeleteNotes();
  init_operations();
  init_tools();
  args109 = {
    request: DeleteNotesRequest$inboundSchema
  };
  tool$notesDeleteNotes = {
    name: "notes-delete-notes",
    description: `Delete a Note


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args109,
    tool: async (client, args110, ctx) => {
      const [result2, apiCall] = await notesDeleteNotes(client, args110.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/notesGetNotes.ts
function notesGetNotes(client, request, options) {
  return new APIPromise($do137(client, request, options));
}
async function $do137(client, request, options) {
  const parsed = safeParse(request, (value) => GetNotesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/note/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getNotes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetNotesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetNotesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_notesGetNotes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/notesGetNotes.ts
var args110, tool$notesGetNotes;
var init_notesGetNotes2 = __esm(() => {
  init_notesGetNotes();
  init_operations();
  init_tools();
  args110 = {
    request: GetNotesRequest$inboundSchema
  };
  tool$notesGetNotes = {
    name: "notes-get-notes",
    description: `Retrieve a Note`,
    args: args110,
    tool: async (client, args111, ctx) => {
      const [result2, apiCall] = await notesGetNotes(client, args111.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/notesListNotes.ts
function notesListNotes(client, options) {
  return new APIPromise($do138(client, options));
}
async function $do138(client, options) {
  const path = pathToFunc("/note.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listNotes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListNotesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListNotesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_notesListNotes = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/notesListNotes.ts
var tool$notesListNotes;
var init_notesListNotes2 = __esm(() => {
  init_notesListNotes();
  init_tools();
  tool$notesListNotes = {
    name: "notes-list-notes",
    description: `List all Notes


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await notesListNotes(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/notesUpdateNotes.ts
function notesUpdateNotes(client, request, options) {
  return new APIPromise($do139(client, request, options));
}
async function $do139(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateNotesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Note, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/note/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateNotes",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateNotesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateNotesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_notesUpdateNotes = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/notesUpdateNotes.ts
var args111, tool$notesUpdateNotes;
var init_notesUpdateNotes2 = __esm(() => {
  init_notesUpdateNotes();
  init_operations();
  init_tools();
  args111 = {
    request: UpdateNotesRequest$inboundSchema
  };
  tool$notesUpdateNotes = {
    name: "notes-update-notes",
    description: `Update a Note`,
    args: args111,
    tool: async (client, args112, ctx) => {
      const [result2, apiCall] = await notesUpdateNotes(client, args112.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/securityRolesCreateSecurityRoles.ts
function securityRolesCreateSecurityRoles(client, request, options) {
  return new APIPromise($do140(client, request, options));
}
async function $do140(client, request, options) {
  const parsed = safeParse(request, (value) => SecurityRoleInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/securityrole.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createSecurityRoles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateSecurityRolesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateSecurityRolesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_securityRolesCreateSecurityRoles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/securityRolesCreateSecurityRoles.ts
var args112, tool$securityRolesCreateSecurityRoles;
var init_securityRolesCreateSecurityRoles2 = __esm(() => {
  init_securityRolesCreateSecurityRoles();
  init_components();
  init_tools();
  args112 = {
    request: SecurityRoleInput$inboundSchema
  };
  tool$securityRolesCreateSecurityRoles = {
    name: "security-roles-create-security-roles",
    description: `Create a new Security Role


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args112,
    tool: async (client, args113, ctx) => {
      const [result2, apiCall] = await securityRolesCreateSecurityRoles(client, args113.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/securityRolesDeleteSecurityRoles.ts
function securityRolesDeleteSecurityRoles(client, request, options) {
  return new APIPromise($do141(client, request, options));
}
async function $do141(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteSecurityRolesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/securityrole/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteSecurityRoles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteSecurityRolesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteSecurityRolesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_securityRolesDeleteSecurityRoles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/securityRolesDeleteSecurityRoles.ts
var args113, tool$securityRolesDeleteSecurityRoles;
var init_securityRolesDeleteSecurityRoles2 = __esm(() => {
  init_securityRolesDeleteSecurityRoles();
  init_operations();
  init_tools();
  args113 = {
    request: DeleteSecurityRolesRequest$inboundSchema
  };
  tool$securityRolesDeleteSecurityRoles = {
    name: "security-roles-delete-security-roles",
    description: `Delete a Security Role


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args113,
    tool: async (client, args114, ctx) => {
      const [result2, apiCall] = await securityRolesDeleteSecurityRoles(client, args114.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/securityRolesGetSecurityRoles.ts
function securityRolesGetSecurityRoles(client, request, options) {
  return new APIPromise($do142(client, request, options));
}
async function $do142(client, request, options) {
  const parsed = safeParse(request, (value) => GetSecurityRolesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/securityrole/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getSecurityRoles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetSecurityRolesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetSecurityRolesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_securityRolesGetSecurityRoles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/securityRolesGetSecurityRoles.ts
var args114, tool$securityRolesGetSecurityRoles;
var init_securityRolesGetSecurityRoles2 = __esm(() => {
  init_securityRolesGetSecurityRoles();
  init_operations();
  init_tools();
  args114 = {
    request: GetSecurityRolesRequest$inboundSchema
  };
  tool$securityRolesGetSecurityRoles = {
    name: "security-roles-get-security-roles",
    description: `Retrieve a Security Role`,
    args: args114,
    tool: async (client, args115, ctx) => {
      const [result2, apiCall] = await securityRolesGetSecurityRoles(client, args115.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/securityRolesListSecurityRoles.ts
function securityRolesListSecurityRoles(client, options) {
  return new APIPromise($do143(client, options));
}
async function $do143(client, options) {
  const path = pathToFunc("/securityrole.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listSecurityRoles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListSecurityRolesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListSecurityRolesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_securityRolesListSecurityRoles = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/securityRolesListSecurityRoles.ts
var tool$securityRolesListSecurityRoles;
var init_securityRolesListSecurityRoles2 = __esm(() => {
  init_securityRolesListSecurityRoles();
  init_tools();
  tool$securityRolesListSecurityRoles = {
    name: "security-roles-list-security-roles",
    description: `List all Security Roles


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await securityRolesListSecurityRoles(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/securityRolesUpdateSecurityRoles.ts
function securityRolesUpdateSecurityRoles(client, request, options) {
  return new APIPromise($do144(client, request, options));
}
async function $do144(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateSecurityRolesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.SecurityRole, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/securityrole/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateSecurityRoles",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateSecurityRolesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateSecurityRolesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_securityRolesUpdateSecurityRoles = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/securityRolesUpdateSecurityRoles.ts
var args115, tool$securityRolesUpdateSecurityRoles;
var init_securityRolesUpdateSecurityRoles2 = __esm(() => {
  init_securityRolesUpdateSecurityRoles();
  init_operations();
  init_tools();
  args115 = {
    request: UpdateSecurityRolesRequest$inboundSchema
  };
  tool$securityRolesUpdateSecurityRoles = {
    name: "security-roles-update-security-roles",
    description: `Update a Security Role`,
    args: args115,
    tool: async (client, args116, ctx) => {
      const [result2, apiCall] = await securityRolesUpdateSecurityRoles(client, args116.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/smsTemplatesCreateSMSTemplates.ts
function smsTemplatesCreateSMSTemplates(client, request, options) {
  return new APIPromise($do145(client, request, options));
}
async function $do145(client, request, options) {
  const parsed = safeParse(request, (value) => SmsTemplateInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/smstemplate.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createSMSTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateSMSTemplatesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateSMSTemplatesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_smsTemplatesCreateSMSTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/smsTemplatesCreateSMSTemplates.ts
var args116, tool$smsTemplatesCreateSMSTemplates;
var init_smsTemplatesCreateSMSTemplates2 = __esm(() => {
  init_smsTemplatesCreateSMSTemplates();
  init_components();
  init_tools();
  args116 = {
    request: SmsTemplateInput$inboundSchema
  };
  tool$smsTemplatesCreateSMSTemplates = {
    name: "SMS-templates-create-SMS-templates",
    description: `Create a new SMS Template


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args116,
    tool: async (client, args117, ctx) => {
      const [result2, apiCall] = await smsTemplatesCreateSMSTemplates(client, args117.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/smsTemplatesDeleteSMSTemplates.ts
function smsTemplatesDeleteSMSTemplates(client, request, options) {
  return new APIPromise($do146(client, request, options));
}
async function $do146(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteSMSTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/smstemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteSMSTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteSMSTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteSMSTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_smsTemplatesDeleteSMSTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/smsTemplatesDeleteSMSTemplates.ts
var args117, tool$smsTemplatesDeleteSMSTemplates;
var init_smsTemplatesDeleteSMSTemplates2 = __esm(() => {
  init_smsTemplatesDeleteSMSTemplates();
  init_operations();
  init_tools();
  args117 = {
    request: DeleteSMSTemplatesRequest$inboundSchema
  };
  tool$smsTemplatesDeleteSMSTemplates = {
    name: "SMS-templates-delete-SMS-templates",
    description: `Delete a SMS Template


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args117,
    tool: async (client, args118, ctx) => {
      const [result2, apiCall] = await smsTemplatesDeleteSMSTemplates(client, args118.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/smsTemplatesGetSMSTemplates.ts
function smsTemplatesGetSMSTemplates(client, request, options) {
  return new APIPromise($do147(client, request, options));
}
async function $do147(client, request, options) {
  const parsed = safeParse(request, (value) => GetSMSTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/smstemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getSMSTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetSMSTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetSMSTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_smsTemplatesGetSMSTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/smsTemplatesGetSMSTemplates.ts
var args118, tool$smsTemplatesGetSMSTemplates;
var init_smsTemplatesGetSMSTemplates2 = __esm(() => {
  init_smsTemplatesGetSMSTemplates();
  init_operations();
  init_tools();
  args118 = {
    request: GetSMSTemplatesRequest$inboundSchema
  };
  tool$smsTemplatesGetSMSTemplates = {
    name: "SMS-templates-get-SMS-templates",
    description: `Retrieve a SMS Template`,
    args: args118,
    tool: async (client, args119, ctx) => {
      const [result2, apiCall] = await smsTemplatesGetSMSTemplates(client, args119.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/smsTemplatesListSMSTemplates.ts
function smsTemplatesListSMSTemplates(client, options) {
  return new APIPromise($do148(client, options));
}
async function $do148(client, options) {
  const path = pathToFunc("/smstemplate.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listSMSTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListSMSTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListSMSTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_smsTemplatesListSMSTemplates = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/smsTemplatesListSMSTemplates.ts
var tool$smsTemplatesListSMSTemplates;
var init_smsTemplatesListSMSTemplates2 = __esm(() => {
  init_smsTemplatesListSMSTemplates();
  init_tools();
  tool$smsTemplatesListSMSTemplates = {
    name: "SMS-templates-list-SMS-templates",
    description: `List all SMS Templates


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await smsTemplatesListSMSTemplates(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/smsTemplatesUpdateSMSTemplates.ts
function smsTemplatesUpdateSMSTemplates(client, request, options) {
  return new APIPromise($do149(client, request, options));
}
async function $do149(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateSMSTemplatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.SmsTemplate, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/smstemplate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateSMSTemplates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateSMSTemplatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateSMSTemplatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_smsTemplatesUpdateSMSTemplates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/smsTemplatesUpdateSMSTemplates.ts
var args119, tool$smsTemplatesUpdateSMSTemplates;
var init_smsTemplatesUpdateSMSTemplates2 = __esm(() => {
  init_smsTemplatesUpdateSMSTemplates();
  init_operations();
  init_tools();
  args119 = {
    request: UpdateSMSTemplatesRequest$inboundSchema
  };
  tool$smsTemplatesUpdateSMSTemplates = {
    name: "SMS-templates-update-SMS-templates",
    description: `Update a SMS Template`,
    args: args119,
    tool: async (client, args120, ctx) => {
      const [result2, apiCall] = await smsTemplatesUpdateSMSTemplates(client, args120.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMembersCreateStaffMembers.ts
function staffMembersCreateStaffMembers(client, request, options) {
  return new APIPromise($do150(client, request, options));
}
async function $do150(client, request, options) {
  const parsed = safeParse(request, (value) => StaffInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/staff.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createStaffMembers",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateStaffMembersResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateStaffMembersResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMembersCreateStaffMembers = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMembersCreateStaffMembers.ts
var args120, tool$staffMembersCreateStaffMembers;
var init_staffMembersCreateStaffMembers2 = __esm(() => {
  init_staffMembersCreateStaffMembers();
  init_components();
  init_tools();
  args120 = {
    request: StaffInput$inboundSchema
  };
  tool$staffMembersCreateStaffMembers = {
    name: "staff-members-create-staff-members",
    description: `Create a new Staff Member


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_staff**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args120,
    tool: async (client, args121, ctx) => {
      const [result2, apiCall] = await staffMembersCreateStaffMembers(client, args121.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMembersDeleteStaffMembers.ts
function staffMembersDeleteStaffMembers(client, request, options) {
  return new APIPromise($do151(client, request, options));
}
async function $do151(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteStaffMembersRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staff/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteStaffMembers",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteStaffMembersResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteStaffMembersResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMembersDeleteStaffMembers = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMembersDeleteStaffMembers.ts
var args121, tool$staffMembersDeleteStaffMembers;
var init_staffMembersDeleteStaffMembers2 = __esm(() => {
  init_staffMembersDeleteStaffMembers();
  init_operations();
  init_tools();
  args121 = {
    request: DeleteStaffMembersRequest$inboundSchema
  };
  tool$staffMembersDeleteStaffMembers = {
    name: "staff-members-delete-staff-members",
    description: `Delete a Staff Member


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_staff**.

			`,
    args: args121,
    tool: async (client, args122, ctx) => {
      const [result2, apiCall] = await staffMembersDeleteStaffMembers(client, args122.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMembersGetStaffMembers.ts
function staffMembersGetStaffMembers(client, request, options) {
  return new APIPromise($do152(client, request, options));
}
async function $do152(client, request, options) {
  const parsed = safeParse(request, (value) => GetStaffMembersRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staff/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getStaffMembers",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetStaffMembersResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetStaffMembersResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMembersGetStaffMembers = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMembersGetStaffMembers.ts
var args122, tool$staffMembersGetStaffMembers;
var init_staffMembersGetStaffMembers2 = __esm(() => {
  init_staffMembersGetStaffMembers();
  init_operations();
  init_tools();
  args122 = {
    request: GetStaffMembersRequest$inboundSchema
  };
  tool$staffMembersGetStaffMembers = {
    name: "staff-members-get-staff-members",
    description: `Retrieve a Staff Member


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_staff**.

			`,
    args: args122,
    tool: async (client, args123, ctx) => {
      const [result2, apiCall] = await staffMembersGetStaffMembers(client, args123.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMembersListStaffMembers.ts
function staffMembersListStaffMembers(client, options) {
  return new APIPromise($do153(client, options));
}
async function $do153(client, options) {
  const path = pathToFunc("/staff.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listStaffMembers",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListStaffMembersResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListStaffMembersResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMembersListStaffMembers = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMembersListStaffMembers.ts
var tool$staffMembersListStaffMembers;
var init_staffMembersListStaffMembers2 = __esm(() => {
  init_staffMembersListStaffMembers();
  init_tools();
  tool$staffMembersListStaffMembers = {
    name: "staff-members-list-staff-members",
    description: `List all Staff Members


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_staff**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await staffMembersListStaffMembers(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMembersUpdateStaffMembers.ts
function staffMembersUpdateStaffMembers(client, request, options) {
  return new APIPromise($do154(client, request, options));
}
async function $do154(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateStaffMembersRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Staff, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staff/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateStaffMembers",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateStaffMembersResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateStaffMembersResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMembersUpdateStaffMembers = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMembersUpdateStaffMembers.ts
var args123, tool$staffMembersUpdateStaffMembers;
var init_staffMembersUpdateStaffMembers2 = __esm(() => {
  init_staffMembersUpdateStaffMembers();
  init_operations();
  init_tools();
  args123 = {
    request: UpdateStaffMembersRequest$inboundSchema
  };
  tool$staffMembersUpdateStaffMembers = {
    name: "staff-members-update-staff-members",
    description: `Update a Staff Member


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_staff**.

			`,
    args: args123,
    tool: async (client, args124, ctx) => {
      const [result2, apiCall] = await staffMembersUpdateStaffMembers(client, args124.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMessagesCreateStaffMessages.ts
function staffMessagesCreateStaffMessages(client, request, options) {
  return new APIPromise($do155(client, request, options));
}
async function $do155(client, request, options) {
  const parsed = safeParse(request, (value) => StaffMessageInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/staffmessage.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createStaffMessages",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateStaffMessagesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateStaffMessagesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMessagesCreateStaffMessages = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMessagesCreateStaffMessages.ts
var args124, tool$staffMessagesCreateStaffMessages;
var init_staffMessagesCreateStaffMessages2 = __esm(() => {
  init_staffMessagesCreateStaffMessages();
  init_components();
  init_tools();
  args124 = {
    request: StaffMessageInput$inboundSchema
  };
  tool$staffMessagesCreateStaffMessages = {
    name: "staff-messages-create-staff-messages",
    description: `Create a new Staff Message


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args124,
    tool: async (client, args125, ctx) => {
      const [result2, apiCall] = await staffMessagesCreateStaffMessages(client, args125.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMessagesDeleteStaffMessages.ts
function staffMessagesDeleteStaffMessages(client, request, options) {
  return new APIPromise($do156(client, request, options));
}
async function $do156(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteStaffMessagesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staffmessage/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteStaffMessages",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteStaffMessagesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteStaffMessagesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMessagesDeleteStaffMessages = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMessagesDeleteStaffMessages.ts
var args125, tool$staffMessagesDeleteStaffMessages;
var init_staffMessagesDeleteStaffMessages2 = __esm(() => {
  init_staffMessagesDeleteStaffMessages();
  init_operations();
  init_tools();
  args125 = {
    request: DeleteStaffMessagesRequest$inboundSchema
  };
  tool$staffMessagesDeleteStaffMessages = {
    name: "staff-messages-delete-staff-messages",
    description: `Delete a Staff Message


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args125,
    tool: async (client, args126, ctx) => {
      const [result2, apiCall] = await staffMessagesDeleteStaffMessages(client, args126.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMessagesGetStaffMessages.ts
function staffMessagesGetStaffMessages(client, request, options) {
  return new APIPromise($do157(client, request, options));
}
async function $do157(client, request, options) {
  const parsed = safeParse(request, (value) => GetStaffMessagesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staffmessage/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getStaffMessages",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetStaffMessagesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetStaffMessagesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMessagesGetStaffMessages = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMessagesGetStaffMessages.ts
var args126, tool$staffMessagesGetStaffMessages;
var init_staffMessagesGetStaffMessages2 = __esm(() => {
  init_staffMessagesGetStaffMessages();
  init_operations();
  init_tools();
  args126 = {
    request: GetStaffMessagesRequest$inboundSchema
  };
  tool$staffMessagesGetStaffMessages = {
    name: "staff-messages-get-staff-messages",
    description: `Retrieve a Staff Message`,
    args: args126,
    tool: async (client, args127, ctx) => {
      const [result2, apiCall] = await staffMessagesGetStaffMessages(client, args127.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMessagesListStaffMessages.ts
function staffMessagesListStaffMessages(client, options) {
  return new APIPromise($do158(client, options));
}
async function $do158(client, options) {
  const path = pathToFunc("/staffmessage.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listStaffMessages",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListStaffMessagesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListStaffMessagesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMessagesListStaffMessages = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMessagesListStaffMessages.ts
var tool$staffMessagesListStaffMessages;
var init_staffMessagesListStaffMessages2 = __esm(() => {
  init_staffMessagesListStaffMessages();
  init_tools();
  tool$staffMessagesListStaffMessages = {
    name: "staff-messages-list-staff-messages",
    description: `List all Staff Messages


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await staffMessagesListStaffMessages(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/staffMessagesUpdateStaffMessages.ts
function staffMessagesUpdateStaffMessages(client, request, options) {
  return new APIPromise($do159(client, request, options));
}
async function $do159(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateStaffMessagesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.StaffMessage, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/staffmessage/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateStaffMessages",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateStaffMessagesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateStaffMessagesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_staffMessagesUpdateStaffMessages = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/staffMessagesUpdateStaffMessages.ts
var args127, tool$staffMessagesUpdateStaffMessages;
var init_staffMessagesUpdateStaffMessages2 = __esm(() => {
  init_staffMessagesUpdateStaffMessages();
  init_operations();
  init_tools();
  args127 = {
    request: UpdateStaffMessagesRequest$inboundSchema
  };
  tool$staffMessagesUpdateStaffMessages = {
    name: "staff-messages-update-staff-messages",
    description: `Update a Staff Message`,
    args: args127,
    tool: async (client, args128, ctx) => {
      const [result2, apiCall] = await staffMessagesUpdateStaffMessages(client, args128.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/tasksCreateTasks.ts
function tasksCreateTasks(client, request, options) {
  return new APIPromise($do160(client, request, options));
}
async function $do160(client, request, options) {
  const parsed = safeParse(request, (value) => TaskInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/task.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createTasks",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateTasksResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateTasksResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_tasksCreateTasks = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/tasksCreateTasks.ts
var args128, tool$tasksCreateTasks;
var init_tasksCreateTasks2 = __esm(() => {
  init_tasksCreateTasks();
  init_components();
  init_tools();
  args128 = {
    request: TaskInput$inboundSchema
  };
  tool$tasksCreateTasks = {
    name: "tasks-create-tasks",
    description: `Create a new Task


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_tasks**.

			
			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args128,
    tool: async (client, args129, ctx) => {
      const [result2, apiCall] = await tasksCreateTasks(client, args129.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/tasksDeleteTasks.ts
function tasksDeleteTasks(client, request, options) {
  return new APIPromise($do161(client, request, options));
}
async function $do161(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteTasksRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/task/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteTasks",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteTasksResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteTasksResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_tasksDeleteTasks = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/tasksDeleteTasks.ts
var args129, tool$tasksDeleteTasks;
var init_tasksDeleteTasks2 = __esm(() => {
  init_tasksDeleteTasks();
  init_operations();
  init_tools();
  args129 = {
    request: DeleteTasksRequest$inboundSchema
  };
  tool$tasksDeleteTasks = {
    name: "tasks-delete-tasks",
    description: `Delete a Task


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_tasks**.

			`,
    args: args129,
    tool: async (client, args130, ctx) => {
      const [result2, apiCall] = await tasksDeleteTasks(client, args130.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/tasksGetTasks.ts
function tasksGetTasks(client, request, options) {
  return new APIPromise($do162(client, request, options));
}
async function $do162(client, request, options) {
  const parsed = safeParse(request, (value) => GetTasksRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/task/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getTasks",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetTasksResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetTasksResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_tasksGetTasks = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/tasksGetTasks.ts
var args130, tool$tasksGetTasks;
var init_tasksGetTasks2 = __esm(() => {
  init_tasksGetTasks();
  init_operations();
  init_tools();
  args130 = {
    request: GetTasksRequest$inboundSchema
  };
  tool$tasksGetTasks = {
    name: "tasks-get-tasks",
    description: `Retrieve a Task


			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_tasks**.

			`,
    args: args130,
    tool: async (client, args131, ctx) => {
      const [result2, apiCall] = await tasksGetTasks(client, args131.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/tasksListTasks.ts
function tasksListTasks(client, options) {
  return new APIPromise($do163(client, options));
}
async function $do163(client, options) {
  const path = pathToFunc("/task.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listTasks",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListTasksResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListTasksResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_tasksListTasks = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/tasksListTasks.ts
var tool$tasksListTasks;
var init_tasksListTasks2 = __esm(() => {
  init_tasksListTasks();
  init_tools();
  tool$tasksListTasks = {
    name: "tasks-list-tasks",
    description: `List all Tasks


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **read_tasks**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await tasksListTasks(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/tasksUpdateTasks.ts
function tasksUpdateTasks(client, request, options) {
  return new APIPromise($do164(client, request, options));
}
async function $do164(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateTasksRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Task, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/task/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateTasks",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateTasksResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateTasksResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_tasksUpdateTasks = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/tasksUpdateTasks.ts
var args131, tool$tasksUpdateTasks;
var init_tasksUpdateTasks2 = __esm(() => {
  init_tasksUpdateTasks();
  init_operations();
  init_tools();
  args131 = {
    request: UpdateTasksRequest$inboundSchema
  };
  tool$tasksUpdateTasks = {
    name: "tasks-update-tasks",
    description: `Update a Task


			
#### OAuth Scope
This endpoint requires the following OAuth scope **manage_tasks**.

			`,
    args: args131,
    tool: async (client, args132, ctx) => {
      const [result2, apiCall] = await tasksUpdateTasks(client, args132.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/taxRatesCreateTaxRates.ts
function taxRatesCreateTaxRates(client, request, options) {
  return new APIPromise($do165(client, request, options));
}
async function $do165(client, request, options) {
  const parsed = safeParse(request, (value) => TaxRateInput$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });
  const path = pathToFunc("/taxrate.json")();
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "createTaxRates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, CreateTaxRatesResponse$inboundSchema, {
    hdrs: true,
    key: "Result"
  }), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", CreateTaxRatesResponse$inboundSchema, {
    key: "Result"
  }))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_taxRatesCreateTaxRates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_components();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/taxRatesCreateTaxRates.ts
var args132, tool$taxRatesCreateTaxRates;
var init_taxRatesCreateTaxRates2 = __esm(() => {
  init_taxRatesCreateTaxRates();
  init_components();
  init_tools();
  args132 = {
    request: TaxRateInput$inboundSchema
  };
  tool$taxRatesCreateTaxRates = {
    name: "tax-rates-create-tax-rates",
    description: `Create a new Tax Rate


			
#### Record UUID
UUID is optional for record creation. If no UUID is supplied, a UUID will be automatically generated for the new record and returned in the response header as x-record-uuid.

			`,
    args: args132,
    tool: async (client, args133, ctx) => {
      const [result2, apiCall] = await taxRatesCreateTaxRates(client, args133.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value.result;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/taxRatesDeleteTaxRates.ts
function taxRatesDeleteTaxRates(client, request, options) {
  return new APIPromise($do166(client, request, options));
}
async function $do166(client, request, options) {
  const parsed = safeParse(request, (value) => DeleteTaxRatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/taxrate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "deleteTaxRates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, DeleteTaxRatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", DeleteTaxRatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_taxRatesDeleteTaxRates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/taxRatesDeleteTaxRates.ts
var args133, tool$taxRatesDeleteTaxRates;
var init_taxRatesDeleteTaxRates2 = __esm(() => {
  init_taxRatesDeleteTaxRates();
  init_operations();
  init_tools();
  args133 = {
    request: DeleteTaxRatesRequest$inboundSchema
  };
  tool$taxRatesDeleteTaxRates = {
    name: "tax-rates-delete-tax-rates",
    description: `Delete a Tax Rate


			
In ServiceM8, records are never deleted, but are archived. Archived records will remain accessible via the API as (active = 0), however will no longer be visible in UI. Archived records can be restored to active by setting the record active field to 1.

			`,
    args: args133,
    tool: async (client, args134, ctx) => {
      const [result2, apiCall] = await taxRatesDeleteTaxRates(client, args134.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/taxRatesGetTaxRates.ts
function taxRatesGetTaxRates(client, request, options) {
  return new APIPromise($do167(client, request, options));
}
async function $do167(client, request, options) {
  const parsed = safeParse(request, (value) => GetTaxRatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/taxrate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getTaxRates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetTaxRatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetTaxRatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_taxRatesGetTaxRates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/taxRatesGetTaxRates.ts
var args134, tool$taxRatesGetTaxRates;
var init_taxRatesGetTaxRates2 = __esm(() => {
  init_taxRatesGetTaxRates();
  init_operations();
  init_tools();
  args134 = {
    request: GetTaxRatesRequest$inboundSchema
  };
  tool$taxRatesGetTaxRates = {
    name: "tax-rates-get-tax-rates",
    description: `Retrieve a Tax Rate`,
    args: args134,
    tool: async (client, args135, ctx) => {
      const [result2, apiCall] = await taxRatesGetTaxRates(client, args135.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/taxRatesListTaxRates.ts
function taxRatesListTaxRates(client, options) {
  return new APIPromise($do168(client, options));
}
async function $do168(client, options) {
  const path = pathToFunc("/taxrate.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listTaxRates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListTaxRatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListTaxRatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_taxRatesListTaxRates = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/taxRatesListTaxRates.ts
var tool$taxRatesListTaxRates;
var init_taxRatesListTaxRates2 = __esm(() => {
  init_taxRatesListTaxRates();
  init_tools();
  tool$taxRatesListTaxRates = {
    name: "tax-rates-list-tax-rates",
    description: `List all Tax Rates


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await taxRatesListTaxRates(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/taxRatesUpdateTaxRates.ts
function taxRatesUpdateTaxRates(client, request, options) {
  return new APIPromise($do169(client, request, options));
}
async function $do169(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateTaxRatesRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.TaxRate, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/taxrate/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateTaxRates",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateTaxRatesResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateTaxRatesResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_taxRatesUpdateTaxRates = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/taxRatesUpdateTaxRates.ts
var args135, tool$taxRatesUpdateTaxRates;
var init_taxRatesUpdateTaxRates2 = __esm(() => {
  init_taxRatesUpdateTaxRates();
  init_operations();
  init_tools();
  args135 = {
    request: UpdateTaxRatesRequest$inboundSchema
  };
  tool$taxRatesUpdateTaxRates = {
    name: "tax-rates-update-tax-rates",
    description: `Update a Tax Rate`,
    args: args135,
    tool: async (client, args136, ctx) => {
      const [result2, apiCall] = await taxRatesUpdateTaxRates(client, args136.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/vendorsGetVendors.ts
function vendorsGetVendors(client, request, options) {
  return new APIPromise($do170(client, request, options));
}
async function $do170(client, request, options) {
  const parsed = safeParse(request, (value) => GetVendorsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/vendor/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getVendors",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, GetVendorsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", GetVendorsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_vendorsGetVendors = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/vendorsGetVendors.ts
var args136, tool$vendorsGetVendors;
var init_vendorsGetVendors2 = __esm(() => {
  init_vendorsGetVendors();
  init_operations();
  init_tools();
  args136 = {
    request: GetVendorsRequest$inboundSchema
  };
  tool$vendorsGetVendors = {
    name: "vendors-get-vendors",
    description: `Retrieve a Vendor

Vendor account information


			
#### OAuth Scope
This endpoint requires the following OAuth scope **vendor**.

			`,
    args: args136,
    tool: async (client, args137, ctx) => {
      const [result2, apiCall] = await vendorsGetVendors(client, args137.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/vendorsListVendors.ts
function vendorsListVendors(client, options) {
  return new APIPromise($do171(client, options));
}
async function $do171(client, options) {
  const path = pathToFunc("/vendor.json")();
  const headers = new Headers(compactMap({
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "listVendors",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path,
    headers,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, ListVendorsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", ListVendorsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_vendorsListVendors = __esm(() => {
  init_matchers();
  init_primitives();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/vendorsListVendors.ts
var tool$vendorsListVendors;
var init_vendorsListVendors2 = __esm(() => {
  init_vendorsListVendors();
  init_tools();
  tool$vendorsListVendors = {
    name: "vendors-list-vendors",
    description: `List all Vendors

Vendor account information


			
#### Filtering
This endpoint supports result filtering. For more information on how to filter this request, [go here](/docs/filtering).
			
			
#### OAuth Scope
This endpoint requires the following OAuth scope **vendor**.

			`,
    tool: async (client, ctx) => {
      const [result2, apiCall] = await vendorsListVendors(client, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/funcs/vendorsUpdateVendors.ts
function vendorsUpdateVendors(client, request, options) {
  return new APIPromise($do172(client, request, options));
}
async function $do172(client, request, options) {
  const parsed = safeParse(request, (value) => UpdateVendorsRequest$outboundSchema.parse(value), "Input validation failed");
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.Vendor, { explode: true });
  const pathParams = {
    uuid: encodeSimple("uuid", payload.uuid, {
      explode: false,
      charEncoding: "percent"
    })
  };
  const path = pathToFunc("/vendor/{uuid}.json")(pathParams);
  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json"
  }));
  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);
  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "updateVendors",
    oAuth2Scopes: [],
    resolvedSecurity: requestSecurity,
    securitySource: client._options.security,
    retryConfig: options?.retries || client._options.retryConfig || {
      strategy: "backoff",
      backoff: {
        initialInterval: 500,
        maxInterval: 60000,
        exponent: 1.5,
        maxElapsedTime: 3600000
      },
      retryConnectionErrors: true
    },
    retryCodes: options?.retryCodes || ["5XX"]
  };
  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path,
    headers,
    body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;
  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;
  const responseFields = {
    HttpMeta: { Response: response, Request: req }
  };
  const [result2] = await match(json(200, UpdateVendorsResponse$inboundSchema), jsonErr(400, ErrorT$inboundSchema2), fail("4XX"), fail("5XX"), json("default", UpdateVendorsResponse$inboundSchema))(response, { extraFields: responseFields });
  if (!result2.ok) {
    return [result2, { status: "complete", request: req, response }];
  }
  return [result2, { status: "complete", request: req, response }];
}
var init_vendorsUpdateVendors = __esm(() => {
  init_encodings();
  init_matchers();
  init_primitives();
  init_schemas();
  init_security();
  init_url();
  init_errors();
  init_operations();
  init_async();
});

// src/mcp-server/tools/vendorsUpdateVendors.ts
var args137, tool$vendorsUpdateVendors;
var init_vendorsUpdateVendors2 = __esm(() => {
  init_vendorsUpdateVendors();
  init_operations();
  init_tools();
  args137 = {
    request: UpdateVendorsRequest$inboundSchema
  };
  tool$vendorsUpdateVendors = {
    name: "vendors-update-vendors",
    description: `Update a Vendor

Vendor account information

`,
    args: args137,
    tool: async (client, args138, ctx) => {
      const [result2, apiCall] = await vendorsUpdateVendors(client, args138.request, { fetchOptions: { signal: ctx.signal } }).$inspect();
      if (!result2.ok) {
        return {
          content: [{ type: "text", text: result2.error.message }],
          isError: true
        };
      }
      const value = result2.value;
      return formatResult(value, apiCall);
    }
  };
});

// src/mcp-server/server.ts
function createMCPServer(deps) {
  const server = new McpServer({
    name: "ServiceM8",
    version: "0.3.8"
  });
  const client = new ServiceM8Core({
    security: deps.security,
    serverURL: deps.serverURL,
    serverIdx: deps.serverIdx
  });
  const scopes = new Set(deps.scopes);
  const allowedTools = deps.allowedTools && new Set(deps.allowedTools);
  const tool = createRegisterTool(deps.logger, server, client, scopes, allowedTools);
  const resource = createRegisterResource(deps.logger, server, client, scopes);
  const resourceTemplate = createRegisterResourceTemplate(deps.logger, server, client, scopes);
  const prompt = createRegisterPrompt(deps.logger, server, client, scopes);
  const register = { tool, resource, resourceTemplate, prompt };
  tool(tool$allocationWindowsListAllocationWindows);
  tool(tool$allocationWindowsCreateAllocationWindows);
  tool(tool$allocationWindowsGetAllocationWindows);
  tool(tool$allocationWindowsUpdateAllocationWindows);
  tool(tool$allocationWindowsDeleteAllocationWindows);
  tool(tool$assetsListAssets);
  tool(tool$assetsGetAssets);
  tool(tool$assetsUpdateAssets);
  tool(tool$assetsDeleteAssets);
  tool(tool$assetTypesListAssetTypes);
  tool(tool$assetTypesCreateAssetTypes);
  tool(tool$assetTypesGetAssetTypes);
  tool(tool$assetTypesUpdateAssetTypes);
  tool(tool$assetTypesDeleteAssetTypes);
  tool(tool$assetTypeFieldsListAssetTypeFields);
  tool(tool$assetTypeFieldsCreateAssetTypeFields);
  tool(tool$assetTypeFieldsGetAssetTypeFields);
  tool(tool$assetTypeFieldsUpdateAssetTypeFields);
  tool(tool$assetTypeFieldsDeleteAssetTypeFields);
  tool(tool$attachmentsListAttachments);
  tool(tool$attachmentsCreateAttachments);
  tool(tool$attachmentsGetAttachments);
  tool(tool$attachmentsUpdateAttachments);
  tool(tool$attachmentsDeleteAttachments);
  tool(tool$badgesListBadges);
  tool(tool$badgesCreateBadges);
  tool(tool$badgesGetBadges);
  tool(tool$badgesUpdateBadges);
  tool(tool$badgesDeleteBadges);
  tool(tool$categoriesListCategories);
  tool(tool$categoriesCreateCategories);
  tool(tool$categoriesGetCategories);
  tool(tool$categoriesUpdateCategories);
  tool(tool$categoriesDeleteCategories);
  tool(tool$clientsListClients);
  tool(tool$clientsCreateClients);
  tool(tool$clientsGetClients);
  tool(tool$clientsUpdateClients);
  tool(tool$clientsDeleteClients);
  tool(tool$companyContactsListCompanyContacts);
  tool(tool$companyContactsCreateCompanyContacts);
  tool(tool$companyContactsGetCompanyContacts);
  tool(tool$companyContactsUpdateCompanyContacts);
  tool(tool$companyContactsDeleteCompanyContacts);
  tool(tool$emailTemplatesListEmailTemplates);
  tool(tool$emailTemplatesCreateEmailTemplates);
  tool(tool$emailTemplatesGetEmailTemplates);
  tool(tool$emailTemplatesUpdateEmailTemplates);
  tool(tool$emailTemplatesDeleteEmailTemplates);
  tool(tool$feedbackListFeedback);
  tool(tool$feedbackCreateFeedback);
  tool(tool$feedbackGetFeedback);
  tool(tool$feedbackUpdateFeedback);
  tool(tool$feedbackDeleteFeedback);
  tool(tool$formsListForms);
  tool(tool$formsCreateForms);
  tool(tool$formsGetForms);
  tool(tool$formsUpdateForms);
  tool(tool$formsDeleteForms);
  tool(tool$formFieldsListFormFields);
  tool(tool$formFieldsCreateFormFields);
  tool(tool$formFieldsGetFormFields);
  tool(tool$formFieldsUpdateFormFields);
  tool(tool$formFieldsDeleteFormFields);
  tool(tool$formResponsesListFormResponses);
  tool(tool$formResponsesCreateFormResponses);
  tool(tool$formResponsesGetFormResponses);
  tool(tool$formResponsesUpdateFormResponses);
  tool(tool$formResponsesDeleteFormResponses);
  tool(tool$jobsListJobs);
  tool(tool$jobsCreateJobs);
  tool(tool$jobsGetJobs);
  tool(tool$jobsUpdateJobs);
  tool(tool$jobsDeleteJobs);
  tool(tool$jobActivitiesListJobActivities);
  tool(tool$jobActivitiesCreateJobActivities);
  tool(tool$jobActivitiesGetJobActivities);
  tool(tool$jobActivitiesUpdateJobActivities);
  tool(tool$jobActivitiesDeleteJobActivities);
  tool(tool$jobAllocationsListJobAllocations);
  tool(tool$jobAllocationsCreateJobAllocations);
  tool(tool$jobAllocationsGetJobAllocations);
  tool(tool$jobAllocationsUpdateJobAllocations);
  tool(tool$jobAllocationsDeleteJobAllocations);
  tool(tool$jobChecklistsListJobChecklists);
  tool(tool$jobChecklistsCreateJobChecklists);
  tool(tool$jobChecklistsGetJobChecklists);
  tool(tool$jobChecklistsUpdateJobChecklists);
  tool(tool$jobChecklistsDeleteJobChecklists);
  tool(tool$jobContactsListJobContacts);
  tool(tool$jobContactsCreateJobContacts);
  tool(tool$jobContactsGetJobContacts);
  tool(tool$jobContactsUpdateJobContacts);
  tool(tool$jobContactsDeleteJobContacts);
  tool(tool$jobMaterialsListJobMaterials);
  tool(tool$jobMaterialsCreateJobMaterials);
  tool(tool$jobMaterialsGetJobMaterials);
  tool(tool$jobMaterialsUpdateJobMaterials);
  tool(tool$jobMaterialsDeleteJobMaterials);
  tool(tool$jobMaterialBundlesListJobMaterialBundles);
  tool(tool$jobMaterialBundlesCreateJobMaterialBundles);
  tool(tool$jobMaterialBundlesGetJobMaterialBundles);
  tool(tool$jobMaterialBundlesUpdateJobMaterialBundles);
  tool(tool$jobMaterialBundlesDeleteJobMaterialBundles);
  tool(tool$jobPaymentsListJobPayments);
  tool(tool$jobPaymentsCreateJobPayments);
  tool(tool$jobPaymentsGetJobPayments);
  tool(tool$jobPaymentsUpdateJobPayments);
  tool(tool$jobPaymentsDeleteJobPayments);
  tool(tool$knowledgeArticlesListKnowledgeArticles);
  tool(tool$knowledgeArticlesCreateKnowledgeArticles);
  tool(tool$knowledgeArticlesGetKnowledgeArticles);
  tool(tool$knowledgeArticlesUpdateKnowledgeArticles);
  tool(tool$knowledgeArticlesDeleteKnowledgeArticles);
  tool(tool$locationsListLocations);
  tool(tool$locationsCreateLocations);
  tool(tool$locationsGetLocations);
  tool(tool$locationsUpdateLocations);
  tool(tool$locationsDeleteLocations);
  tool(tool$materialsListMaterials);
  tool(tool$materialsCreateMaterials);
  tool(tool$materialsGetMaterials);
  tool(tool$materialsUpdateMaterials);
  tool(tool$materialsDeleteMaterials);
  tool(tool$bundlesListBundles);
  tool(tool$bundlesCreateBundles);
  tool(tool$bundlesGetBundles);
  tool(tool$bundlesUpdateBundles);
  tool(tool$bundlesDeleteBundles);
  tool(tool$notesListNotes);
  tool(tool$notesCreateNotes);
  tool(tool$notesGetNotes);
  tool(tool$notesUpdateNotes);
  tool(tool$notesDeleteNotes);
  tool(tool$jobQueuesListJobQueues);
  tool(tool$jobQueuesCreateJobQueues);
  tool(tool$jobQueuesGetJobQueues);
  tool(tool$jobQueuesUpdateJobQueues);
  tool(tool$jobQueuesDeleteJobQueues);
  tool(tool$securityRolesListSecurityRoles);
  tool(tool$securityRolesCreateSecurityRoles);
  tool(tool$securityRolesGetSecurityRoles);
  tool(tool$securityRolesUpdateSecurityRoles);
  tool(tool$securityRolesDeleteSecurityRoles);
  tool(tool$smsTemplatesListSMSTemplates);
  tool(tool$smsTemplatesCreateSMSTemplates);
  tool(tool$smsTemplatesGetSMSTemplates);
  tool(tool$smsTemplatesUpdateSMSTemplates);
  tool(tool$smsTemplatesDeleteSMSTemplates);
  tool(tool$staffMembersListStaffMembers);
  tool(tool$staffMembersCreateStaffMembers);
  tool(tool$staffMembersGetStaffMembers);
  tool(tool$staffMembersUpdateStaffMembers);
  tool(tool$staffMembersDeleteStaffMembers);
  tool(tool$staffMessagesListStaffMessages);
  tool(tool$staffMessagesCreateStaffMessages);
  tool(tool$staffMessagesGetStaffMessages);
  tool(tool$staffMessagesUpdateStaffMessages);
  tool(tool$staffMessagesDeleteStaffMessages);
  tool(tool$tasksListTasks);
  tool(tool$tasksCreateTasks);
  tool(tool$tasksGetTasks);
  tool(tool$tasksUpdateTasks);
  tool(tool$tasksDeleteTasks);
  tool(tool$taxRatesListTaxRates);
  tool(tool$taxRatesCreateTaxRates);
  tool(tool$taxRatesGetTaxRates);
  tool(tool$taxRatesUpdateTaxRates);
  tool(tool$taxRatesDeleteTaxRates);
  tool(tool$vendorsListVendors);
  tool(tool$vendorsGetVendors);
  tool(tool$vendorsUpdateVendors);
  return server;
}
var init_server2 = __esm(() => {
  init_mcp();
  init_core();
  init_resources();
  init_tools();
  init_allocationWindowsCreateAllocationWindows2();
  init_allocationWindowsDeleteAllocationWindows2();
  init_allocationWindowsGetAllocationWindows2();
  init_allocationWindowsListAllocationWindows2();
  init_allocationWindowsUpdateAllocationWindows2();
  init_assetsDeleteAssets2();
  init_assetsGetAssets2();
  init_assetsListAssets2();
  init_assetsUpdateAssets2();
  init_assetTypeFieldsCreateAssetTypeFields2();
  init_assetTypeFieldsDeleteAssetTypeFields2();
  init_assetTypeFieldsGetAssetTypeFields2();
  init_assetTypeFieldsListAssetTypeFields2();
  init_assetTypeFieldsUpdateAssetTypeFields2();
  init_assetTypesCreateAssetTypes2();
  init_assetTypesDeleteAssetTypes2();
  init_assetTypesGetAssetTypes2();
  init_assetTypesListAssetTypes2();
  init_assetTypesUpdateAssetTypes2();
  init_attachmentsCreateAttachments2();
  init_attachmentsDeleteAttachments2();
  init_attachmentsGetAttachments2();
  init_attachmentsListAttachments2();
  init_attachmentsUpdateAttachments2();
  init_badgesCreateBadges2();
  init_badgesDeleteBadges2();
  init_badgesGetBadges2();
  init_badgesListBadges2();
  init_badgesUpdateBadges2();
  init_bundlesCreateBundles2();
  init_bundlesDeleteBundles2();
  init_bundlesGetBundles2();
  init_bundlesListBundles2();
  init_bundlesUpdateBundles2();
  init_categoriesCreateCategories2();
  init_categoriesDeleteCategories2();
  init_categoriesGetCategories2();
  init_categoriesListCategories2();
  init_categoriesUpdateCategories2();
  init_clientsCreateClients2();
  init_clientsDeleteClients2();
  init_clientsGetClients2();
  init_clientsListClients2();
  init_clientsUpdateClients2();
  init_companyContactsCreateCompanyContacts2();
  init_companyContactsDeleteCompanyContacts2();
  init_companyContactsGetCompanyContacts2();
  init_companyContactsListCompanyContacts2();
  init_companyContactsUpdateCompanyContacts2();
  init_emailTemplatesCreateEmailTemplates2();
  init_emailTemplatesDeleteEmailTemplates2();
  init_emailTemplatesGetEmailTemplates2();
  init_emailTemplatesListEmailTemplates2();
  init_emailTemplatesUpdateEmailTemplates2();
  init_feedbackCreateFeedback2();
  init_feedbackDeleteFeedback2();
  init_feedbackGetFeedback2();
  init_feedbackListFeedback2();
  init_feedbackUpdateFeedback2();
  init_formFieldsCreateFormFields2();
  init_formFieldsDeleteFormFields2();
  init_formFieldsGetFormFields2();
  init_formFieldsListFormFields2();
  init_formFieldsUpdateFormFields2();
  init_formResponsesCreateFormResponses2();
  init_formResponsesDeleteFormResponses2();
  init_formResponsesGetFormResponses2();
  init_formResponsesListFormResponses2();
  init_formResponsesUpdateFormResponses2();
  init_formsCreateForms2();
  init_formsDeleteForms2();
  init_formsGetForms2();
  init_formsListForms2();
  init_formsUpdateForms2();
  init_jobActivitiesCreateJobActivities2();
  init_jobActivitiesDeleteJobActivities2();
  init_jobActivitiesGetJobActivities2();
  init_jobActivitiesListJobActivities2();
  init_jobActivitiesUpdateJobActivities2();
  init_jobAllocationsCreateJobAllocations2();
  init_jobAllocationsDeleteJobAllocations2();
  init_jobAllocationsGetJobAllocations2();
  init_jobAllocationsListJobAllocations2();
  init_jobAllocationsUpdateJobAllocations2();
  init_jobChecklistsCreateJobChecklists2();
  init_jobChecklistsDeleteJobChecklists2();
  init_jobChecklistsGetJobChecklists2();
  init_jobChecklistsListJobChecklists2();
  init_jobChecklistsUpdateJobChecklists2();
  init_jobContactsCreateJobContacts2();
  init_jobContactsDeleteJobContacts2();
  init_jobContactsGetJobContacts2();
  init_jobContactsListJobContacts2();
  init_jobContactsUpdateJobContacts2();
  init_jobMaterialBundlesCreateJobMaterialBundles2();
  init_jobMaterialBundlesDeleteJobMaterialBundles2();
  init_jobMaterialBundlesGetJobMaterialBundles2();
  init_jobMaterialBundlesListJobMaterialBundles2();
  init_jobMaterialBundlesUpdateJobMaterialBundles2();
  init_jobMaterialsCreateJobMaterials2();
  init_jobMaterialsDeleteJobMaterials2();
  init_jobMaterialsGetJobMaterials2();
  init_jobMaterialsListJobMaterials2();
  init_jobMaterialsUpdateJobMaterials2();
  init_jobPaymentsCreateJobPayments2();
  init_jobPaymentsDeleteJobPayments2();
  init_jobPaymentsGetJobPayments2();
  init_jobPaymentsListJobPayments2();
  init_jobPaymentsUpdateJobPayments2();
  init_jobQueuesCreateJobQueues2();
  init_jobQueuesDeleteJobQueues2();
  init_jobQueuesGetJobQueues2();
  init_jobQueuesListJobQueues2();
  init_jobQueuesUpdateJobQueues2();
  init_jobsCreateJobs2();
  init_jobsDeleteJobs2();
  init_jobsGetJobs2();
  init_jobsListJobs2();
  init_jobsUpdateJobs2();
  init_knowledgeArticlesCreateKnowledgeArticles2();
  init_knowledgeArticlesDeleteKnowledgeArticles2();
  init_knowledgeArticlesGetKnowledgeArticles2();
  init_knowledgeArticlesListKnowledgeArticles2();
  init_knowledgeArticlesUpdateKnowledgeArticles2();
  init_locationsCreateLocations2();
  init_locationsDeleteLocations2();
  init_locationsGetLocations2();
  init_locationsListLocations2();
  init_locationsUpdateLocations2();
  init_materialsCreateMaterials2();
  init_materialsDeleteMaterials2();
  init_materialsGetMaterials2();
  init_materialsListMaterials2();
  init_materialsUpdateMaterials2();
  init_notesCreateNotes2();
  init_notesDeleteNotes2();
  init_notesGetNotes2();
  init_notesListNotes2();
  init_notesUpdateNotes2();
  init_securityRolesCreateSecurityRoles2();
  init_securityRolesDeleteSecurityRoles2();
  init_securityRolesGetSecurityRoles2();
  init_securityRolesListSecurityRoles2();
  init_securityRolesUpdateSecurityRoles2();
  init_smsTemplatesCreateSMSTemplates2();
  init_smsTemplatesDeleteSMSTemplates2();
  init_smsTemplatesGetSMSTemplates2();
  init_smsTemplatesListSMSTemplates2();
  init_smsTemplatesUpdateSMSTemplates2();
  init_staffMembersCreateStaffMembers2();
  init_staffMembersDeleteStaffMembers2();
  init_staffMembersGetStaffMembers2();
  init_staffMembersListStaffMembers2();
  init_staffMembersUpdateStaffMembers2();
  init_staffMessagesCreateStaffMessages2();
  init_staffMessagesDeleteStaffMessages2();
  init_staffMessagesGetStaffMessages2();
  init_staffMessagesListStaffMessages2();
  init_staffMessagesUpdateStaffMessages2();
  init_tasksCreateTasks2();
  init_tasksDeleteTasks2();
  init_tasksGetTasks2();
  init_tasksListTasks2();
  init_tasksUpdateTasks2();
  init_taxRatesCreateTaxRates2();
  init_taxRatesDeleteTaxRates2();
  init_taxRatesGetTaxRates2();
  init_taxRatesListTaxRates2();
  init_taxRatesUpdateTaxRates2();
  init_vendorsGetVendors2();
  init_vendorsListVendors2();
  init_vendorsUpdateVendors2();
});

// src/mcp-server/cli/start/impl.ts
var exports_impl = {};
__export(exports_impl, {
  main: () => main
});
async function main(flags) {
  flags.env?.forEach(([key, value]) => {
    process.env[key] = value;
  });
  switch (flags.transport) {
    case "stdio":
      await startStdio(flags);
      break;
    case "sse":
      await startSSE(flags);
      break;
    default:
      throw new Error(`Invalid transport: ${flags.transport}`);
  }
}
async function startStdio(flags) {
  const logger = createConsoleLogger(flags["log-level"]);
  const transport = new StdioServerTransport;
  const server = createMCPServer({
    logger,
    allowedTools: flags.tool,
    scopes: flags.scope,
    security: { oauth2: flags.oauth2, apiKeyAuth: flags["api-key-auth"] },
    serverURL: flags["server-url"],
    serverIdx: flags["server-index"]
  });
  await server.connect(transport);
  const abort = async () => {
    await server.close();
    process.exit(0);
  };
  process.on("SIGTERM", abort);
  process.on("SIGINT", abort);
}
async function startSSE(flags) {
  const logger = createConsoleLogger(flags["log-level"]);
  const app = import_express.default();
  const mcpServer = createMCPServer({
    logger,
    allowedTools: flags.tool,
    scopes: flags.scope,
    security: { oauth2: flags.oauth2, apiKeyAuth: flags["api-key-auth"] },
    serverURL: flags["server-url"],
    serverIdx: flags["server-index"]
  });
  let transport;
  const controller = new AbortController;
  app.get("/sse", async (_req, res) => {
    transport = new SSEServerTransport("/message", res);
    await mcpServer.connect(transport);
    mcpServer.server.onclose = async () => {
      res.end();
    };
  });
  app.post("/message", async (req, res) => {
    if (!transport) {
      throw new Error("Server transport not initialized");
    }
    await transport.handlePostMessage(req, res);
  });
  const httpServer = app.listen(flags.port, "0.0.0.0", () => {
    const ha = httpServer.address();
    const host = typeof ha === "string" ? ha : `${ha?.address}:${ha?.port}`;
    logger.info("MCP HTTP server started", { host });
  });
  let closing = false;
  controller.signal.addEventListener("abort", async () => {
    if (closing) {
      logger.info("Received second signal. Forcing shutdown.");
      process.exit(1);
    }
    closing = true;
    logger.info("Shutting down MCP server");
    await mcpServer.close();
    logger.info("Shutting down HTTP server");
    const timer = setTimeout(() => {
      logger.info("Forcing shutdown");
      process.exit(1);
    }, 5000);
    httpServer.close(() => {
      clearTimeout(timer);
      logger.info("Graceful shutdown complete");
      process.exit(0);
    });
  });
  const abort = () => controller.abort();
  process.on("SIGTERM", abort);
  process.on("SIGINT", abort);
}
var import_express;
var init_impl = __esm(() => {
  init_sse();
  init_stdio2();
  import_express = __toESM(require_express2(), 1);
  init_console_logger();
  init_server2();
});

// node_modules/@stricli/core/dist/index.js
function K(e, t) {
  let n = e.env?.[t];
  return typeof n == "string" && n !== "0";
}
var b = { UnknownCommand: -5, InvalidArgument: -4, ContextLoadError: -3, CommandLoadError: -2, InternalError: -1, Success: 0, CommandRunError: 1 };
function I(e) {
  return e.replace(/-./g, (t) => t[1].toUpperCase());
}
function A(e) {
  return Array.from(e).map((t, n) => {
    let a = t.toUpperCase(), r = t.toLowerCase();
    return n === 0 || a !== t || a === r ? t : `-${r}`;
  }).join("");
}
function ve(e) {
  let t = new Map;
  return { get: (...n) => t.get(n.join(",")) ?? e, set: (n, ...a) => {
    t.set(a.join(","), n);
  } };
}
function Xe(e, t, n) {
  let { threshold: a, weights: r } = n;
  if (e === t)
    return 0;
  let i = Math.abs(e.length - t.length);
  if (typeof a == "number" && i > a)
    return 1 / 0;
  let o = ve(1 / 0);
  o.set(0, -1, -1);
  for (let s = 0;s < t.length; ++s)
    o.set((s + 1) * r.insertion, -1, s);
  for (let s = 0;s < e.length; ++s)
    o.set((s + 1) * r.deletion, s, -1);
  let d = -1 / 0;
  for (let s = 0;s < e.length; ++s) {
    let u = 1 / 0;
    for (let l = 0;l <= t.length - 1; ++l) {
      let p = e[s] === t[l] ? 0 : 1, c = [o.get(s - 1, l) + r.deletion, o.get(s, l - 1) + r.insertion, o.get(s - 1, l - 1) + p * r.substitution];
      e[s] === t[l - 1] && e[s - 1] === t[l] && c.push(o.get(s - 2, l - 2) + p * r.transposition);
      let f = Math.min(...c);
      o.set(f, s, l), f < u && (u = f);
    }
    if (u > a) {
      if (d > a)
        return 1 / 0;
      d = u;
    } else
      d = -1 / 0;
  }
  let m = o.get(e.length - 1, t.length - 1);
  return m > a ? 1 / 0 : m;
}
function we(e, t, n) {
  let a = e[1] - t[1];
  if (a !== 0)
    return a;
  let r = e[0].startsWith(n), i = t[0].startsWith(n);
  return r && !i ? -1 : !r && i ? 1 : e[0].localeCompare(t[0]);
}
function D(e, t, n) {
  let a = t.map((i) => [i, Xe(e, i, n)]).filter(([, i]) => i <= n.threshold), r = Math.min(...a.map(([, i]) => i));
  return a.filter(([, i]) => i === r).sort((i, o) => we(i, o, e)).map(([i]) => i);
}
var x = class extends Error {
};
function q(e) {
  return e instanceof Error ? e.stack ?? String(e) : String(e);
}
function $e(e, t) {
  let n = [], a = Math.max(e.length, t.length);
  for (let r = 0;r < a; ++r)
    n[r] = Math.max(e[r], t[r]);
  return n;
}
function $(e, t) {
  if (e.length === 0)
    return [];
  let n = Array(Math.max(...e.map((r) => r.length))).fill(0, 0), a = e.reduce((r, i) => {
    let o = i.map((d) => d.length);
    return $e(r, o);
  }, n);
  return e.map((r) => {
    let i = (r[0] ?? "").padEnd(a[0]);
    return r.slice(1).reduce((o, d, m, s) => {
      let u = s.length === m + 1 ? d : d.padEnd(a[m + 1]);
      return [...o, t?.[m] ?? " ", u];
    }, [i]).join("").trimEnd();
  });
}
function V(e, t) {
  if (e.length <= 1)
    return e[0] ?? "";
  if (e.length === 2)
    return e.join(` ${t.conjunction} `);
  let n = e.slice(0, e.length - 1).join(", ");
  return t.serialComma && (n += ","), [n, t.conjunction, e[e.length - 1]].join(" ");
}
function Le(e, t) {
  return e.reduce((n, a) => {
    let r = t(a), i = n[r] ?? [];
    return i.push(a), n[r] = i, n;
  }, {});
}
function me(e, t) {
  return Le(e, (n) => n[t]);
}
async function z(e) {
  let t = await Promise.allSettled(e), n = me(t, "status");
  return n.rejected && n.rejected.length > 0 ? { status: "rejected", reasons: n.rejected.map((a) => a.reason) } : { status: "fulfilled", value: n.fulfilled?.map((a) => a.value) ?? [] };
}
var Ie = new Set(["true", "t", "yes", "y", "on", "1"]);
var De = new Set(["false", "f", "no", "n", "off", "0"]);
var re = (e) => {
  let t = e.toLowerCase();
  if (Ie.has(t))
    return true;
  if (De.has(t))
    return false;
  throw new SyntaxError(`Cannot convert ${e} to a boolean`);
};
var oe = (e) => {
  let t = Number(e);
  if (Number.isNaN(t))
    throw new SyntaxError(`Cannot convert ${e} to a number`);
  return t;
};
var h = class extends x {
  _brand;
};
function se(e, t) {
  let n = e.constructor.name, a = t[n];
  return a ? a(e) : e.message;
}
function Me(e, t, n) {
  return Object.fromEntries(Object.entries(t).map(([a, r]) => {
    let i = r, o = e[i];
    if (!o) {
      let d = v(i, n);
      throw new L(d, [], a);
    }
    return [a, [i, o]];
  }));
}
var L = class extends h {
  input;
  corrections;
  aliasName;
  constructor(t, n, a) {
    let r = `No flag registered for --${t}`;
    if (a)
      r += ` (aliased from -${a})`;
    else if (n.length > 0) {
      let i = V(n.map((o) => `--${o}`), { kind: "conjunctive", conjunction: "or", serialComma: true });
      r += `, did you mean ${i}?`;
    }
    super(r), this.input = t, this.corrections = n, this.aliasName = a;
  }
};
var G = class extends h {
  input;
  constructor(t) {
    super(`No alias registered for -${t}`), this.input = t;
  }
};
function ae(e, t) {
  return e.placeholder ? e.placeholder : typeof t == "number" ? `arg${t}` : "args";
}
function v(e, t) {
  return t === "allow-kebab-for-camel" ? A(e) : e;
}
var j = class extends h {
  externalFlagNameOrPlaceholder;
  input;
  exception;
  constructor(t, n, a) {
    super(`Failed to parse "${n}" for ${t}: ${a instanceof Error ? a.message : String(a)}`), this.externalFlagNameOrPlaceholder = t, this.input = n, this.exception = a;
  }
};
function M(e, t, n, a) {
  try {
    return t.parse.call(a, n);
  } catch (r) {
    throw new j(e, n, r);
  }
}
var W = class extends h {
  externalFlagName;
  input;
  values;
  constructor(t, n, a, r) {
    let i = `Expected "${n}" to be one of (${a.join("|")})`;
    if (r.length > 0) {
      let o = V(r.map((d) => `"${d}"`), { kind: "conjunctive", conjunction: "or", serialComma: true });
      i += `, did you mean ${o}?`;
    }
    super(i), this.externalFlagName = t, this.input = n, this.values = a;
  }
};
var X = class extends h {
  externalFlagName;
  nextFlagName;
  constructor(t, n) {
    let a = `Expected input for flag --${t}`;
    n && (a += ` but encountered --${n} instead`), super(a), this.externalFlagName = t, this.nextFlagName = n;
  }
};
var H = class extends h {
  expectedCount;
  input;
  constructor(t, n) {
    super(`Too many arguments, expected ${t} but encountered "${n}"`), this.expectedCount = t, this.input = n;
  }
};
var _ = class extends h {
  placeholder;
  limit;
  constructor(t, n) {
    let a;
    n ? (a = `Expected at least ${n[0]} argument(s) for ${t}`, n[1] === 0 ? a += " but found none" : a += ` but only found ${n[1]}`) : a = `Expected argument for ${t}`, super(a), this.placeholder = t, this.limit = n;
  }
};
function de(e) {
  if (e.startsWith("no") && e.length > 2) {
    if (e[2] === "-")
      return e.slice(4);
    let t = e[2], n = t.toUpperCase();
    return t !== n ? undefined : t.toLowerCase() + e.slice(3);
  }
}
function pe(e, t, n) {
  let a = e, r = t[a];
  if (!r) {
    let o = de(a);
    if (o && (r = t[o], r && r.kind == "boolean"))
      return { namedFlag: [o, r], negated: true };
  }
  let i = I(e);
  if (n.caseStyle === "allow-kebab-for-camel" && !r) {
    if (r = t[i], r)
      return { namedFlag: [i, r] };
    let o = de(i);
    if (o && (r = t[o], r && r.kind == "boolean"))
      return { namedFlag: [o, r], negated: true };
  }
  if (!r) {
    if (i in t)
      throw new L(e, [i]);
    let o = A(e);
    if (o in t)
      throw new L(e, [o]);
    let d = D(a, Object.keys(t), n.distanceOptions);
    throw new L(e, d);
  }
  return { namedFlag: [a, r] };
}
function ue(e) {
  return e.namedFlag[1].kind === "boolean" || e.namedFlag[1].kind === "counter";
}
var ce = /^-([a-z]+)$/i;
var Ge = /^--([a-z][a-z-]+)$/i;
function je(e, t, n, a) {
  let r = ce.exec(e);
  if (r) {
    let o = r[1];
    return Array.from(o).map((d) => {
      let m = d, s = n[m];
      if (!s)
        throw new G(m);
      return { namedFlag: s };
    });
  }
  let i = Ge.exec(e);
  if (i) {
    let o = i[1];
    return [pe(o, t, a)];
  }
  return [];
}
var Ue = /^--([a-z][a-z-.\d_]+)=(.+)$/i;
var qe = /^-([a-z])=(.+)$/i;
var J = class extends h {
  externalFlagName;
  valueText;
  constructor(t, n) {
    super(`Cannot negate flag --${t} and pass "${n}" as value`), this.externalFlagName = t, this.valueText = n;
  }
};
function Ve(e, t, n, a) {
  let r = Ue.exec(e);
  if (r) {
    let o = r[1], { namedFlag: d, negated: m } = pe(o, t, a), s = r[2];
    if (m)
      throw new J(o, s);
    return [d, s];
  }
  let i = qe.exec(e);
  if (i) {
    let o = i[1], d = n[o];
    if (!d)
      throw new G(o);
    let m = i[2];
    return [d, m];
  }
}
async function We(e, t, n, a, r) {
  if (!n) {
    if ("default" in t && typeof t.default < "u")
      return t.kind === "boolean" || t.kind === "enum" ? t.default : M(e, t, t.default, r);
    if (t.optional)
      return;
    if (t.kind === "boolean")
      return false;
    if (t.kind === "counter")
      return 0;
    throw new X(e);
  }
  if (t.kind === "counter")
    return n.reduce((o, d) => {
      try {
        return o + oe.call(r, d);
      } catch (m) {
        throw new j(e, d, m);
      }
    }, 0);
  if ("variadic" in t && t.variadic) {
    if (t.kind === "enum") {
      for (let o of n)
        if (!t.values.includes(o)) {
          let d = D(o, t.values, a.distanceOptions);
          throw new W(e, o, t.values, d);
        }
      return n;
    }
    return Promise.all(n.map((o) => M(e, t, o, r)));
  }
  let i = n[0];
  if (t.kind === "boolean")
    try {
      return re.call(r, i);
    } catch (o) {
      throw new j(e, i, o);
    }
  if (t.kind === "enum") {
    if (!t.values.includes(i)) {
      let o = D(i, t.values, a.distanceOptions);
      throw new W(e, i, t.values, o);
    }
    return i;
  }
  return M(e, t, i, r);
}
var Y = class extends h {
  externalFlagName;
  previousInput;
  input;
  constructor(t, n, a) {
    super(`Too many arguments for --${t}, encountered "${a}" after "${n}"`), this.externalFlagName = t, this.previousInput = n, this.input = a;
  }
};
function fe(e) {
  return e.kind === "counter" ? true : ("variadic" in e) ? !!e.variadic : false;
}
function B(e, t, n, a) {
  let r = e.get(n[0]) ?? [];
  if (r.length > 0 && !fe(n[1])) {
    let i = v(n[0], t);
    throw new Y(i, r[0], a);
  }
  e.set(n[0], [...r, a]);
}
function ie(e, t, n) {
  if (t.get(n)) {
    let r = e[n];
    return !fe(r);
  }
  return false;
}
function Q(e, t) {
  let { flags: n = {}, aliases: a = {}, positional: r = { kind: "tuple", parameters: [] } } = e, i = Me(n, a, t.caseStyle), o = [], d = new Map, m = 0, s, u = false;
  return { next: (l) => {
    if (!u && t.allowArgumentEscapeSequence && l === "--") {
      if (s)
        if (s[1].kind === "parsed" && s[1].inferEmpty)
          B(d, t.caseStyle, s, ""), s = undefined;
        else {
          let p = v(s[0], t.caseStyle);
          throw new X(p);
        }
      u = true;
      return;
    }
    if (!u) {
      let p = Ve(l, n, i, t);
      if (p) {
        if (s)
          if (s[1].kind === "parsed" && s[1].inferEmpty)
            B(d, t.caseStyle, s, ""), s = undefined;
          else {
            let f = v(s[0], t.caseStyle), T = v(p[0][0], t.caseStyle);
            throw new X(f, T);
          }
        B(d, t.caseStyle, ...p);
        return;
      }
      let c = je(l, n, i, t);
      if (c.length > 0) {
        if (s)
          if (s[1].kind === "parsed" && s[1].inferEmpty)
            B(d, t.caseStyle, s, ""), s = undefined;
          else {
            let f = v(s[0], t.caseStyle), T = v(c[0].namedFlag[0], t.caseStyle);
            throw new X(f, T);
          }
        if (c.every(ue))
          for (let f of c)
            f.namedFlag[1].kind === "boolean" ? B(d, t.caseStyle, f.namedFlag, f.negated ? "false" : "true") : B(d, t.caseStyle, f.namedFlag, "1");
        else if (c.length > 1) {
          let f = c.find((E) => !ue(E)), T = v(f.namedFlag[0], t.caseStyle);
          throw new X(T);
        } else
          s = c[0].namedFlag;
        return;
      }
    }
    if (s)
      B(d, t.caseStyle, s, l), s = undefined;
    else {
      if (r.kind === "tuple") {
        if (m >= r.parameters.length)
          throw new H(r.parameters.length, l);
      } else if (typeof r.maximum == "number" && m >= r.maximum)
        throw new H(r.maximum, l);
      o[m] = l, ++m;
    }
  }, parseArguments: async (l) => {
    let p = [], c;
    r.kind === "array" ? (typeof r.minimum == "number" && m < r.minimum && p.push(new _(ae(r.parameter), [r.minimum, m])), c = z(o.map(async (g, C) => {
      let y = ae(r.parameter, C + 1);
      return M(y, r.parameter, g, l);
    }))) : c = z(r.parameters.map(async (g, C) => {
      let y = ae(g, C + 1), N = o[C];
      if (typeof N != "string") {
        if (typeof g.default == "string")
          return M(y, g, g.default, l);
        if (g.optional)
          return;
        throw new _(y);
      }
      return M(y, g, N, l);
    })), s && s[1].kind === "parsed" && s[1].inferEmpty && (B(d, t.caseStyle, s, ""), s = undefined);
    let f = z(Object.entries(n).map(async (g) => {
      let [C, y] = g, N = v(C, t.caseStyle);
      if (s && s[0] === C)
        throw new X(N);
      let P = d.get(C), w = await We(N, y, P, t, l);
      return [C, w];
    })), [T, E] = await Promise.all([c, f]);
    if (T.status === "rejected")
      for (let g of T.reasons)
        p.push(g);
    if (E.status === "rejected")
      for (let g of E.reasons)
        p.push(g);
    if (p.length > 0)
      return { success: false, errors: p };
    if (T.status === "rejected")
      throw new x("Unknown failure while scanning positional arguments");
    if (E.status === "rejected")
      throw new x("Unknown failure while scanning flag arguments");
    return { success: true, arguments: [Object.fromEntries(E.value), ...T.value] };
  }, proposeCompletions: async ({ partial: l, completionConfig: p, text: c, context: f, includeVersionFlag: T }) => {
    if (s) {
      let F = s[1], g;
      return F.kind === "enum" ? g = F.values : F.proposeCompletions ? g = await F.proposeCompletions.call(f, l) : g = [], g.map((C) => ({ kind: "argument:value", completion: C, brief: F.brief })).filter(({ completion: C }) => C.startsWith(l));
    }
    let E = [];
    if (!u) {
      let F = ce.exec(l);
      if (p.includeAliases) {
        if (l === "" || l === "-") {
          let g = Object.entries(a).filter((C) => !ie(n, d, C[1]));
          for (let [C] of g) {
            let y = i[C];
            y && E.push({ kind: "argument:flag", completion: `-${C}`, brief: y[1].brief });
          }
        } else if (F) {
          let g = Array.from(F[1]);
          if (g.includes("h"))
            return [];
          if (T && g.includes("v"))
            return [];
          let C = new Map(d);
          for (let P of g) {
            let w = i[P];
            if (!w)
              throw new G(P);
            B(C, t.caseStyle, w, w[1].kind === "boolean" ? "true" : "1");
          }
          let y = g[g.length - 1];
          if (y) {
            let P = i[y];
            P && E.push({ kind: "argument:flag", completion: l, brief: P[1].brief });
          }
          let N = Object.entries(a).filter((P) => !ie(n, C, P[1]));
          for (let [P] of N) {
            let w = i[P];
            w && E.push({ kind: "argument:flag", completion: `${l}${P}`, brief: w[1].brief });
          }
        }
      }
      if (l === "" || l === "-" || l.startsWith("--")) {
        t.allowArgumentEscapeSequence && E.push({ kind: "argument:flag", completion: "--", brief: c.briefs.argumentEscapeSequence });
        let g = Object.entries(n).filter(([y]) => !ie(n, d, y));
        t.caseStyle === "allow-kebab-for-camel" && (g = g.map(([y, N]) => [A(y), N]));
        let C = g.map(([y, N]) => [`--${y}`, N]).filter(([y]) => y.startsWith(l));
        E.push(...C.map(([y, N]) => ({ kind: "argument:flag", completion: y, brief: N.brief })));
      }
    }
    if (r.kind === "array") {
      if (r.parameter.proposeCompletions && (typeof r.maximum != "number" || m < r.maximum)) {
        let F = await r.parameter.proposeCompletions.call(f, l);
        E.push(...F.map((g) => ({ kind: "argument:value", completion: g, brief: r.parameter.brief })));
      }
    } else {
      let F = r.parameters[m];
      if (F?.proposeCompletions) {
        let g = await F.proposeCompletions.call(f, l);
        E.push(...g.map((C) => ({ kind: "argument:value", completion: C, brief: F.brief })));
      }
    }
    return E.filter(({ completion: F }) => F.startsWith(l));
  } };
}
function ge(e, t, n) {
  let a = t === "allow-kebab-for-camel" ? "convert-camel-to-kebab" : t, r = e.getAllEntries();
  return n.includeHiddenRoutes || (r = r.filter((i) => !i.hidden)), r.flatMap((i) => {
    let o = i.name[a];
    return n.includeAliases ? [o, ...i.aliases] : [o];
  });
}
var Ce = { headers: { usage: "USAGE", aliases: "ALIASES", commands: "COMMANDS", flags: "FLAGS", arguments: "ARGUMENTS" }, keywords: { default: "default =" }, briefs: { help: "Print help information and exit", helpAll: "Print help information (including hidden commands/flags) and exit", version: "Print version information and exit", argumentEscapeSequence: "All subsequent inputs should be interpreted as arguments" }, noCommandRegisteredForInput: ({ input: e, corrections: t }) => {
  let n = `No command registered for \`${e}\``;
  if (t.length > 0) {
    let a = V(t, { kind: "conjunctive", conjunction: "or", serialComma: true });
    return `${n}, did you mean ${a}?`;
  } else
    return n;
}, noTextAvailableForLocale: ({ requestedLocale: e, defaultLocale: t }) => `Application does not support "${e}" locale, defaulting to "${t}"`, exceptionWhileParsingArguments: (e) => e instanceof h ? se(e, {}) : `Unable to parse arguments, ${q(e)}`, exceptionWhileLoadingCommandFunction: (e) => `Unable to load command function, ${q(e)}`, exceptionWhileLoadingCommandContext: (e) => `Unable to load command context, ${q(e)}`, exceptionWhileRunningCommand: (e) => `Command failed, ${q(e)}`, commandErrorResult: (e) => e.message, currentVersionIsNotLatest: ({ currentVersion: e, latestVersion: t, upgradeCommand: n }) => n ? `Latest available version is ${t} (currently running ${e}), upgrade with "${n}"` : `Latest available version is ${t} (currently running ${e})` };
function ye(e) {
  if (e.startsWith("en"))
    return Ce;
}
function S(e, t, n) {
  return !n.disableAnsiColor && !K(e, "STRICLI_NO_COLOR") && (t.getColorDepth?.(e.env) ?? 1) >= 4;
}
async function xe({ loader: e, parameters: t }, { context: n, inputs: a, scannerConfig: r, errorFormatting: i, documentationConfig: o, determineExitCode: d }) {
  let m = e(), s;
  try {
    let l = Q(t, r);
    for (let c of a)
      l.next(c);
    let p = await l.parseArguments(n);
    if (p.success)
      s = p.arguments;
    else {
      let c = S(n.process, n.process.stderr, o);
      for (let f of p.errors) {
        let T = i.exceptionWhileParsingArguments(f, c);
        n.process.stderr.write(c ? `\x1B[1m\x1B[31m${T}\x1B[39m\x1B[22m
` : `${T}
`);
      }
      return b.InvalidArgument;
    }
  } catch (l) {
    let p = S(n.process, n.process.stderr, o), c = i.exceptionWhileParsingArguments(l, p);
    return n.process.stderr.write(p ? `\x1B[1m\x1B[31m${c}\x1B[39m\x1B[22m
` : `${c}
`), b.InvalidArgument;
  }
  let u;
  try {
    let l = await m;
    typeof l == "function" ? u = l : u = l.default;
  } catch (l) {
    let p = S(n.process, n.process.stderr, o), c = i.exceptionWhileLoadingCommandFunction(l, p);
    return n.process.stderr.write(p ? `\x1B[1m\x1B[31m${c}\x1B[39m\x1B[22m
` : `${c}
`), b.CommandLoadError;
  }
  try {
    let l = await u.call(n, ...s);
    if (l instanceof Error) {
      let p = S(n.process, n.process.stderr, o), c = i.commandErrorResult(l, p);
      return n.process.stderr.write(p ? `\x1B[1m\x1B[31m${c}\x1B[39m\x1B[22m
` : `${c}
`), d ? d(l) : b.CommandRunError;
    }
  } catch (l) {
    let p = S(n.process, n.process.stderr, o), c = i.exceptionWhileRunningCommand(l, p);
    return n.process.stderr.write(p ? `\x1B[1m\x1B[31m${c}\x1B[39m\x1B[22m
` : `${c}
`), d ? d(l) : b.CommandRunError;
  }
  return b.Success;
}
var R = Symbol("RouteMap");
var O = Symbol("Command");
function Z(e, t, n) {
  let a = [...n], r = [], i, o = e, d, m = true, s = false;
  return { next: (u) => {
    if (u === "--help" || u === "-h") {
      s = true, d || (d = o);
      return;
    } else if (u === "--helpAll" || u === "--help-all" || u === "-H") {
      s = "all", d || (d = o);
      return;
    }
    if (d) {
      r.push(u);
      return;
    }
    if (o.kind === O) {
      d = o, r.push(u);
      return;
    }
    let l = I(u), p = u, c = o.getRoutingTargetForInput(p);
    if (t.caseStyle === "allow-kebab-for-camel" && !c && (c = o.getRoutingTargetForInput(l), c && (p = l)), !c) {
      let f = o.getDefaultCommand();
      if (f) {
        m = false, i = [o, ""], r.push(u), o = f;
        return;
      }
      return { input: u, routeMap: o };
    }
    m = false, i = [o, u], o = c, a.push(u);
  }, finish: () => {
    if (d = d ?? o, d.kind === R && !s) {
      let l = d.getDefaultCommand();
      l && (i = [d, ""], d = l, m = false);
    }
    let u = i ? i[0].getOtherAliasesForInput(i[1], t.caseStyle) : { original: [], "convert-camel-to-kebab": [] };
    return { target: d, unprocessedInputs: r, helpRequested: s, prefix: a, rootLevel: m, aliases: u };
  } };
}
async function Te({ root: e, defaultText: t, config: n }, a, r) {
  let i = t;
  if (r.locale) {
    let l = n.localization.loadText(r.locale);
    if (l)
      i = l;
    else {
      let p = S(r.process, r.process.stderr, n.documentation), c = i.noTextAvailableForLocale({ requestedLocale: r.locale, defaultLocale: n.localization.defaultLocale, ansiColor: p });
      r.process.stderr.write(p ? `\x1B[1m\x1B[33m${c}\x1B[39m\x1B[22m
` : `${c}
`);
    }
  }
  if (n.versionInfo?.getLatestVersion && !K(r.process, "STRICLI_SKIP_VERSION_CHECK")) {
    let l;
    "currentVersion" in n.versionInfo ? l = n.versionInfo.currentVersion : l = await n.versionInfo.getCurrentVersion.call(r);
    let p = await n.versionInfo.getLatestVersion.call(r, l);
    if (p && l !== p) {
      let c = S(r.process, r.process.stderr, n.documentation), f = i.currentVersionIsNotLatest({ currentVersion: l, latestVersion: p, upgradeCommand: n.versionInfo.upgradeCommand, ansiColor: c });
      r.process.stderr.write(c ? `\x1B[1m\x1B[33m${f}\x1B[39m\x1B[22m
` : `${f}
`);
    }
  }
  let o = a.slice();
  if (n.versionInfo && (o[0] === "--version" || o[0] === "-v")) {
    let l;
    return "currentVersion" in n.versionInfo ? l = n.versionInfo.currentVersion : l = await n.versionInfo.getCurrentVersion.call(r), r.process.stdout.write(l + `
`), b.Success;
  }
  let d = Z(e, n.scanner, [n.name]), m;
  for (;o.length > 0 && !m; ) {
    let l = o.shift();
    m = d.next(l);
  }
  if (m) {
    let l = ge(m.routeMap, n.scanner.caseStyle, n.completion), p = D(m.input, l, n.scanner.distanceOptions).map((T) => `\`${T}\``), c = S(r.process, r.process.stderr, n.documentation), f = i.noCommandRegisteredForInput({ input: m.input, corrections: p, ansiColor: c });
    return r.process.stderr.write(c ? `\x1B[1m\x1B[31m${f}\x1B[39m\x1B[22m
` : `${f}
`), b.UnknownCommand;
  }
  let s = d.finish();
  if (s.helpRequested || s.target.kind === R) {
    let l = S(r.process, r.process.stdout, n.documentation);
    return r.process.stdout.write(s.target.formatHelp({ prefix: s.prefix, includeVersionFlag: !!n.versionInfo && s.rootLevel, includeArgumentEscapeSequenceFlag: n.scanner.allowArgumentEscapeSequence, includeHelpAllFlag: s.helpRequested === "all" || n.documentation.alwaysShowHelpAllFlag, includeHidden: s.helpRequested === "all", config: n.documentation, aliases: s.aliases[n.documentation.caseStyle], text: i, ansiColor: l })), b.Success;
  }
  let u;
  if ("forCommand" in r)
    try {
      u = await r.forCommand({ prefix: s.prefix });
    } catch (l) {
      let p = S(r.process, r.process.stderr, n.documentation), c = i.exceptionWhileLoadingCommandContext(l, p);
      return r.process.stderr.write(p ? `\x1B[1m\x1B[31m${c}\x1B[39m\x1B[22m` : c), b.ContextLoadError;
    }
  else
    u = r;
  return xe(s.target, { context: u, inputs: s.unprocessedInputs, scannerConfig: n.scanner, documentationConfig: n.documentation, errorFormatting: i, determineExitCode: n.determineExitCode });
}
function U(e, t) {
  return t === "convert-camel-to-kebab" ? A(e) : e;
}
function Fe(e, t) {
  return t === "convert-camel-to-kebab" ? `no-${A(e)}` : `no${e[0].toUpperCase()}${e.slice(1)}`;
}
function Ae(e) {
  let t = e.scanner?.caseStyle ?? "original", n;
  if (e.documentation?.caseStyle) {
    if (t === "original" && e.documentation.caseStyle === "convert-camel-to-kebab")
      throw new x("Cannot convert route and flag names on display but scan as original");
    n = e.documentation.caseStyle;
  } else
    t === "allow-kebab-for-camel" ? n = "convert-camel-to-kebab" : n = t;
  let a = { caseStyle: t, allowArgumentEscapeSequence: e.scanner?.allowArgumentEscapeSequence ?? false, distanceOptions: e.scanner?.distanceOptions ?? { threshold: 7, weights: { insertion: 1, deletion: 3, substitution: 2, transposition: 0 } } }, r = { alwaysShowHelpAllFlag: e.documentation?.alwaysShowHelpAllFlag ?? false, useAliasInUsageLine: e.documentation?.useAliasInUsageLine ?? false, onlyRequiredInUsageLine: e.documentation?.onlyRequiredInUsageLine ?? false, caseStyle: n, disableAnsiColor: e.documentation?.disableAnsiColor ?? false }, i = { includeAliases: e.completion?.includeAliases ?? r.useAliasInUsageLine, includeHiddenRoutes: e.completion?.includeHiddenRoutes ?? false, ...e.completion };
  return { ...e, scanner: a, completion: i, documentation: r, localization: { defaultLocale: "en", loadText: ye, ...e.localization } };
}
function He(e, t) {
  let n = Ae(t);
  if (e.kind === O && n.versionInfo) {
    if (e.usesFlag("version"))
      throw new x("Unable to use command with flag --version as root when version info is supplied");
    if (e.usesFlag("v"))
      throw new x("Unable to use command with alias -v as root when version info is supplied");
  }
  let a = n.localization.loadText(n.localization.defaultLocale);
  if (!a)
    throw new x(`No text available for the default locale "${n.localization.defaultLocale}"`);
  return { root: e, config: n, defaultText: a };
}
function le(e) {
  return "default" in e && typeof e.default < "u";
}
function k(e) {
  return e.optional ?? le(e);
}
function be(e) {
  return `(${e})`;
}
function Pe(e) {
  return `[${e}]`;
}
function Se(e) {
  return `${e}...`;
}
function Ye(e) {
  return `<${e}>`;
}
function Qe(e) {
  return `[<${e}>]`;
}
function Ze(e) {
  return `<${e}>...`;
}
function ee(e, t) {
  let n = Object.entries(e.flags ?? {}).filter(([, i]) => !(i.hidden || t.config.onlyRequiredInUsageLine && k(i))).map(([i, o]) => {
    let d = t.config.caseStyle === "convert-camel-to-kebab" ? `--${A(i)}` : `--${i}`;
    if (e.aliases && t.config.useAliasInUsageLine) {
      let s = Object.entries(e.aliases).filter((u) => u[1] === i);
      s.length === 1 && s[0] && (d = `-${s[0][0]}`);
    }
    if (o.kind === "boolean")
      return [o, d];
    if (o.kind === "enum" && typeof o.placeholder != "string")
      return [o, `${d} ${o.values.join("|")}`];
    let m = o.placeholder ?? "value";
    return [o, `${d} ${m}`];
  }).map(([i, o]) => i.kind === "parsed" && i.variadic ? k(i) ? Se(Pe(o)) : Se(be(o)) : k(i) ? Pe(o) : be(o)), a = [], r = e.positional;
  if (r)
    if (r.kind === "array")
      a = [Ze(r.parameter.placeholder ?? "args")];
    else {
      let i = r.parameters;
      t.config.onlyRequiredInUsageLine && (i = i.filter((o) => !o.optional && typeof o.default > "u")), a = i.map((o, d) => {
        let m = o.placeholder ?? `arg${d + 1}`;
        return o.optional || typeof o.default < "u" ? Qe(m) : Ye(m);
      });
    }
  return [...t.prefix, ...n, ...a].join(" ");
}
function ne(e, t, n) {
  let { keywords: a, briefs: r } = n.text, i = Object.entries(e).filter(([, m]) => !(m.hidden && !n.includeHidden)), o = i.some(([, m]) => k(m)), d = i.map(([m, s]) => {
    let u = Object.entries(t).filter((f) => f[1] === m).map(([f]) => `-${f}`), l = "--" + U(m, n.config.caseStyle);
    if (s.kind === "boolean" && s.default !== false) {
      let f = Fe(m, n.config.caseStyle);
      l = `${l}/--${f}`;
    }
    k(s) ? l = `[${l}]` : o && (l = ` ${l}`), s.kind === "parsed" && s.variadic && (l = `${l}...`);
    let p = [];
    if (s.kind === "enum") {
      let f = s.values.join("|");
      p.push(f);
    }
    if (le(s)) {
      let f = n.ansiColor ? `\x1B[90m${a.default}\x1B[39m` : a.default;
      p.push(`${f} ${s.default === "" ? '""' : String(s.default)}`);
    }
    let c = p.length > 0 ? `[${p.join(", ")}]` : undefined;
    return { aliases: u.join(" "), flagName: l, brief: s.brief, suffix: c, hidden: s.hidden };
  });
  if (d.push({ aliases: "-h", flagName: o ? " --help" : "--help", brief: r.help }), n.includeHelpAllFlag) {
    let m = U("helpAll", n.config.caseStyle);
    d.push({ aliases: "-H", flagName: o ? ` --${m}` : `--${m}`, brief: r.helpAll, hidden: !n.config.alwaysShowHelpAllFlag });
  }
  return n.includeVersionFlag && d.push({ aliases: "-v", flagName: o ? " --version" : "--version", brief: r.version }), n.includeArgumentEscapeSequenceFlag && d.push({ aliases: "", flagName: o ? " --" : "--", brief: r.argumentEscapeSequence }), $(d.map((m) => n.ansiColor ? [m.hidden ? `\x1B[90m${m.aliases}\x1B[39m` : `\x1B[97m${m.aliases}\x1B[39m`, m.hidden ? `\x1B[90m${m.flagName}\x1B[39m` : `\x1B[97m${m.flagName}\x1B[39m`, m.hidden ? `\x1B[90m${m.brief}\x1B[39m` : `\x1B[03m${m.brief}\x1B[23m`, m.suffix ?? ""] : [m.aliases, m.flagName, m.brief, m.suffix ?? ""]), [" ", "  ", " "]);
}
function* te(e) {
  if (yield e.config.useAliasInUsageLine ? "-h" : "--help", e.includeHelpAllFlag) {
    let t = U("helpAll", e.config.caseStyle);
    yield e.config.useAliasInUsageLine ? "-H" : `--${t}`;
  }
  e.includeVersionFlag && (yield e.config.useAliasInUsageLine ? "-v" : "--version");
}
function Re(e, t) {
  if (e.kind === "array") {
    let r = e.parameter.placeholder ?? "args", i = t.ansiColor ? `\x1B[97m${r}...\x1B[39m` : `${r}...`, o = t.ansiColor ? `\x1B[3m${e.parameter.brief}\x1B[23m` : e.parameter.brief;
    return $([[i, o]], ["  "]);
  }
  let { keywords: n } = t.text, a = e.parameters.some((r) => r.optional);
  return $(e.parameters.map((r, i) => {
    let o = r.placeholder ?? `arg${i + 1}`, d;
    return r.optional ? o = `[${o}]` : a && (o = ` ${o}`), r.default && (d = `[${t.ansiColor ? `\x1B[90m${n.default}\x1B[39m` : n.default} ${r.default}]`), [t.ansiColor ? `\x1B[97m${o}\x1B[39m` : o, t.ansiColor ? `\x1B[3m${r.brief}\x1B[23m` : r.brief, d ?? ""];
  }), ["  ", " "]);
}
function* Oe(e, t, n) {
  let { brief: a, fullDescription: r, customUsage: i } = t, { headers: o } = n.text, d = n.prefix.join(" ");
  if (yield n.ansiColor ? `\x1B[1m${o.usage}\x1B[22m` : o.usage, i)
    for (let s of i)
      if (typeof s == "string")
        yield `  ${d} ${s}`;
      else {
        let u = n.ansiColor ? `\x1B[3m${s.brief}\x1B[23m` : s.brief;
        yield `  ${d} ${s.input}
    ${u}`;
      }
  else
    yield `  ${ee(e, n)}`;
  for (let s of te(n))
    yield `  ${d} ${s}`;
  if (yield "", yield r ?? a, n.aliases && n.aliases.length > 0) {
    let s = n.prefix.slice(0, -1).join(" ");
    yield "", yield n.ansiColor ? `\x1B[1m${o.aliases}\x1B[22m` : o.aliases;
    for (let u of n.aliases)
      yield `  ${s} ${u}`;
  }
  yield "", yield n.ansiColor ? `\x1B[1m${o.flags}\x1B[22m` : o.flags;
  for (let s of ne(e.flags ?? {}, e.aliases ?? {}, n))
    yield `  ${s}`;
  let m = e.positional ?? { kind: "tuple", parameters: [] };
  if (m.kind === "array" || m.parameters.length > 0) {
    yield "", yield n.ansiColor ? `\x1B[1m${o.arguments}\x1B[22m` : o.arguments;
    for (let s of Re(m, n))
      yield `  ${s}`;
  }
}
function en(e, t) {
  for (let n of t)
    if (n in e)
      throw new x(`Unable to use reserved flag --${n}`);
}
function nn(e, t) {
  for (let n of t)
    if (n in e)
      throw new x(`Unable to use reserved alias -${n}`);
}
function* tn(e) {
  yield `no-${A(e)}`, yield `no${e[0].toUpperCase()}${e.slice(1)}`;
}
function rn(e) {
  let t = Object.entries(e).filter(([, n]) => n.kind === "boolean" && !n.optional);
  for (let [n] of t)
    for (let a of tn(n))
      if (a in e)
        throw new x(`Unable to allow negation for --${n} as it conflicts with --${a}`);
}
function on(e) {
  let { flags: t = {}, aliases: n = {} } = e.parameters;
  en(t, ["help", "helpAll", "help-all"]), nn(n, ["h", "H"]), rn(t);
  let a;
  return "func" in e ? a = async () => e.func : a = e.loader, { kind: O, loader: a, parameters: e.parameters, get brief() {
    return e.docs.brief;
  }, formatUsageLine: (r) => ee(e.parameters, r), formatHelp: (r) => [...Oe(e.parameters, e.docs, r)].join(`
`) + `
`, usesFlag: (r) => (r in t) || (r in n) };
}
function* Be(e, t, n) {
  let { brief: a, fullDescription: r, hideRoute: i } = t, { headers: o } = n.text;
  yield n.ansiColor ? `\x1B[1m${o.usage}\x1B[22m` : o.usage;
  for (let [l, p] of Object.entries(e))
    if (!i || !i[l] || n.includeHidden) {
      let c = n.config.caseStyle === "convert-camel-to-kebab" ? A(l) : l;
      yield `  ${p.formatUsageLine({ ...n, prefix: [...n.prefix, c] })}`;
    }
  let d = n.prefix.join(" ");
  for (let l of te(n))
    yield `  ${d} ${l}`;
  if (yield "", yield r ?? a, n.aliases && n.aliases.length > 0) {
    let l = n.prefix.slice(0, -1).join(" ");
    yield "", yield n.ansiColor ? `\x1B[1m${o.aliases}\x1B[22m` : o.aliases;
    for (let p of n.aliases)
      yield `  ${l} ${p}`;
  }
  yield "", yield n.ansiColor ? `\x1B[1m${o.flags}\x1B[22m` : o.flags;
  for (let l of ne({}, {}, n))
    yield `  ${l}`;
  yield "", yield n.ansiColor ? `\x1B[1m${o.commands}\x1B[22m` : o.commands;
  let s = Object.entries(e).filter(([l]) => !i || !i[l] || n.includeHidden).map(([l, p]) => ({ routeName: U(l, n.config.caseStyle), brief: p.brief, hidden: i && i[l] })), u = $(s.map((l) => n.ansiColor ? [l.hidden ? `\x1B[90m${l.routeName}\x1B[39m` : `\x1B[97m${l.routeName}\x1B[39m`, l.hidden ? `\x1B[90m${l.brief}\x1B[39m` : `\x1B[03m${l.brief}\x1B[23m`] : [l.routeName, l.brief]), ["  "]);
  for (let l of u)
    yield `  ${l}`;
}
function an({ routes: e, defaultCommand: t, docs: n, aliases: a }) {
  if (Object.entries(e).length === 0)
    throw new x("Route map must contain at least one route");
  let r = a ?? {}, i = new Map;
  for (let [m, s] of Object.entries(r)) {
    if (m in e)
      throw new x(`Cannot use "${m}" as an alias when a route with that name already exists`);
    let u = i.get(s) ?? [];
    i.set(s, [...u, m]);
  }
  let o = t ? e[t] : undefined;
  if (o && o.kind === R)
    throw new x(`Cannot use "${t}" as the default command because it is not a Command`);
  let d = (m) => {
    if (m in r)
      return r[m];
    if (m in e)
      return m;
  };
  return { kind: R, get brief() {
    return n.brief;
  }, formatUsageLine(m) {
    let s = this.getAllEntries().filter((u) => !u.hidden).map((u) => u.name[m.config.caseStyle]);
    return `${m.prefix.join(" ")} ${s.join("|")} ...`;
  }, formatHelp: (m) => [...Be(e, n, m)].join(`
`) + `
`, getDefaultCommand: () => o, getOtherAliasesForInput: (m, s) => {
    if (t) {
      if (m === t)
        return { original: [""], "convert-camel-to-kebab": [""] };
      if (m === "")
        return { original: [t], "convert-camel-to-kebab": [t] };
    }
    let u = I(m), l = d(m);
    if (!l && s === "allow-kebab-for-camel" && (l = d(u)), !l)
      return { original: [], "convert-camel-to-kebab": [] };
    let p = [l, ...i.get(l) ?? []].filter((c) => c !== m && c !== u);
    return { original: p, "convert-camel-to-kebab": p.map(A) };
  }, getRoutingTargetForInput: (m) => {
    let s = m in r ? r[m] : m;
    return e[s];
  }, getAllEntries() {
    let m = n.hideRoute;
    return Object.entries(e).map(([s, u]) => ({ name: { original: s, "convert-camel-to-kebab": A(s) }, target: u, aliases: i.get(s) ?? [], hidden: m?.[s] ?? false }));
  } };
}
async function zt(e, t, n) {
  let a = await Te(e, t, n);
  n.process.exitCode = a;
}

// src/mcp-server/mcp-server.ts
import process3 from "node:process";

// src/mcp-server/cli.ts
function buildContext(process2) {
  return { process: process2 };
}

// src/mcp-server/cli/start/command.ts
init_lib();
init_console_logger();

// src/mcp-server/scopes.ts
var mcpScopes = [];

// src/mcp-server/cli/start/command.ts
var startCommand = on({
  loader: async () => {
    const { main: main2 } = await Promise.resolve().then(() => (init_impl(), exports_impl));
    return main2;
  },
  parameters: {
    flags: {
      transport: {
        kind: "enum",
        brief: "The transport to use for communicating with the server",
        default: "stdio",
        values: ["stdio", "sse"]
      },
      port: {
        kind: "parsed",
        brief: "The port to use when the SSE transport is enabled",
        default: "2718",
        parse: (val) => coerce.number().int().gte(0).lt(65536).parse(val)
      },
      tool: {
        kind: "parsed",
        brief: "Specify tools to mount on the server",
        optional: true,
        variadic: true,
        parse: (value) => {
          return stringType().parse(value);
        }
      },
      ...mcpScopes.length ? {
        scope: {
          kind: "enum",
          brief: "Mount tools/resources that match given scope (repeatable flag)",
          values: mcpScopes,
          variadic: true,
          optional: true
        }
      } : {},
      oauth2: {
        kind: "parsed",
        brief: "Sets the oauth2 auth field for the API",
        optional: true,
        parse: (value) => {
          return stringType().parse(value);
        }
      },
      "api-key-auth": {
        kind: "parsed",
        brief: "Sets the apiKeyAuth auth field for the API",
        optional: true,
        parse: (value) => {
          return stringType().parse(value);
        }
      },
      "server-url": {
        kind: "parsed",
        brief: "Overrides the default server URL used by the SDK",
        optional: true,
        parse: (value) => new URL(value).toString()
      },
      "server-index": {
        kind: "parsed",
        brief: "Selects a predefined server used by the SDK",
        optional: true,
        parse: oe
      },
      "log-level": {
        kind: "enum",
        brief: "The log level to use for the server",
        default: "info",
        values: consoleLoggerLevels
      },
      env: {
        kind: "parsed",
        brief: "Environment variables made available to the server",
        optional: true,
        variadic: true,
        parse: (val) => {
          const sepIdx = val.indexOf("=");
          if (sepIdx === -1) {
            throw new Error("Invalid environment variable format");
          }
          const key = val.slice(0, sepIdx);
          const value = val.slice(sepIdx + 1);
          return [
            stringType().nonempty({
              message: "Environment variable key must be a non-empty string"
            }).parse(key),
            stringType().nonempty({
              message: "Environment variable value must be a non-empty string"
            }).parse(value)
          ];
        }
      }
    }
  },
  docs: {
    brief: "Run the Model Context Protocol server"
  }
});

// src/mcp-server/mcp-server.ts
var routes = an({
  routes: {
    start: startCommand
  },
  docs: {
    brief: "MCP server CLI"
  }
});
var app = He(routes, {
  name: "mcp",
  versionInfo: {
    currentVersion: "0.3.8"
  }
});
zt(app, process3.argv.slice(2), buildContext(process3));
export {
  app
};

//# debugId=0556E1FB98F0B37364756E2164756E21
//# sourceMappingURL=mcp-server.js.map
