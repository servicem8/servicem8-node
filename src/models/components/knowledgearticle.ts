/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Record active/deleted flag.  Valid values are [0,1]
 */
export const KnowledgeArticleActive = {
  Zero: 0,
  One: 1,
} as const;
/**
 * Record active/deleted flag.  Valid values are [0,1]
 */
export type KnowledgeArticleActive = ClosedEnum<typeof KnowledgeArticleActive>;

export const ObjectName = {
  JobMixed: "Job",
  JobLower: "job",
} as const;
export type ObjectName = ClosedEnum<typeof ObjectName>;

export type Relationship = {
  objectName: ObjectName;
  objectUuid: string;
  objectDescription?: string | undefined;
  createDate?: string | undefined;
};

export type KnowledgeArticle = {
  /**
   * Unique identifier for this record
   */
  uuid?: string | undefined;
  /**
   * Record active/deleted flag.  Valid values are [0,1]
   */
  active?: KnowledgeArticleActive | undefined;
  /**
   * Timestamp at which record was last modified
   */
  editDate?: any | undefined;
  /**
   * Title of the knowledge article. This is a mandatory field with a maximum length of 100 characters. Used for identifying and searching for articles in the knowledge base.
   */
  name: string;
  /**
   * The main content of the knowledge article. For 'richtext' and 'pdf' articles, this contains HTML formatted text. For 'video' articles, this may contain supplementary information. For 'call' articles, this contains call details. Supports extended text length.
   */
  content?: string | undefined;
  /**
   * Type of knowledge article. Valid values are 'video', 'richtext', 'pdf', or 'call'. This determines how the article content is presented and processed in the system.
   */
  articleType?: string | undefined;
  /**
   * Comma-separated list of tags associated with this knowledge article. Maximum length is 2000 characters. Tags are used for categorization, searching, and automatic relationship generation with other objects like Services, Materials, and Companies.
   */
  tags?: string | undefined;
  /**
   * JSON array of manually created relationships between this knowledge article and other objects. Contains objects with properties: object_name (e.g., 'job'), object_uuid (the related object's UUID), object_description (a description of the related object), and create_date. Used to associate articles with specific jobs or other system objects.
   */
  relationships?: Array<Relationship> | undefined;
};

export type KnowledgeArticleInput = {
  /**
   * Unique identifier for this record
   */
  uuid?: string | undefined;
  /**
   * Record active/deleted flag.  Valid values are [0,1]
   */
  active?: KnowledgeArticleActive | undefined;
  /**
   * Title of the knowledge article. This is a mandatory field with a maximum length of 100 characters. Used for identifying and searching for articles in the knowledge base.
   */
  name: string;
  /**
   * The main content of the knowledge article. For 'richtext' and 'pdf' articles, this contains HTML formatted text. For 'video' articles, this may contain supplementary information. For 'call' articles, this contains call details. Supports extended text length.
   */
  content?: string | undefined;
  /**
   * Type of knowledge article. Valid values are 'video', 'richtext', 'pdf', or 'call'. This determines how the article content is presented and processed in the system.
   */
  articleType?: string | undefined;
  /**
   * Comma-separated list of tags associated with this knowledge article. Maximum length is 2000 characters. Tags are used for categorization, searching, and automatic relationship generation with other objects like Services, Materials, and Companies.
   */
  tags?: string | undefined;
  /**
   * JSON array of manually created relationships between this knowledge article and other objects. Contains objects with properties: object_name (e.g., 'job'), object_uuid (the related object's UUID), object_description (a description of the related object), and create_date. Used to associate articles with specific jobs or other system objects.
   */
  relationships?: Array<Relationship> | undefined;
};

/** @internal */
export const KnowledgeArticleActive$inboundSchema: z.ZodNativeEnum<
  typeof KnowledgeArticleActive
> = z.nativeEnum(KnowledgeArticleActive);

/** @internal */
export const KnowledgeArticleActive$outboundSchema: z.ZodNativeEnum<
  typeof KnowledgeArticleActive
> = KnowledgeArticleActive$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeArticleActive$ {
  /** @deprecated use `KnowledgeArticleActive$inboundSchema` instead. */
  export const inboundSchema = KnowledgeArticleActive$inboundSchema;
  /** @deprecated use `KnowledgeArticleActive$outboundSchema` instead. */
  export const outboundSchema = KnowledgeArticleActive$outboundSchema;
}

/** @internal */
export const ObjectName$inboundSchema: z.ZodNativeEnum<typeof ObjectName> = z
  .nativeEnum(ObjectName);

/** @internal */
export const ObjectName$outboundSchema: z.ZodNativeEnum<typeof ObjectName> =
  ObjectName$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectName$ {
  /** @deprecated use `ObjectName$inboundSchema` instead. */
  export const inboundSchema = ObjectName$inboundSchema;
  /** @deprecated use `ObjectName$outboundSchema` instead. */
  export const outboundSchema = ObjectName$outboundSchema;
}

/** @internal */
export const Relationship$inboundSchema: z.ZodType<
  Relationship,
  z.ZodTypeDef,
  unknown
> = z.object({
  object_name: ObjectName$inboundSchema,
  object_uuid: z.string(),
  object_description: z.string().optional(),
  create_date: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "object_name": "objectName",
    "object_uuid": "objectUuid",
    "object_description": "objectDescription",
    "create_date": "createDate",
  });
});

/** @internal */
export type Relationship$Outbound = {
  object_name: string;
  object_uuid: string;
  object_description?: string | undefined;
  create_date?: string | undefined;
};

/** @internal */
export const Relationship$outboundSchema: z.ZodType<
  Relationship$Outbound,
  z.ZodTypeDef,
  Relationship
> = z.object({
  objectName: ObjectName$outboundSchema,
  objectUuid: z.string(),
  objectDescription: z.string().optional(),
  createDate: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    objectName: "object_name",
    objectUuid: "object_uuid",
    objectDescription: "object_description",
    createDate: "create_date",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Relationship$ {
  /** @deprecated use `Relationship$inboundSchema` instead. */
  export const inboundSchema = Relationship$inboundSchema;
  /** @deprecated use `Relationship$outboundSchema` instead. */
  export const outboundSchema = Relationship$outboundSchema;
  /** @deprecated use `Relationship$Outbound` instead. */
  export type Outbound = Relationship$Outbound;
}

export function relationshipToJSON(relationship: Relationship): string {
  return JSON.stringify(Relationship$outboundSchema.parse(relationship));
}

export function relationshipFromJSON(
  jsonString: string,
): SafeParseResult<Relationship, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Relationship$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Relationship' from JSON`,
  );
}

/** @internal */
export const KnowledgeArticle$inboundSchema: z.ZodType<
  KnowledgeArticle,
  z.ZodTypeDef,
  unknown
> = z.object({
  uuid: z.string().optional(),
  active: KnowledgeArticleActive$inboundSchema.default(1),
  edit_date: z.any().optional(),
  name: z.string(),
  content: z.string().optional(),
  article_type: z.string().optional(),
  tags: z.string().optional(),
  relationships: z.array(z.lazy(() => Relationship$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "edit_date": "editDate",
    "article_type": "articleType",
  });
});

/** @internal */
export type KnowledgeArticle$Outbound = {
  uuid?: string | undefined;
  active: number;
  edit_date?: any | undefined;
  name: string;
  content?: string | undefined;
  article_type?: string | undefined;
  tags?: string | undefined;
  relationships?: Array<Relationship$Outbound> | undefined;
};

/** @internal */
export const KnowledgeArticle$outboundSchema: z.ZodType<
  KnowledgeArticle$Outbound,
  z.ZodTypeDef,
  KnowledgeArticle
> = z.object({
  uuid: z.string().optional(),
  active: KnowledgeArticleActive$outboundSchema.default(1),
  editDate: z.any().optional(),
  name: z.string(),
  content: z.string().optional(),
  articleType: z.string().optional(),
  tags: z.string().optional(),
  relationships: z.array(z.lazy(() => Relationship$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    editDate: "edit_date",
    articleType: "article_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeArticle$ {
  /** @deprecated use `KnowledgeArticle$inboundSchema` instead. */
  export const inboundSchema = KnowledgeArticle$inboundSchema;
  /** @deprecated use `KnowledgeArticle$outboundSchema` instead. */
  export const outboundSchema = KnowledgeArticle$outboundSchema;
  /** @deprecated use `KnowledgeArticle$Outbound` instead. */
  export type Outbound = KnowledgeArticle$Outbound;
}

export function knowledgeArticleToJSON(
  knowledgeArticle: KnowledgeArticle,
): string {
  return JSON.stringify(
    KnowledgeArticle$outboundSchema.parse(knowledgeArticle),
  );
}

export function knowledgeArticleFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeArticle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeArticle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeArticle' from JSON`,
  );
}

/** @internal */
export const KnowledgeArticleInput$inboundSchema: z.ZodType<
  KnowledgeArticleInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  uuid: z.string().optional(),
  active: KnowledgeArticleActive$inboundSchema.default(1),
  name: z.string(),
  content: z.string().optional(),
  article_type: z.string().optional(),
  tags: z.string().optional(),
  relationships: z.array(z.lazy(() => Relationship$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "article_type": "articleType",
  });
});

/** @internal */
export type KnowledgeArticleInput$Outbound = {
  uuid?: string | undefined;
  active: number;
  name: string;
  content?: string | undefined;
  article_type?: string | undefined;
  tags?: string | undefined;
  relationships?: Array<Relationship$Outbound> | undefined;
};

/** @internal */
export const KnowledgeArticleInput$outboundSchema: z.ZodType<
  KnowledgeArticleInput$Outbound,
  z.ZodTypeDef,
  KnowledgeArticleInput
> = z.object({
  uuid: z.string().optional(),
  active: KnowledgeArticleActive$outboundSchema.default(1),
  name: z.string(),
  content: z.string().optional(),
  articleType: z.string().optional(),
  tags: z.string().optional(),
  relationships: z.array(z.lazy(() => Relationship$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    articleType: "article_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeArticleInput$ {
  /** @deprecated use `KnowledgeArticleInput$inboundSchema` instead. */
  export const inboundSchema = KnowledgeArticleInput$inboundSchema;
  /** @deprecated use `KnowledgeArticleInput$outboundSchema` instead. */
  export const outboundSchema = KnowledgeArticleInput$outboundSchema;
  /** @deprecated use `KnowledgeArticleInput$Outbound` instead. */
  export type Outbound = KnowledgeArticleInput$Outbound;
}

export function knowledgeArticleInputToJSON(
  knowledgeArticleInput: KnowledgeArticleInput,
): string {
  return JSON.stringify(
    KnowledgeArticleInput$outboundSchema.parse(knowledgeArticleInput),
  );
}

export function knowledgeArticleInputFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeArticleInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeArticleInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeArticleInput' from JSON`,
  );
}
